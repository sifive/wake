
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>core &#8212; wake-manual  documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="nothing" href="../nothing/nothing.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="core">
<h1>core<a class="headerlink" href="#core" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<div class="section" id="tuple-wake">
<h2>tuple.wake<a class="headerlink" href="#tuple-wake" title="Permalink to this headline">¶</a></h2>
<dl class="data">
<dt id="function-data Unit">
<code class="descname">data Unit</code><a class="headerlink" href="#function-data Unit" title="Permalink to this definition">¶</a></dt>
<dd><p>unit / void</p>
</dd></dl>

<dl class="tuple">
<dt id="function-tuple Pair a b">
<code class="descname">tuple Pair a b</code><a class="headerlink" href="#function-tuple Pair a b" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a <code class="docutils literal notranslate"><span class="pre">Pair</span></code>, a tuple containing two elements.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">First:</span> <span class="pre">a,</span>&#160; <span class="pre">Second:</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Pair</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
</dd></dl>

<dl class="tuple">
<dt id="function-tuple Triple a b c">
<code class="descname">tuple Triple a b c</code><a class="headerlink" href="#function-tuple Triple a b c" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a <code class="docutils literal notranslate"><span class="pre">Triple</span></code>, a tuple containing three elements.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">First:</span> <span class="pre">a,</span>&#160; <span class="pre">Second:</span> <span class="pre">b,</span>&#160; <span class="pre">Third:</span> <span class="pre">c</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Triple</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">c</span></code></p>
</dd></dl>

<dl class="data">
<dt id="function-data a; b">
<code class="descname">data a; b</code><a class="headerlink" href="#function-data a; b" title="Permalink to this definition">¶</a></dt>
<dd><p>Variable length Tuples (terminate with Unit if you want ._x accessors)
aka: a List with fixed length and heterogeneous element types
Examples:
def tup = (1; “xx”; 1e8; Unit)
def (x; y; z; Unit) = tup
def _ = println (str tup._0)
def _ = println (dstr tup._2)
def (a; b) = (5; “z”)</p>
</dd></dl>

<dl class="function">
<dt id="function-def _0 (x; _)">
<code class="descname">def _0 (x; _)</code><a class="headerlink" href="#function-def _0 (x; _)" title="Permalink to this definition">¶</a></dt>
<dd><p>Handy accessor methods</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">;</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def _1 (_; x; _)">
<code class="descname">def _1 (_; x; _)</code><a class="headerlink" href="#function-def _1 (_; x; _)" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">;</span> <span class="pre">b</span> <span class="pre">;</span> <span class="pre">c</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def _2 (_; _; x; _)">
<code class="descname">def _2 (_; _; x; _)</code><a class="headerlink" href="#function-def _2 (_; _; x; _)" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">;</span> <span class="pre">b</span> <span class="pre">;</span> <span class="pre">c</span> <span class="pre">;</span> <span class="pre">d</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">c</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def _3 (_; _; _; x; _)">
<code class="descname">def _3 (_; _; _; x; _)</code><a class="headerlink" href="#function-def _3 (_; _; _; x; _)" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">;</span> <span class="pre">b</span> <span class="pre">;</span> <span class="pre">c</span> <span class="pre">;</span> <span class="pre">d</span> <span class="pre">;</span> <span class="pre">e</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">d</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def _4 (_; _; _; _; x; _)">
<code class="descname">def _4 (_; _; _; _; x; _)</code><a class="headerlink" href="#function-def _4 (_; _; _; _; x; _)" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">;</span> <span class="pre">b</span> <span class="pre">;</span> <span class="pre">c</span> <span class="pre">;</span> <span class="pre">d</span> <span class="pre">;</span> <span class="pre">e</span> <span class="pre">;</span> <span class="pre">f</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">e</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def _5 (_; _; _; _; _; x; _)">
<code class="descname">def _5 (_; _; _; _; _; x; _)</code><a class="headerlink" href="#function-def _5 (_; _; _; _; _; x; _)" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">;</span> <span class="pre">b</span> <span class="pre">;</span> <span class="pre">c</span> <span class="pre">;</span> <span class="pre">d</span> <span class="pre">;</span> <span class="pre">e</span> <span class="pre">;</span> <span class="pre">f</span> <span class="pre">;</span> <span class="pre">g</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">f</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def _6 (_; _; _; _; _; _; x; _)">
<code class="descname">def _6 (_; _; _; _; _; _; x; _)</code><a class="headerlink" href="#function-def _6 (_; _; _; _; _; _; x; _)" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">;</span> <span class="pre">b</span> <span class="pre">;</span> <span class="pre">c</span> <span class="pre">;</span> <span class="pre">d</span> <span class="pre">;</span> <span class="pre">e</span> <span class="pre">;</span> <span class="pre">f</span> <span class="pre">;</span> <span class="pre">g</span> <span class="pre">;</span> <span class="pre">h</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">g</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def _7 (_; _; _; _; _; _; _; x; _)">
<code class="descname">def _7 (_; _; _; _; _; _; _; x; _)</code><a class="headerlink" href="#function-def _7 (_; _; _; _; _; _; _; x; _)" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">;</span> <span class="pre">b</span> <span class="pre">;</span> <span class="pre">c</span> <span class="pre">;</span> <span class="pre">d</span> <span class="pre">;</span> <span class="pre">e</span> <span class="pre">;</span> <span class="pre">f</span> <span class="pre">;</span> <span class="pre">g</span> <span class="pre">;</span> <span class="pre">h</span> <span class="pre">;</span> <span class="pre">i</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">h</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def _8 (_; _; _; _; _; _; _; _; x; _)">
<code class="descname">def _8 (_; _; _; _; _; _; _; _; x; _)</code><a class="headerlink" href="#function-def _8 (_; _; _; _; _; _; _; _; x; _)" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">;</span> <span class="pre">b</span> <span class="pre">;</span> <span class="pre">c</span> <span class="pre">;</span> <span class="pre">d</span> <span class="pre">;</span> <span class="pre">e</span> <span class="pre">;</span> <span class="pre">f</span> <span class="pre">;</span> <span class="pre">g</span> <span class="pre">;</span> <span class="pre">h</span> <span class="pre">;</span> <span class="pre">i</span> <span class="pre">;</span> <span class="pre">j</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">i</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def _9 (_; _; _; _; _; _; _; _; _; x; _)">
<code class="descname">def _9 (_; _; _; _; _; _; _; _; _; x; _)</code><a class="headerlink" href="#function-def _9 (_; _; _; _; _; _; _; _; _; x; _)" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">;</span> <span class="pre">b</span> <span class="pre">;</span> <span class="pre">c</span> <span class="pre">;</span> <span class="pre">d</span> <span class="pre">;</span> <span class="pre">e</span> <span class="pre">;</span> <span class="pre">f</span> <span class="pre">;</span> <span class="pre">g</span> <span class="pre">;</span> <span class="pre">h</span> <span class="pre">;</span> <span class="pre">i</span> <span class="pre">;</span> <span class="pre">j</span> <span class="pre">;</span> <span class="pre">k</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">j</span></code></p>
</dd></dl>

</div>
<div class="section" id="boolean-wake">
<h2>boolean.wake<a class="headerlink" href="#boolean-wake" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="function-def !(x: Boolean): Boolean">
<code class="descname">def !(x: Boolean): Boolean</code><a class="headerlink" href="#function-def !(x: Boolean): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Unary operator for Boolean NOT.</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">!True</span>&#160; <span class="pre">=</span> <span class="pre">False</span>
<span class="pre">!False</span> <span class="pre">=</span> <span class="pre">True</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Boolean</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: Boolean) &amp;&amp; (y: Boolean): Boolean">
<code class="descname">def (x: Boolean) &amp;&amp; (y: Boolean): Boolean</code><a class="headerlink" href="#function-def (x: Boolean) && (y: Boolean): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary operator for Boolean AND; <cite>x &amp;&amp; y</cite>.
Both <cite>x</cite> and <cite>y</cite> must be True to return True.</p>
<p>## BEWARE: unlike other languages, in wake, expression ‘y’ is evaluated even if ‘x’ is False ##</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">True</span>&#160; <span class="pre">&amp;&amp;</span> <span class="pre">True</span>&#160; <span class="pre">=</span> <span class="pre">True</span>
<span class="pre">False</span> <span class="pre">&amp;&amp;</span> <span class="pre">True</span>&#160; <span class="pre">=</span> <span class="pre">False</span>
<span class="pre">True</span>&#160; <span class="pre">&amp;&amp;</span> <span class="pre">False</span> <span class="pre">=</span> <span class="pre">False</span>
<span class="pre">False</span> <span class="pre">&amp;&amp;</span> <span class="pre">False</span> <span class="pre">=</span> <span class="pre">False</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Boolean,</span>&#160; <span class="pre">y:</span> <span class="pre">Boolean</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: Boolean) || (y: Boolean): Boolean">
<code class="descname">def (x: Boolean) || (y: Boolean): Boolean</code><a class="headerlink" href="#function-def (x: Boolean) || (y: Boolean): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary operator for Boolean OR; <cite>x || y</cite>.
Either <cite>x</cite> or <cite>y</cite> must be True to return True.</p>
<p>## BEWARE: unlike other languages, in wake, expression ‘y’ is evaluated even if ‘x’ is True ##</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">True</span>&#160; <span class="pre">||</span> <span class="pre">True</span>&#160; <span class="pre">=</span> <span class="pre">True</span>
<span class="pre">False</span> <span class="pre">||</span> <span class="pre">True</span>&#160; <span class="pre">=</span> <span class="pre">True</span>
<span class="pre">True</span>&#160; <span class="pre">||</span> <span class="pre">False</span> <span class="pre">=</span> <span class="pre">True</span>
<span class="pre">False</span> <span class="pre">||</span> <span class="pre">False</span> <span class="pre">=</span> <span class="pre">False</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Boolean,</span>&#160; <span class="pre">y:</span> <span class="pre">Boolean</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def eor (x: Boolean) (y: Boolean): Boolean">
<code class="descname">def eor (x: Boolean) (y: Boolean): Boolean</code><a class="headerlink" href="#function-def eor (x: Boolean) (y: Boolean): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary operator for Boolean XOR/EOR; <cite>eor x y</cite>.
When <cite>x</cite> and <cite>y</cite> differ, returns True.</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">eor</span> <span class="pre">True</span>&#160; <span class="pre">True</span>&#160; <span class="pre">=</span> <span class="pre">False</span>
<span class="pre">eor</span> <span class="pre">False</span> <span class="pre">True</span>&#160; <span class="pre">=</span> <span class="pre">True</span>
<span class="pre">eor</span> <span class="pre">True</span>&#160; <span class="pre">False</span> <span class="pre">=</span> <span class="pre">True</span>
<span class="pre">eor</span> <span class="pre">False</span> <span class="pre">False</span> <span class="pre">=</span> <span class="pre">False</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Boolean,</span>&#160; <span class="pre">y:</span> <span class="pre">Boolean</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def enor (x: Boolean) (y: Boolean): Boolean">
<code class="descname">def enor (x: Boolean) (y: Boolean): Boolean</code><a class="headerlink" href="#function-def enor (x: Boolean) (y: Boolean): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary operator for Boolean XNOR/ENOR; <cite>enor x y</cite>.
When <cite>x</cite> and <cite>y</cite> are equal, returns True.</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">enor</span> <span class="pre">True</span>&#160; <span class="pre">True</span>&#160; <span class="pre">=</span> <span class="pre">True</span>
<span class="pre">enor</span> <span class="pre">False</span> <span class="pre">True</span>&#160; <span class="pre">=</span> <span class="pre">False</span>
<span class="pre">enor</span> <span class="pre">True</span>&#160; <span class="pre">False</span> <span class="pre">=</span> <span class="pre">False</span>
<span class="pre">enor</span> <span class="pre">False</span> <span class="pre">False</span> <span class="pre">=</span> <span class="pre">True</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Boolean,</span>&#160; <span class="pre">y:</span> <span class="pre">Boolean</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

</div>
<div class="section" id="regexp-wake">
<h2>regexp.wake<a class="headerlink" href="#regexp-wake" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="function-def quote (str: String): RegExp">
<code class="descname">def quote (str: String): RegExp</code><a class="headerlink" href="#function-def quote (str: String): RegExp" title="Permalink to this definition">¶</a></dt>
<dd><p>Create RegExp that only matches str, by escaping special characters.
quote “a.b” = <cite>a.b</cite>
quote “hello[world]” = <cite>hello[world]</cite></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">str:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">RegExp</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def regExpCat (l: List RegExp): RegExp">
<code class="descname">def regExpCat (l: List RegExp): RegExp</code><a class="headerlink" href="#function-def regExpCat (l: List RegExp): RegExp" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate a list of regular expressions.
The resulting regular expression must match the elements sequentially.
For simple expressions, use built-in RegExp interpolation <cite>${x}${y}${z}</cite>.
regExpCast (<cite>abc</cite>, <cite>def</cite>, Nil) = <cite>abcdef</cite></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">l:</span> <span class="pre">List</span> <span class="pre">RegExp</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">RegExp</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def stringToRegExp (str: String): Result RegExp Error">
<code class="descname">def stringToRegExp (str: String): Result RegExp Error</code><a class="headerlink" href="#function-def stringToRegExp (str: String): Result RegExp Error" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a String into a Regular expression.
If the string is an illegal RegExp, returns Fail.
stringToRegExp “abc” = Pass <cite>abc</cite>
stringToRegExp “a(”  = Fail (Error “missing ): a(” _)</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">str:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Result</span> <span class="pre">RegExp</span> <span class="pre">Error</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def globToRegExp (glob: String): RegExp">
<code class="descname">def globToRegExp (glob: String): RegExp</code><a class="headerlink" href="#function-def globToRegExp (glob: String): RegExp" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a String glob-style expression into a RegExp.
A glob expression has:
?    matches any single non-/ character
*    matches 0 or more non-/ characters
/**  matches any path after the /
<a href="#id1"><span class="problematic" id="id2">**</span></a>/  matches any path leading up to the /
[ab] matches either a or b
*   matches a *</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">glob:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">RegExp</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def regExpToString (regExp: RegExp): String">
<code class="descname">def regExpToString (regExp: RegExp): String</code><a class="headerlink" href="#function-def regExpToString (regExp: RegExp): String" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a regular expression into a String.
stringToRegExp (regExpToString x) = Pass x
regExpToString <cite>abc</cite> = “abc”
regExpToString <cite>.*</cite>  = “.*”</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">regExp:</span> <span class="pre">RegExp</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">String</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def matches (testRegExp: RegExp) (str: String): Boolean">
<code class="descname">def matches (testRegExp: RegExp) (str: String): Boolean</code><a class="headerlink" href="#function-def matches (testRegExp: RegExp) (str: String): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if a regular expression matches an entire String.
matches <cite>a*</cite> “ba” = False
matches <cite>a*</cite> “aa” = True</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">testRegExp:</span> <span class="pre">RegExp,</span>&#160; <span class="pre">str:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def extract (parensRegexp: RegExp) (str: String): List String">
<code class="descname">def extract (parensRegexp: RegExp) (str: String): List String</code><a class="headerlink" href="#function-def extract (parensRegexp: RegExp) (str: String): List String" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract fields out of a String using a parenthetical regular expression.
extract <cite>(.*)-(.*)</cite> “hello-world-hello” = (“hello”, “world-hello”, Nil)
extract <cite>(.*)-(.*)</cite> “helloworldhello” = Nil</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">parensRegexp:</span> <span class="pre">RegExp,</span>&#160; <span class="pre">str:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">String</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def replace (locatorRegExp: RegExp) (replacement: String) (str: String): String">
<code class="descname">def replace (locatorRegExp: RegExp) (replacement: String) (str: String): String</code><a class="headerlink" href="#function-def replace (locatorRegExp: RegExp) (replacement: String) (str: String): String" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace all occurances of locatorRegExp in str with replacement.
replace <cite>:</cite> ” ” “a:b:c” = “a b c”</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">locatorRegExp:</span> <span class="pre">RegExp,</span>&#160; <span class="pre">replacement:</span> <span class="pre">String,</span>&#160; <span class="pre">str:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">String</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tokenize (seperatorRegExp: RegExp) (str: String): List String">
<code class="descname">def tokenize (seperatorRegExp: RegExp) (str: String): List String</code><a class="headerlink" href="#function-def tokenize (seperatorRegExp: RegExp) (str: String): List String" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all occurances of seperatorRegExp from str, creating a List of String fragments.
tokenize <cite>:</cite> “hello:there:friend” = (“hello”, “there”, “friend”, Nil)</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">seperatorRegExp:</span> <span class="pre">RegExp,</span>&#160; <span class="pre">str:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">String</span></code></p>
</dd></dl>

</div>
<div class="section" id="result-wake">
<h2>result.wake<a class="headerlink" href="#result-wake" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="function-def isPass: Result a b =&gt; Boolean">
<code class="descname">def isPass: Result a b =&gt; Boolean</code><a class="headerlink" href="#function-def isPass: Result a b => Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>isPass: report if the Result was a Pass</p>
<p>isPass (Pass 123) = True
isPass (Fail 123) = False</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">Result</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def isFail: Result a b =&gt; Boolean">
<code class="descname">def isFail: Result a b =&gt; Boolean</code><a class="headerlink" href="#function-def isFail: Result a b => Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>isFail: report if the Result was a Fail</p>
<p>isFail (Pass 123) = False
isFail (Fail 123) = True</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">Result</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def getPass: Result a b =&gt; Option a">
<code class="descname">def getPass: Result a b =&gt; Option a</code><a class="headerlink" href="#function-def getPass: Result a b => Option a" title="Permalink to this definition">¶</a></dt>
<dd><p>getPass: retrieve the Pass value else None</p>
<p>getPass (Pass 123) = Some 123
getPass (Fail 123) = None</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">Result</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def getFail: Result a b =&gt; Option b">
<code class="descname">def getFail: Result a b =&gt; Option b</code><a class="headerlink" href="#function-def getFail: Result a b => Option b" title="Permalink to this definition">¶</a></dt>
<dd><p>getFail: retrieve the Fail value else None</p>
<p>getFail (Pass 123) = None
getFail (Fail 123) = Some 123</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">Result</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def getWhenFail (default: pass): Result pass fail =&gt; pass">
<code class="descname">def getWhenFail (default: pass): Result pass fail =&gt; pass</code><a class="headerlink" href="#function-def getWhenFail (default: pass): Result pass fail => pass" title="Permalink to this definition">¶</a></dt>
<dd><p>getWhenFail: retrieve the Pass value, using a default value for Fail</p>
<p>getWhenFail 42 (Pass 123) = 123
getWhenFail 42 (Pass 123) = 42</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">default:</span> <span class="pre">a,</span>&#160; <span class="pre">Result</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def getWhenPass (default: fail): Result pass fail =&gt; fail">
<code class="descname">def getWhenPass (default: fail): Result pass fail =&gt; fail</code><a class="headerlink" href="#function-def getWhenPass (default: fail): Result pass fail => fail" title="Permalink to this definition">¶</a></dt>
<dd><p>getWhenPass: retrieve the Fail value, using a default value for Pass</p>
<p>getWhenPass 42 (Pass 123) = 42
getWhenPass 42 (Pass 123) = 123</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">default:</span> <span class="pre">a,</span>&#160; <span class="pre">Result</span> <span class="pre">b</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def rmap (fn: a =&gt; b): Result a fail =&gt; Result b fail">
<code class="descname">def rmap (fn: a =&gt; b): Result a fail =&gt; Result b fail</code><a class="headerlink" href="#function-def rmap (fn: a => b): Result a fail => Result b fail" title="Permalink to this definition">¶</a></dt>
<dd><p>rmap: apply a function to a Pass-ing result
If you find yourself using the function, consider using require instead.</p>
<p>rmap (_+1) (Pass 123) = Pass 124
rmap (_+1) (Fail 123) = Fail 123</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">fn:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">Result</span> <span class="pre">a</span> <span class="pre">c</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Result</span> <span class="pre">b</span> <span class="pre">c</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def rmapPass (fn: a =&gt; Result b fail): Result a fail =&gt; Result b fail">
<code class="descname">def rmapPass (fn: a =&gt; Result b fail): Result a fail =&gt; Result b fail</code><a class="headerlink" href="#function-def rmapPass (fn: a => Result b fail): Result a fail => Result b fail" title="Permalink to this definition">¶</a></dt>
<dd><p>rmapPass: apply a fallible function a Pass-ing result
If you find yourself using the function, consider using require instead.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">fn:</span> <span class="pre">a,</span>&#160; <span class="pre">Result</span> <span class="pre">b</span> <span class="pre">c,</span>&#160; <span class="pre">Result</span> <span class="pre">a</span> <span class="pre">c</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Result</span> <span class="pre">b</span> <span class="pre">c</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def rmapFail (fn: a =&gt; Result pass b): Result pass a =&gt; Result pass b">
<code class="descname">def rmapFail (fn: a =&gt; Result pass b): Result pass a =&gt; Result pass b</code><a class="headerlink" href="#function-def rmapFail (fn: a => Result pass b): Result pass a => Result pass b" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a fallible function to Fail value or propogates Pass
If you find yourself using the function, consider using require instead.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">fn:</span> <span class="pre">a,</span>&#160; <span class="pre">Result</span> <span class="pre">b</span> <span class="pre">c,</span>&#160; <span class="pre">Result</span> <span class="pre">b</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Result</span> <span class="pre">b</span> <span class="pre">c</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def rfoldl (combiningFn: accumulator">
<code class="descname">def rfoldl (combiningFn: accumulator</code><a class="headerlink" href="#function-def rfoldl (combiningFn: accumulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to combine the elements of a <cite>List</cite> front-to-back, where each step might fail.
If any update step fails, the error value of the first such failure is
returned and no further values are processed.</p>
<p>Parameters:
- <cite>combiningFn</cite>: How to attempt to meld each element into the accumulator.
- <cite>acc</cite>: The initial value of the accumulator; if <cite>list</cite> is empty, this is
returned unchanged as the <cite>Pass</cite> value.
- <cite>list</cite>: The elements which should be combined.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">combiningFn:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">Result</span> <span class="pre">a</span> <span class="pre">c,</span>&#160; <span class="pre">acc:</span> <span class="pre">a,</span>&#160; <span class="pre">list:</span> <span class="pre">List</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Result</span> <span class="pre">a</span> <span class="pre">c</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def rfoldr (combiningFn: element">
<code class="descname">def rfoldr (combiningFn: element</code><a class="headerlink" href="#function-def rfoldr (combiningFn: element" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to combine the elements of a <cite>List</cite> front-to-back, where each step might fail.
If any update step fails, the error value of the first such failure is
returned and no further values are processed.</p>
<p>Parameters:
- <cite>combiningFn</cite>: How to attempt to meld each element into the accumulator.
- <cite>acc</cite>: The initial value of the accumulator; if <cite>list</cite> is empty, this is
returned unchanged as the <cite>Pass</cite> value.
- <cite>list</cite>: The elements which should be combined.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">combiningFn:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">Result</span> <span class="pre">b</span> <span class="pre">c,</span>&#160; <span class="pre">acc:</span> <span class="pre">b,</span>&#160; <span class="pre">list:</span> <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Result</span> <span class="pre">b</span> <span class="pre">c</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def findFailFn (fn: a">
<code class="descname">def findFailFn (fn: a</code><a class="headerlink" href="#function-def findFailFn (fn: a" title="Permalink to this definition">¶</a></dt>
<dd><p>findFailFn: if fn returns Pass for all List elements, return the outputs else Fail
Once a Fail is found, fn is not evaluated on further elements.
This means that fn is applied to the List mostly sequentially.
If more parallelism is desired, use ‘map fn | findFail’ instead.</p>
<p>def toInt x = int x | getOrFail “not an Integer ({x})”
findFailFn toInt (“456”, “123”, Nil) = Pass (456, 123, Nil)
findFailFn toInt (“_56”, “123”, Nil) = Fail “not an Integer (_56)”</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">fn:</span> <span class="pre">a,</span>&#160; <span class="pre">Result</span> <span class="pre">b</span> <span class="pre">c,</span>&#160; <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Result</span> <span class="pre">(List</span> <span class="pre">b)</span> <span class="pre">c</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def findPassFn (fn: a">
<code class="descname">def findPassFn (fn: a</code><a class="headerlink" href="#function-def findPassFn (fn: a" title="Permalink to this definition">¶</a></dt>
<dd><p>findPassFn: if fn returns Fail for all List elements, return the outputs else Pass
Once a Pass is found, fn is not evaluated on further elements.
This means that fn is applied to the List mostly sequentially.
If more parallelism is desired, use ‘map fn | findPass’ instead.</p>
<p>def toInt x = int x | getOrFail “bad: {x}”
findPassFn toInt (“_56”, “123”, “777”, Nil) = Pass 123
findPassFn toInt (“_56”, “_23”, “_77”, Nil) = Fail (“bad: _56”, “bad: _23”, “bad: _77”, Nil)</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">fn:</span> <span class="pre">a,</span>&#160; <span class="pre">Result</span> <span class="pre">b</span> <span class="pre">c,</span>&#160; <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Result</span> <span class="pre">b</span> <span class="pre">(List</span> <span class="pre">c)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def stack Unit: List String">
<code class="descname">def stack Unit: List String</code><a class="headerlink" href="#function-def stack Unit: List String" title="Permalink to this definition">¶</a></dt>
<dd><p>stack: dump a stack trace from the call site
This function currently only works with debug mode enabled.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">Unit</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">String</span></code></p>
</dd></dl>

<dl class="tuple">
<dt id="function-tuple Error">
<code class="descname">tuple Error</code><a class="headerlink" href="#function-tuple Error" title="Permalink to this definition">¶</a></dt>
<dd><p>An Error has a cause and a stack trace
Result types should generally use an Error for their Fail case.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">Cause:</span> <span class="pre">String,</span>&#160; <span class="pre">Stack:</span> <span class="pre">List</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Error</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def makeError (cause: String): Error">
<code class="descname">def makeError (cause: String): Error</code><a class="headerlink" href="#function-def makeError (cause: String): Error" title="Permalink to this definition">¶</a></dt>
<dd><p>makeError: create an Error with the specified cause
This captures the stack at the point of the makeError call.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">cause:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Error</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def addErrorContext (prefix: String): Result a Error =&gt; Result a Error">
<code class="descname">def addErrorContext (prefix: String): Result a Error =&gt; Result a Error</code><a class="headerlink" href="#function-def addErrorContext (prefix: String): Result a Error => Result a Error" title="Permalink to this definition">¶</a></dt>
<dd><p>addErrorContext: add a prefix to the cause string of a Fail-ure
This method can be useful to preserve an existing failure cause,
where using a require-else must supply a totally new cause.</p>
<p>require Pass contents =
read file
| addErrorContext “opening {file.getPathName}”</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">prefix:</span> <span class="pre">String,</span>&#160; <span class="pre">Result</span> <span class="pre">a</span> <span class="pre">Error</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Result</span> <span class="pre">a</span> <span class="pre">Error</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def failWithError (cause: String): Result a Error">
<code class="descname">def failWithError (cause: String): Result a Error</code><a class="headerlink" href="#function-def failWithError (cause: String): Result a Error" title="Permalink to this definition">¶</a></dt>
<dd><p>failWithError: produce a Fail for us in error conditions</p>
<p>require Some = int str
else failWithError “Could not parse {str} as an Integer”</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">cause:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Result</span> <span class="pre">a</span> <span class="pre">Error</span></code></p>
</dd></dl>

</div>
<div class="section" id="list-wake">
<h2>list.wake<a class="headerlink" href="#list-wake" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="function-def element,">
<code class="descname">def element,</code><a class="headerlink" href="#function-def element," title="Permalink to this definition">¶</a></dt>
<dd><p>Create a singleton list from a value. This
can be used to slightly increase the niceness
of lists by avoid the Nil at the end. This is
especially nice for vertical lists.</p>
<p>Examples:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">10,</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">#</span> <span class="pre">Create</span> <span class="pre">a</span> <span class="pre">singleton</span> <span class="pre">list</span> <span class="pre">containing</span> <span class="pre">just</span> <span class="pre">10</span>
<span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">#</span> <span class="pre">Create</span> <span class="pre">a</span> <span class="pre">list</span> <span class="pre">of</span> <span class="pre">3</span> <span class="pre">elements</span> <span class="pre">without</span> <span class="pre">using</span> <span class="pre">Nil</span>
<span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">3,)</span> <span class="pre">++</span> <span class="pre">(4,</span> <span class="pre">5,</span> <span class="pre">6,)</span> <span class="pre">#</span> <span class="pre">append</span> <span class="pre">two</span> <span class="pre">lists</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">element:</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def empty: List a =&gt; Boolean">
<code class="descname">def empty: List a =&gt; Boolean</code><a class="headerlink" href="#function-def empty: List a => Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Report if the list contains no elements.
If you find yourself using the function, consider using match instead.</p>
<p>Examples:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">empty</span> <span class="pre">Nil</span>&#160;&#160;&#160;&#160;&#160; <span class="pre">=</span> <span class="pre">True</span>
<span class="pre">empty</span> <span class="pre">(seq</span> <span class="pre">0)</span>&#160; <span class="pre">=</span> <span class="pre">True</span>
<span class="pre">empty</span> <span class="pre">(1,</span> <span class="pre">Nil)</span> <span class="pre">=</span> <span class="pre">False</span>
<span class="pre">empty</span> <span class="pre">(seq</span> <span class="pre">9)</span>&#160; <span class="pre">=</span> <span class="pre">False</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def head: List a =&gt; Option a">
<code class="descname">def head: List a =&gt; Option a</code><a class="headerlink" href="#function-def head: List a => Option a" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the first element of the list, else None.
If you find yourself using the function, consider using match instead.</p>
<p>Examples:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">head</span> <span class="pre">Nil</span> <span class="pre">=</span> <span class="pre">None</span>
<span class="pre">head</span> <span class="pre">(&quot;a&quot;,</span> <span class="pre">&quot;b&quot;,</span> <span class="pre">Nil)</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">&quot;a&quot;</span>
<span class="pre">head</span> <span class="pre">(seq</span> <span class="pre">10)</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">0</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tail: List a =&gt; List a">
<code class="descname">def tail: List a =&gt; List a</code><a class="headerlink" href="#function-def tail: List a => List a" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the first element from the List
If you find yourself using the function, consider using match instead.</p>
<p>Examples:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">tail</span> <span class="pre">(seq</span> <span class="pre">5)</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">Nil</span>
<span class="pre">tail</span> <span class="pre">(&quot;a&quot;,</span> <span class="pre">Nil)</span> <span class="pre">=</span> <span class="pre">Nil</span>
<span class="pre">tail</span> <span class="pre">Nil</span> <span class="pre">=</span> <span class="pre">Nil</span>
<span class="pre">tail</span> <span class="pre">(pi,</span> <span class="pre">1.0,</span> <span class="pre">Nil)</span> <span class="pre">=</span> <span class="pre">1.0,</span> <span class="pre">Nil</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def map (mapFn: a">
<code class="descname">def map (mapFn: a</code><a class="headerlink" href="#function-def map (mapFn: a" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new List by applying the function <cite>mapFn</cite> to each element of <cite>list</cite>.
The <cite>map</cite> function (along with <cite>foldl</cite>) is generally how one implements loops in wake.
This function (like most in wake) runs <cite>mapFn</cite> in parallel.</p>
<p>Parameters:
- <cite>mapFn</cite>: The function to apply to each element
- <cite>list</cite>: The List of elements to feed to <cite>mapFn</cite></p>
<p>Guarantees:
- The resultant List has the same length as <cite>list</cite></p>
<p>Examples:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">map</span> <span class="pre">str</span>&#160;&#160;&#160;&#160; <span class="pre">(3,</span> <span class="pre">9,</span> <span class="pre">Nil)</span> <span class="pre">=</span> <span class="pre">&quot;3&quot;,</span> <span class="pre">&quot;9&quot;,</span> <span class="pre">Nil</span>
<span class="pre">map</span> <span class="pre">(_+100)</span> <span class="pre">(3,</span> <span class="pre">9,</span> <span class="pre">Nil)</span> <span class="pre">=</span> <span class="pre">103,</span> <span class="pre">109,</span> <span class="pre">Nil</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">mapFn:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">list:</span> <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def mapFlat (mapFn: a">
<code class="descname">def mapFlat (mapFn: a</code><a class="headerlink" href="#function-def mapFlat (mapFn: a" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new List by applying a function f to each element and concatenating the output.</p>
<p>Parameters:
- <cite>mapFn</cite>: The function to apply to each element
- <cite>list</cite>: The list of elements to feed to <cite>mapFn</cite></p>
<p>Examples:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">def</span> <span class="pre">twice</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">x,</span> <span class="pre">x,</span> <span class="pre">Nil</span>
<span class="pre">mapFlat</span> <span class="pre">twice</span> <span class="pre">(seq</span> <span class="pre">3)</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">2,</span> <span class="pre">Nil</span>
<span class="pre">mapFlat</span> <span class="pre">seq</span> <span class="pre">(seq</span> <span class="pre">5)</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">Nil</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">mapFn:</span> <span class="pre">a,</span>&#160; <span class="pre">List</span> <span class="pre">b,</span>&#160; <span class="pre">list:</span> <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def mapPartial (f: a">
<code class="descname">def mapPartial (f: a</code><a class="headerlink" href="#function-def mapPartial (f: a" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new List by applying a partial function to each element of a List.
Partial functions can return None, in which case the result is not included in the output.</p>
<p>Parameters:
- <cite>mapFn</cite>: The partial function to apply to each element
- <cite>list</cite>: The list of elements to feed to <cite>mapFn</cite></p>
<p>Guarantees:
- The resultant List is no longer than <cite>list</cite></p>
<p>Examples:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">mapPartial</span> <span class="pre">int</span> <span class="pre">(&quot;3&quot;,</span> <span class="pre">&quot;x&quot;,</span> <span class="pre">&quot;44&quot;,</span> <span class="pre">Nil)</span> <span class="pre">=</span> <span class="pre">3,</span> <span class="pre">44,</span> <span class="pre">Nil</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">a,</span>&#160; <span class="pre">Option</span> <span class="pre">b,</span>&#160; <span class="pre">list:</span> <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def foldl (combiningFn: accumulator">
<code class="descname">def foldl (combiningFn: accumulator</code><a class="headerlink" href="#function-def foldl (combiningFn: accumulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine the elements of a List front-to-back into a single value.
An accumulator is updated from its initial value by combiningFn for each element.</p>
<p>In C++ syntax, <cite>foldl &lt;combiningFn&gt; &lt;accumulateInitalValue&gt; &lt;List&gt;</cite> does:
<code class="docutils literal notranslate"><span class="pre">`c++</span>
<span class="pre">auto</span> <span class="pre">accumulator</span> <span class="pre">=</span> <span class="pre">&lt;accumulateInitalValue&gt;;</span>
<span class="pre">for</span> <span class="pre">(element</span> <span class="pre">:</span> <span class="pre">&lt;List&gt;)</span> <span class="pre">accumulator</span> <span class="pre">=</span> <span class="pre">combiningFn(accumulator,</span> <span class="pre">element);</span>
<span class="pre">return</span> <span class="pre">accumulator;</span>
<span class="pre">`</span></code>
In python this is similar to <cite>functools.reduce</cite></p>
<p>Parameters:
- <cite>combiningFn</cite>: The function to combine elements of the list with the accumulator
- <cite>initialValue</cite>: The initial value of the accumulator
- <cite>list</cite>: The list to combine the elements of</p>
<p>Examples:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">foldl</span> <span class="pre">f</span> <span class="pre">x</span> <span class="pre">Nil</span> <span class="pre">=</span> <span class="pre">x</span>
<span class="pre">foldl</span> <span class="pre">f</span> <span class="pre">x</span> <span class="pre">(a,</span> <span class="pre">b,</span> <span class="pre">c,</span> <span class="pre">Nil)</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">(f</span> <span class="pre">(f</span> <span class="pre">x</span> <span class="pre">a)</span> <span class="pre">b)</span> <span class="pre">c</span>
<span class="pre">foldl</span> <span class="pre">(_+_)</span> <span class="pre">0</span> <span class="pre">(seq</span> <span class="pre">6)</span> <span class="pre">=</span> <span class="pre">15</span>
<span class="pre">foldl</span> <span class="pre">(_*_)</span> <span class="pre">0</span> <span class="pre">l</span> <span class="pre">=</span> <span class="pre">0</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">combiningFn:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">accumulator:</span> <span class="pre">a,</span>&#160; <span class="pre">List</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def scanl (combiningFn: accumulator">
<code class="descname">def scanl (combiningFn: accumulator</code><a class="headerlink" href="#function-def scanl (combiningFn: accumulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new List from an accumulator run over the elements front-to-back.
The last element of the produced List is equivalent to the result of foldl.</p>
<p>Parameters:
- <cite>combiningFn</cite>: The function to combine elements of the list with the accumulator
- <cite>initialValue</cite>: The initial value of the accumulator
- <cite>list</cite>: The list to scan over</p>
<p>Guarantees:
- The resultant List is exactly one element longer than <cite>list</cite>
- The first element of the resultant List will be <cite>initialValue</cite>
- The last element of the resultant List will be equal to <cite>foldl combiningFn initialValue list</cite>
- If <cite>combiningFn</cite> is a group operation, the difference between the resultants yields <cite>list</cite></p>
<p>Examples:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">scanl</span> <span class="pre">f</span> <span class="pre">z</span> <span class="pre">Nil</span> <span class="pre">=</span> <span class="pre">z</span>
<span class="pre">scanl</span> <span class="pre">(_+_)</span> <span class="pre">100</span> <span class="pre">(seq</span> <span class="pre">6)</span> <span class="pre">=</span> <span class="pre">100,</span> <span class="pre">100,</span> <span class="pre">101,</span> <span class="pre">103,</span> <span class="pre">106,</span> <span class="pre">110,</span> <span class="pre">115,</span> <span class="pre">Nil</span>
<span class="pre">^^^-</span> <span class="pre">100+0+1+2+3+4+5</span>
<span class="pre">^^^-</span> <span class="pre">100+0+1+2</span>
<span class="pre">^^^-</span> <span class="pre">100+0</span>
<span class="pre">^^^-</span> <span class="pre">100</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">combiningFn:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">accumulator:</span> <span class="pre">a,</span>&#160; <span class="pre">List</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def foldr (combiningFn: element">
<code class="descname">def foldr (combiningFn: element</code><a class="headerlink" href="#function-def foldr (combiningFn: element" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine the elements of a List back-to-front into a single value.
An accumulator is updated from its initial value by combiningFn for each element.</p>
<p>Parameters:
- <cite>combiningFn</cite>: The function to combine elements of the list with the accumulator
- <cite>initialValue</cite>: The initial value of the accumulator
- <cite>list</cite>: The list to combine the elements of</p>
<p>Examples:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">foldr</span> <span class="pre">f</span> <span class="pre">x</span> <span class="pre">Nil</span> <span class="pre">=</span> <span class="pre">x</span>
<span class="pre">foldr</span> <span class="pre">f</span> <span class="pre">x</span> <span class="pre">(a,</span> <span class="pre">b,</span> <span class="pre">c,</span> <span class="pre">Nil)</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">(f</span> <span class="pre">b</span> <span class="pre">(f</span> <span class="pre">c</span> <span class="pre">x))</span>
<span class="pre">foldr</span> <span class="pre">(_,_)</span> <span class="pre">y</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">++</span> <span class="pre">y</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">combiningFn:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">accumulator:</span> <span class="pre">b,</span>&#160; <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def scanr (combiningFn: element">
<code class="descname">def scanr (combiningFn: element</code><a class="headerlink" href="#function-def scanr (combiningFn: element" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new List from an accumulator run over the elements back-to-front.
The first element of the produced List is equivalent to the result of a foldr.</p>
<p>Parameters:
- <cite>combiningFn</cite>: The function to combine elements of the list with the accumulator
- <cite>initialValue</cite>: The initial value of the accumulator
- <cite>list</cite>: The list to scan over</p>
<p>Guarantees:
- The resultant List is exactly one element longer than <cite>list</cite>
- The first element of the resultant List will be <cite>foldl combiningFn initialValue list</cite>
- The last element of the resultant List will be equal to <cite>initialValue</cite>
- If <cite>combiningFn</cite> is a group operation, the difference between the resultants yields <cite>list</cite></p>
<p>Examples:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">scanr</span>
<span class="pre">scanr</span> <span class="pre">(_+_)</span> <span class="pre">100</span> <span class="pre">(seq</span> <span class="pre">6)</span> <span class="pre">=</span> <span class="pre">115,</span> <span class="pre">115,</span> <span class="pre">114,</span> <span class="pre">112,</span> <span class="pre">109,</span> <span class="pre">105,</span> <span class="pre">100,</span> <span class="pre">Nil</span>
<span class="pre">^^^-</span> <span class="pre">100</span>
<span class="pre">^^^-</span> <span class="pre">5+100</span>
<span class="pre">^^^-</span> <span class="pre">1+2+3+4+5+100</span>
<span class="pre">^^^-</span> <span class="pre">0+1+2+3+4+5+100</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">combiningFn:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">accumulator:</span> <span class="pre">b,</span>&#160; <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (l: List a) ++ (r: List a): List a">
<code class="descname">def (l: List a) ++ (r: List a): List a</code><a class="headerlink" href="#function-def (l: List a) ++ (r: List a): List a" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate two lists into one List.
The ++ operator must be provided by the wake package for publish to work.</p>
<p>Guarantees:
- ++ is associtive
- Nil is an identity of ++</p>
<p>Examples:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">Nil)</span> <span class="pre">++</span> <span class="pre">(8,</span> <span class="pre">9,</span> <span class="pre">Nil)</span> <span class="pre">=</span> <span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">8,</span> <span class="pre">9,</span> <span class="pre">Nil)</span>
<span class="pre">(x</span> <span class="pre">++</span> <span class="pre">y)</span> <span class="pre">++</span> <span class="pre">z</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">++</span> <span class="pre">(y</span> <span class="pre">++</span> <span class="pre">z)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">#</span> <span class="pre">associtive</span>
<span class="pre">Nil</span> <span class="pre">++</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">#</span> <span class="pre">left</span> <span class="pre">identity</span>
<span class="pre">x</span> <span class="pre">++</span> <span class="pre">Nil</span> <span class="pre">=</span> <span class="pre">x</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">#</span> <span class="pre">right</span> <span class="pre">identity</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">l:</span> <span class="pre">List</span> <span class="pre">a,</span>&#160; <span class="pre">r:</span> <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def prepend (item: a) (list: List a): List a">
<code class="descname">def prepend (item: a) (list: List a): List a</code><a class="headerlink" href="#function-def prepend (item: a) (list: List a): List a" title="Permalink to this definition">¶</a></dt>
<dd><p>Add <cite>item</cite> to the start of <cite>list</cite>.
This is efficient no matter how large the list.
Consider using ‘,’ directly as it is more idiomatic.</p>
<p>Examples:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">prepend</span> <span class="pre">9</span> <span class="pre">(seq</span> <span class="pre">3)</span> <span class="pre">=</span> <span class="pre">9,</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">Nil</span>
<span class="pre">prepend</span> <span class="pre">8</span> <span class="pre">Nil</span>&#160;&#160;&#160;&#160; <span class="pre">=</span> <span class="pre">8,</span> <span class="pre">Nil</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">item:</span> <span class="pre">a,</span>&#160; <span class="pre">list:</span> <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def append (item: a) (list: List a): List a">
<code class="descname">def append (item: a) (list: List a): List a</code><a class="headerlink" href="#function-def append (item: a) (list: List a): List a" title="Permalink to this definition">¶</a></dt>
<dd><p>Add <cite>item</cite> to the end of <cite>list</cite>.</p>
<p><strong>NOTE</strong>: This function must recreate the entire list to add the item.
If you add 1000 items to an empty list, this costs 1000*1000/2 steps.
Therefore, if you need to add more than one item to the end of a list,
you should consider prepending them to an empty list and then appending
that list in reverse to the list you want to enlarge.</p>
<p>Examples:
<a href="#id3"><span class="problematic" id="id4">``</span></a>`
append 9 (seq 3) = 0, 1, 2, 9, Nil
append 9 Nil     = 9, Nil</p>
<p>append 8 (append 7 (append 6 (seq 6)))
= 0, 1, 2, 3, 4, 5, 6, 7, 8, Nil
= (seq 6) ++ reverse (8, 7, 6, Nil)   # &lt;== potentially much faster
<a href="#id5"><span class="problematic" id="id6">``</span></a><a href="#id7"><span class="problematic" id="id8">`</span></a></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">item:</span> <span class="pre">a,</span>&#160; <span class="pre">list:</span> <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def splitAt (index: Integer) (listToDivide: List a): Pair (List a) (List a)">
<code class="descname">def splitAt (index: Integer) (listToDivide: List a): Pair (List a) (List a)</code><a class="headerlink" href="#function-def splitAt (index: Integer) (listToDivide: List a): Pair (List a) (List a)" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an index, cut a List into elements before and after the index</p>
<p>Examples:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">splitAt</span> <span class="pre">4</span> <span class="pre">(seq</span> <span class="pre">8)</span> <span class="pre">=</span> <span class="pre">Pair</span> <span class="pre">(0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">Nil)</span> <span class="pre">(4,</span> <span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">7,</span> <span class="pre">Nil)</span>
<span class="pre">splitAt</span> <span class="pre">0</span> <span class="pre">(seq</span> <span class="pre">8)</span> <span class="pre">=</span> <span class="pre">Pair</span> <span class="pre">Nil</span> <span class="pre">(0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">7,</span> <span class="pre">Nil)</span>
<span class="pre">splitAt</span> <span class="pre">8</span> <span class="pre">(seq</span> <span class="pre">8)</span> <span class="pre">=</span> <span class="pre">Pair</span> <span class="pre">(0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">7,</span> <span class="pre">Nil)</span> <span class="pre">Nil</span>
<span class="pre">splitAt</span> <span class="pre">1000</span> <span class="pre">(seq</span> <span class="pre">3)</span> <span class="pre">=</span> <span class="pre">Pair</span> <span class="pre">(seq</span> <span class="pre">3)</span> <span class="pre">Nil</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">index:</span> <span class="pre">Integer,</span>&#160; <span class="pre">listToDivide:</span> <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Pair</span> <span class="pre">(List</span> <span class="pre">a)</span> <span class="pre">(List</span> <span class="pre">a)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def take (length: Integer) (l: List a): List a">
<code class="descname">def take (length: Integer) (l: List a): List a</code><a class="headerlink" href="#function-def take (length: Integer) (l: List a): List a" title="Permalink to this definition">¶</a></dt>
<dd><p>Keep only the first <cite>length</cite> elements</p>
<p>Examples:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">take</span> <span class="pre">2</span> <span class="pre">(seq</span> <span class="pre">100)</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">Nil</span>
<span class="pre">take</span> <span class="pre">0</span> <span class="pre">(seq</span> <span class="pre">100)</span> <span class="pre">=</span> <span class="pre">Nil</span>
<span class="pre">take</span> <span class="pre">2</span> <span class="pre">Nil</span> <span class="pre">=</span> <span class="pre">Nil</span>
<span class="pre">take</span> <span class="pre">(-2)</span> <span class="pre">(seq</span> <span class="pre">100)</span> <span class="pre">=</span> <span class="pre">Nil</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">length:</span> <span class="pre">Integer,</span>&#160; <span class="pre">l:</span> <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def drop (num: Integer) (l: List a): List a">
<code class="descname">def drop (num: Integer) (l: List a): List a</code><a class="headerlink" href="#function-def drop (num: Integer) (l: List a): List a" title="Permalink to this definition">¶</a></dt>
<dd><p>Discard the first <cite>num</cite> elements</p>
<p>Examples:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">drop</span> <span class="pre">4</span> <span class="pre">(seq</span> <span class="pre">6)</span> <span class="pre">=</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">Nil</span>
<span class="pre">drop</span> <span class="pre">6</span> <span class="pre">(seq</span> <span class="pre">6)</span> <span class="pre">=</span> <span class="pre">Nil</span>
<span class="pre">drop</span> <span class="pre">0</span> <span class="pre">(seq</span> <span class="pre">3)</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">Nil</span>
<span class="pre">drop</span> <span class="pre">(-2)</span> <span class="pre">(seq</span> <span class="pre">3)</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">Nil</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">num:</span> <span class="pre">Integer,</span>&#160; <span class="pre">l:</span> <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def at (i: Integer) (l: List a): Option a">
<code class="descname">def at (i: Integer) (l: List a): Option a</code><a class="headerlink" href="#function-def at (i: Integer) (l: List a): Option a" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the i-th element if it exists or else None</p>
<p>Examples:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">at</span> <span class="pre">4</span> <span class="pre">(seq</span> <span class="pre">8)</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">4</span>
<span class="pre">at</span> <span class="pre">4</span> <span class="pre">(seq</span> <span class="pre">4)</span> <span class="pre">=</span> <span class="pre">None</span>
<span class="pre">at</span> <span class="pre">(-1)</span> <span class="pre">(seq</span> <span class="pre">4)</span> <span class="pre">=</span> <span class="pre">None</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">i:</span> <span class="pre">Integer,</span>&#160; <span class="pre">l:</span> <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def splitUntil (stopFn: a">
<code class="descname">def splitUntil (stopFn: a</code><a class="headerlink" href="#function-def splitUntil (stopFn: a" title="Permalink to this definition">¶</a></dt>
<dd><p>Cut the List at the point <cite>f</cite> is first True
Once <cite>stopFn</cite> returns True, <cite>stopFn</cite> is not evaulated on further elements.
This means that <cite>stopFn</cite> is applied to the List mostly sequentially.
If more parallelism is desired, use ‘map f | find (_)’ and splitAt.</p>
<p>Examples:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">splitUntil</span> <span class="pre">(_&gt;=4)</span> <span class="pre">(seq</span> <span class="pre">8)</span> <span class="pre">=</span> <span class="pre">Pair</span> <span class="pre">(0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">Nil)</span> <span class="pre">(4,</span> <span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">7,</span> <span class="pre">Nil)</span>
<span class="pre">splitUntil</span> <span class="pre">(_&gt;=0)</span> <span class="pre">(seq</span> <span class="pre">8)</span> <span class="pre">=</span> <span class="pre">Pair</span> <span class="pre">Nil</span> <span class="pre">(0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">7,</span> <span class="pre">Nil)</span>
<span class="pre">splitUntil</span> <span class="pre">(_&gt;=8)</span> <span class="pre">(seq</span> <span class="pre">8)</span> <span class="pre">=</span> <span class="pre">Pair</span> <span class="pre">(0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">7,</span> <span class="pre">Nil)</span> <span class="pre">Nil</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">stopFn:</span> <span class="pre">a,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">l:</span> <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Pair</span> <span class="pre">(List</span> <span class="pre">a)</span> <span class="pre">(List</span> <span class="pre">a)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def takeUntil (f: a">
<code class="descname">def takeUntil (f: a</code><a class="headerlink" href="#function-def takeUntil (f: a" title="Permalink to this definition">¶</a></dt>
<dd><p>Take the longest prefix of a list where <cite>f</cite> is False
Once <cite>f</cite> returns True, <cite>f</cite> is not evaulated on further elements.
This means that <cite>f</cite> is applied to the List mostly sequentially.
If more parallelism is desired, use ‘map f | find (_)’ and take.</p>
<p>Examples:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">takeUntil</span> <span class="pre">(_&gt;=4)</span> <span class="pre">(seq</span> <span class="pre">8)</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">Nil</span>
<span class="pre">takeUntil</span> <span class="pre">(_&gt;=0)</span> <span class="pre">(seq</span> <span class="pre">8)</span> <span class="pre">=</span> <span class="pre">Nil</span>
<span class="pre">takeUntil</span> <span class="pre">(_&gt;=8)</span> <span class="pre">(seq</span> <span class="pre">8)</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">7,</span> <span class="pre">Nil</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">a,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def dropUntil (f: a">
<code class="descname">def dropUntil (f: a</code><a class="headerlink" href="#function-def dropUntil (f: a" title="Permalink to this definition">¶</a></dt>
<dd><p>Discard elements from the list until ‘f’ returns True
Once <cite>f</cite> returns True, <cite>f</cite> is not evaulated on further elements.
This means that <cite>f</cite> is applied to the List mostly sequentially.
If more parallelism is desired, use ‘map f | find (_)’ and drop.</p>
<p>Examples:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">dropUntil</span> <span class="pre">(_&gt;=4)</span> <span class="pre">(seq</span> <span class="pre">8)</span> <span class="pre">=</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">7,</span> <span class="pre">Nil</span>
<span class="pre">dropUntil</span> <span class="pre">(_&gt;=0)</span> <span class="pre">(seq</span> <span class="pre">8)</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">7,</span> <span class="pre">Nil</span>
<span class="pre">dropUntil</span> <span class="pre">(_&gt;=8)</span> <span class="pre">(seq</span> <span class="pre">8)</span> <span class="pre">=</span> <span class="pre">Nil</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">a,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">l:</span> <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def find (f: a">
<code class="descname">def find (f: a</code><a class="headerlink" href="#function-def find (f: a" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the location of the first element accepted by <cite>f</cite>
Returns: <cite>Pair value index</cite>, such that <cite>value</cite> is <cite>at index</cite>
Once <cite>f</cite> returns True, <cite>f</cite> is not evaulated on further elements.
This means that <cite>f</cite> is applied to the List mostly sequentially.
If more parallelism is desired, use ‘map f | find (_)’.</p>
<p>Examples:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">def</span> <span class="pre">l</span> <span class="pre">=</span> <span class="pre">(85,</span> <span class="pre">4,</span> <span class="pre">10,</span> <span class="pre">3,</span> <span class="pre">Nil)</span>
<span class="pre">find</span> <span class="pre">(_==10)</span> <span class="pre">l</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">(Pair</span> <span class="pre">10</span> <span class="pre">3)</span>
<span class="pre">find</span> <span class="pre">(_&gt;9)</span> <span class="pre">l</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">(Pair</span> <span class="pre">85</span> <span class="pre">0)</span>
<span class="pre">find</span> <span class="pre">(_&lt;3)</span> <span class="pre">l</span> <span class="pre">=</span> <span class="pre">None</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">a,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">(Pair</span> <span class="pre">a</span> <span class="pre">Integer)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def exists (f: a">
<code class="descname">def exists (f: a</code><a class="headerlink" href="#function-def exists (f: a" title="Permalink to this definition">¶</a></dt>
<dd><p>Does <cite>f</cite> return True for any element in the list?
Once <cite>f</cite> returns True, <cite>f</cite> is not evaulated on further elements.
This means that <cite>f</cite> is applied to the List mostly sequentially.
If more parallelism is desired, use ‘map f | exists (_)’.</p>
<p>Examples:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">exists</span> <span class="pre">(_==11)</span> <span class="pre">(seq</span> <span class="pre">20)</span> <span class="pre">=</span> <span class="pre">True</span>
<span class="pre">exists</span> <span class="pre">(_&gt;100)</span> <span class="pre">(seq</span> <span class="pre">20)</span> <span class="pre">=</span> <span class="pre">False</span>
<span class="pre">exists</span> <span class="pre">(_&lt;100)</span> <span class="pre">(seq</span> <span class="pre">20)</span> <span class="pre">=</span> <span class="pre">True</span>
<span class="pre">exists</span> <span class="pre">(\_</span> <span class="pre">True)</span> <span class="pre">Nil</span>&#160;&#160;&#160; <span class="pre">=</span> <span class="pre">False</span>
<span class="pre">exists</span> <span class="pre">(\_</span> <span class="pre">True)</span> <span class="pre">(prepend</span> <span class="pre">x</span> <span class="pre">xs)</span> <span class="pre">=</span> <span class="pre">True</span>
<span class="pre">exists</span> <span class="pre">p</span> <span class="pre">xs</span> <span class="pre">=</span> <span class="pre">!</span> <span class="pre">(forall</span> <span class="pre">(!</span> <span class="pre">p</span> <span class="pre">_)</span> <span class="pre">xs)</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">a,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def forall (f: a">
<code class="descname">def forall (f: a</code><a class="headerlink" href="#function-def forall (f: a" title="Permalink to this definition">¶</a></dt>
<dd><p>Does <cite>f</cite> return True for all elements in the list?
Once <cite>f</cite> returns False, <cite>f</cite> is not evaulated on further elements.
This means that <cite>f</cite> is applied to the List mostly sequentially.
If more parallelism is desired, use ‘map f | forall (_)’.</p>
<p>Examples:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">forall</span> <span class="pre">(_==11)</span> <span class="pre">(seq</span> <span class="pre">20)</span> <span class="pre">=</span> <span class="pre">False</span>
<span class="pre">forall</span> <span class="pre">(_&gt;100)</span> <span class="pre">(seq</span> <span class="pre">20)</span> <span class="pre">=</span> <span class="pre">False</span>
<span class="pre">forall</span> <span class="pre">(_&lt;100)</span> <span class="pre">(seq</span> <span class="pre">20)</span> <span class="pre">=</span> <span class="pre">True</span>
<span class="pre">forall</span> <span class="pre">(\_</span> <span class="pre">False)</span> <span class="pre">Nil</span>&#160;&#160; <span class="pre">=</span> <span class="pre">True</span>
<span class="pre">forall</span> <span class="pre">(\_</span> <span class="pre">False)</span> <span class="pre">(prepend</span> <span class="pre">x</span> <span class="pre">xs)</span> <span class="pre">=</span> <span class="pre">False</span>
<span class="pre">forall</span> <span class="pre">(\_</span> <span class="pre">True)</span> <span class="pre">xs</span> <span class="pre">=</span> <span class="pre">True</span>
<span class="pre">forall</span> <span class="pre">p</span> <span class="pre">xs</span> <span class="pre">=</span> <span class="pre">!</span> <span class="pre">(exists</span> <span class="pre">(!</span> <span class="pre">p</span> <span class="pre">_)</span> <span class="pre">xs)</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">a,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def splitBy (acceptFn: a">
<code class="descname">def splitBy (acceptFn: a</code><a class="headerlink" href="#function-def splitBy (acceptFn: a" title="Permalink to this definition">¶</a></dt>
<dd><p>Partition one <cite>list</cite> into two Lists based on the output of <cite>acceptFn</cite>.
Every element of <cite>list</cite> appears in exactly one of the output Lists.
Two elements in an output List retain the order they had in <cite>list</cite>.</p>
<p>Parameters:
- <cite>acceptFn</cite>: The Boolean function which categorizes each element
- <cite>list</cite>: The List of elements to be categorized by <cite>True</cite> / <cite>False</cite></p>
<p>Returns <cite>Pair true false</cite>, where:
- <cite>true</cite>:  List of elements from <cite>list</cite> for which <cite>acceptFn</cite> returned <cite>True</cite>
- <cite>false</cite>: List of elements from <cite>list</cite> for which <cite>acceptFn</cite> returned <cite>False</cite></p>
<p>Examples:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">def</span> <span class="pre">isEven</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">x%2</span> <span class="pre">==</span> <span class="pre">0</span>
<span class="pre">splitBy</span> <span class="pre">isEven</span> <span class="pre">(0,</span> <span class="pre">1,</span> <span class="pre">3,</span> <span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">Nil)</span> <span class="pre">=</span> <span class="pre">Pair</span> <span class="pre">(0,</span> <span class="pre">6,</span> <span class="pre">Nil)</span> <span class="pre">(1,</span> <span class="pre">3,</span> <span class="pre">5,</span> <span class="pre">Nil)</span>
<span class="pre">splitBy</span> <span class="pre">p</span> <span class="pre">xs</span> <span class="pre">=</span> <span class="pre">Pair</span> <span class="pre">(filter</span> <span class="pre">p</span> <span class="pre">xs)</span> <span class="pre">(filter</span> <span class="pre">(!</span> <span class="pre">p</span> <span class="pre">_)</span> <span class="pre">xs)</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">acceptFn:</span> <span class="pre">a,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">list:</span> <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Pair</span> <span class="pre">(true:</span> <span class="pre">List</span> <span class="pre">a)</span> <span class="pre">(false:</span> <span class="pre">List</span> <span class="pre">a)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def filter (f: a">
<code class="descname">def filter (f: a</code><a class="headerlink" href="#function-def filter (f: a" title="Permalink to this definition">¶</a></dt>
<dd><p>Keep only those elements in the List where <cite>f</cite> evaluates to True</p>
<p>Examples:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">def</span> <span class="pre">isEven</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">x%2</span> <span class="pre">==</span> <span class="pre">0</span>
<span class="pre">filter</span> <span class="pre">isEven</span> <span class="pre">(seq</span> <span class="pre">10)</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">2,</span> <span class="pre">4,</span> <span class="pre">6,</span> <span class="pre">8,</span> <span class="pre">Nil</span>
<span class="pre">filter</span> <span class="pre">p</span> <span class="pre">Nil</span> <span class="pre">=</span> <span class="pre">Nil</span>
<span class="pre">filter</span> <span class="pre">(\x</span> <span class="pre">True)</span> <span class="pre">xs</span> <span class="pre">=</span> <span class="pre">xs</span>
<span class="pre">filter</span> <span class="pre">(\x</span> <span class="pre">False)</span> <span class="pre">xs</span> <span class="pre">=</span> <span class="pre">Nil</span>
<span class="pre">filter</span> <span class="pre">p</span> <span class="pre">xs</span> <span class="pre">=</span> <span class="pre">getPairFirst</span> <span class="pre">(splitBy</span> <span class="pre">p</span> <span class="pre">xs)</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">a,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def sortBy (cmpFn: a">
<code class="descname">def sortBy (cmpFn: a</code><a class="headerlink" href="#function-def sortBy (cmpFn: a" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a less-than comparison operator, sort the list
Elements which compare equal retain their order in the output list.
The lessThanFn must provide these two properties for all x, y, z:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">if</span> <span class="pre">lessThanFn</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">then</span> <span class="pre">!</span> <span class="pre">lessThanFn</span> <span class="pre">y</span> <span class="pre">x</span>
<span class="pre">if</span> <span class="pre">lessThanFn</span> <span class="pre">x</span> <span class="pre">z</span> <span class="pre">then</span> <span class="pre">lessThanFn</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">||</span> <span class="pre">lessThanFn</span> <span class="pre">y</span> <span class="pre">z</span>
<span class="pre">`</span></code></p>
<p>Parameters:
- <cite>cmpFn</cite>: The comparision operator that defines the ordering
- <cite>list</cite>: The list of elements to sort by <cite>lessThanFn</cite></p>
<p>Guarantees:
- The output is a permutation of <cite>list</cite>
- If <cite>0 &lt;= x &lt; y &lt; len list</cite> then <cite>lessThanFn (at list x) (at list y)</cite> (ignoring None)</p>
<p>Example:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">sortBy</span> <span class="pre">(_&lt;_)</span> <span class="pre">(6,</span> <span class="pre">1,</span> <span class="pre">4,</span> <span class="pre">2,</span> <span class="pre">Nil)</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">4,</span> <span class="pre">6,</span> <span class="pre">Nil</span>
<span class="pre">sortBy</span> <span class="pre">p</span> <span class="pre">Nil</span> <span class="pre">=</span> <span class="pre">Nil</span>
<span class="pre">sortBy</span> <span class="pre">p</span> <span class="pre">(x,</span> <span class="pre">Nil)</span> <span class="pre">=</span> <span class="pre">(x,</span> <span class="pre">Nil)</span>
<span class="pre">sortBy</span> <span class="pre">(\x\y</span> <span class="pre">if</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span> <span class="pre">then</span> <span class="pre">False</span> <span class="pre">else</span> <span class="pre">!</span> <span class="pre">p</span> <span class="pre">x</span> <span class="pre">y)</span> <span class="pre">xs</span> <span class="pre">=</span> <span class="pre">reverse</span> <span class="pre">(sortBy</span> <span class="pre">p</span> <span class="pre">xs)</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">cmpFn:</span> <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">Order,</span>&#160; <span class="pre">l:</span> <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def distinctBy (cmpFn: a">
<code class="descname">def distinctBy (cmpFn: a</code><a class="headerlink" href="#function-def distinctBy (cmpFn: a" title="Permalink to this definition">¶</a></dt>
<dd><p>Keep only the first occurrence of a value
The order of non-duplicated elements is retained.</p>
<p>This runs in O(n*lg(n))</p>
<p>Example:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">distinctBy</span> <span class="pre">(_&lt;=&gt;_)</span> <span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">1,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">3,</span> <span class="pre">Nil)</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">Nil</span>
<span class="pre">distinctBy</span> <span class="pre">(_&lt;=&gt;_)</span> <span class="pre">Nil</span> <span class="pre">=</span> <span class="pre">Nil</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">cmpFn:</span> <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">Order,</span>&#160; <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def distinctRunBy (eqFn: a">
<code class="descname">def distinctRunBy (eqFn: a</code><a class="headerlink" href="#function-def distinctRunBy (eqFn: a" title="Permalink to this definition">¶</a></dt>
<dd><p>Keep only the first occurrence in a run of equal values</p>
<p>Example:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">distinctRunBy</span> <span class="pre">(_==_)</span> <span class="pre">(1,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">1,</span> <span class="pre">3,</span> <span class="pre">3,</span> <span class="pre">Nil)</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">1,</span> <span class="pre">3,</span> <span class="pre">Nil</span>
<span class="pre">distinctRunBy</span> <span class="pre">(_==_)</span> <span class="pre">Nil</span> <span class="pre">=</span> <span class="pre">Nil</span>
<span class="pre">distinctBy</span> <span class="pre">(_&lt;=&gt;_)</span> <span class="pre">|</span> <span class="pre">sortBy</span> <span class="pre">(_&lt;_)</span> <span class="pre">=</span> <span class="pre">sortBy</span> <span class="pre">(_&lt;_)</span> <span class="pre">|</span> <span class="pre">distinctRunBy</span> <span class="pre">(_==_)</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">eqFn:</span> <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">l:</span> <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def cmp (cmpFn: a">
<code class="descname">def cmp (cmpFn: a</code><a class="headerlink" href="#function-def cmp (cmpFn: a" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two lists using an Order comparator
* <cite>EQ</cite> is the result if the lists are exactly equal.
* <cite>LT</cite> is the result if the first elements that <cite>f</cite> does not return <cite>EQ</cite> for returns <cite>LT</cite>
or if <cite>l</cite> is a prefix of <cite>r</cite>.
* <cite>GT</cite> is the result if the first elements that <cite>f</cite> does not return <cite>EQ</cite> for returns <cite>GT</cite>
or if <cite>r</cite> is a prefix of <cite>l</cite>.</p>
<p>This is also called a lexicographical ordering.</p>
<p>Parameters:
- <cite>cmpFn</cite>: The function by which elements of <cite>l</cite> and <cite>r</cite> are compared
- <cite>l</cite>: The left list
- <cite>r</cite>: The right list</p>
<p>Example:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">cmp</span> <span class="pre">(_&lt;=&gt;_)</span> <span class="pre">(seq</span> <span class="pre">5)</span>&#160; <span class="pre">(seq</span> <span class="pre">5)</span>&#160; <span class="pre">=</span> <span class="pre">EQ</span>
<span class="pre">cmp</span> <span class="pre">(_&lt;=&gt;_)</span> <span class="pre">(seq</span> <span class="pre">5)</span>&#160; <span class="pre">(seq</span> <span class="pre">4)</span>&#160; <span class="pre">=</span> <span class="pre">GT</span>
<span class="pre">cmp</span> <span class="pre">(_&lt;=&gt;_)</span> <span class="pre">(0,</span> <span class="pre">Nil)</span> <span class="pre">(1,</span> <span class="pre">Nil)</span> <span class="pre">=</span> <span class="pre">LT</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">cmpFn:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">Order,</span>&#160; <span class="pre">l:</span> <span class="pre">List</span> <span class="pre">a,</span>&#160; <span class="pre">r:</span> <span class="pre">List</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Order</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tab (f: Integer">
<code class="descname">def tab (f: Integer</code><a class="headerlink" href="#function-def tab (f: Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a list of specified size by calling <cite>f</cite> on the index to generate.</p>
<p>Example:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">tab</span> <span class="pre">(_+100)</span> <span class="pre">5</span> <span class="pre">=</span> <span class="pre">100,</span> <span class="pre">101,</span> <span class="pre">102,</span> <span class="pre">103,</span> <span class="pre">104,</span> <span class="pre">Nil</span>
<span class="pre">tab</span> <span class="pre">f</span> <span class="pre">0</span> <span class="pre">=</span> <span class="pre">Nil</span>
<span class="pre">tab</span> <span class="pre">f</span> <span class="pre">3</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">0,</span> <span class="pre">f</span> <span class="pre">1,</span> <span class="pre">f</span> <span class="pre">2,</span> <span class="pre">Nil</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">Integer,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">n:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def zip (a: List a) (b: List b): List (Pair a b)">
<code class="descname">def zip (a: List a) (b: List b): List (Pair a b)</code><a class="headerlink" href="#function-def zip (a: List a) (b: List b): List (Pair a b)" title="Permalink to this definition">¶</a></dt>
<dd><p>Take two Lists and turn them into a List of Pairs
The shortest length of the two input lists sets the output length.</p>
<p>Example:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">zip</span> <span class="pre">(4,</span> <span class="pre">7,</span> <span class="pre">Nil)</span> <span class="pre">(&quot;a&quot;,</span> <span class="pre">&quot;b&quot;,</span> <span class="pre">Nil)</span> <span class="pre">=</span> <span class="pre">(Pair</span> <span class="pre">4</span> <span class="pre">&quot;a&quot;,</span> <span class="pre">Pair</span> <span class="pre">7</span> <span class="pre">&quot;b&quot;,</span> <span class="pre">Nil)</span>
<span class="pre">zip</span> <span class="pre">(4,</span> <span class="pre">7,</span> <span class="pre">Nil)</span> <span class="pre">(&quot;a&quot;,</span> <span class="pre">&quot;b&quot;,</span> <span class="pre">&quot;c&quot;,</span> <span class="pre">Nil)</span> <span class="pre">=</span> <span class="pre">(Pair</span> <span class="pre">4</span> <span class="pre">&quot;a&quot;,</span> <span class="pre">Pair</span> <span class="pre">7</span> <span class="pre">&quot;b&quot;,</span> <span class="pre">Nil)</span>
<span class="pre">zip</span> <span class="pre">Nil</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">Nil</span>
<span class="pre">zip</span> <span class="pre">x</span> <span class="pre">Nil</span> <span class="pre">=</span> <span class="pre">Nil</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a:</span> <span class="pre">List</span> <span class="pre">a,</span>&#160; <span class="pre">b:</span> <span class="pre">List</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">(Pair</span> <span class="pre">a</span> <span class="pre">b)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def unzip (list: List (Pair a b)): Pair (List a) (List b)">
<code class="descname">def unzip (list: List (Pair a b)): Pair (List a) (List b)</code><a class="headerlink" href="#function-def unzip (list: List (Pair a b)): Pair (List a) (List b)" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn a List of Pairs into a Pair of Lists</p>
<p>Guarantees:
- Both output lists will be the same length
- if <cite>(len x) == (len y)</cite> then <cite>unzip (zip x y) = Pair x y</cite>
- <cite>((Pair x y) zip x y) (unzip l) = l</cite></p>
<p>Example:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">unzip</span> <span class="pre">(Pair</span> <span class="pre">4</span> <span class="pre">&quot;a&quot;,</span> <span class="pre">Pair</span> <span class="pre">7</span> <span class="pre">&quot;b&quot;,</span> <span class="pre">Nil)</span> <span class="pre">=</span> <span class="pre">Pair</span> <span class="pre">(4,</span> <span class="pre">7,</span> <span class="pre">Nil)</span> <span class="pre">(&quot;a&quot;,</span> <span class="pre">&quot;b&quot;,</span> <span class="pre">Nil)</span>
<span class="pre">unzip</span> <span class="pre">Nil</span> <span class="pre">=</span> <span class="pre">Pair</span> <span class="pre">Nil</span> <span class="pre">Nil</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">list:</span> <span class="pre">List</span> <span class="pre">Pair</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Pair</span> <span class="pre">(List</span> <span class="pre">a)</span> <span class="pre">(List</span> <span class="pre">b)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def groupBy (cmpFn: a">
<code class="descname">def groupBy (cmpFn: a</code><a class="headerlink" href="#function-def groupBy (cmpFn: a" title="Permalink to this definition">¶</a></dt>
<dd><p>Group a list by some comparison function.
Elements which compare equal are placed into the same bucket.
Buckets preserve the order of the original list.
The buckets appear in the sort-order specified by cmpFn.</p>
<p>Examples:
<a href="#id9"><span class="problematic" id="id10">``</span></a>`
def cmp a b = a%3 &lt; b%3
def list = seq 10
groupBy cmp list =
(0,3,6,9,Nil), (1,4,7,Nil), (2,5,8,Nil), Nil</p>
<p>def cmp a b = a/3 &gt; b/3
def list = seq 10
groupBy cmp list =
(9,Nil), (6,7,8,Nil), (3,4,5,Nil), (0,1,2,Nil), Nil
<a href="#id11"><span class="problematic" id="id12">``</span></a><a href="#id13"><span class="problematic" id="id14">`</span></a></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">cmpFn:</span> <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">Order,</span>&#160; <span class="pre">list:</span> <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">(List</span> <span class="pre">a)</span></code></p>
</dd></dl>

</div>
<div class="section" id="string-wake">
<h2>string.wake<a class="headerlink" href="#string-wake" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="function-def strlen (string: String): Integer">
<code class="descname">def strlen (string: String): Integer</code><a class="headerlink" href="#function-def strlen (string: String): Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>strlen: report the number of bytes a String consumes in UTF-8 representation.
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; THIS IS NOT THE NUMBER OF CHARACTERS IN A STRING &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
This information can be relevant when reading / writing Strings to disk.
To manipulate Strings, such as extract-ing a substring, use regular expressions.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">string:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def cat (strings: List String): String">
<code class="descname">def cat (strings: List String): String</code><a class="headerlink" href="#function-def cat (strings: List String): String" title="Permalink to this definition">¶</a></dt>
<dd><p>cat: concatenate a List of Strings into a String.
If you have a finite list of terms, consider using String interpolation.</p>
<p>cat (“hello”, ” “, “world”, Nil) = “hello world”
cat (x, “:”, y, “:”, z, Nil) = “{x}:{y}:{z}”</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">strings:</span> <span class="pre">List</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">String</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def catWith (separator: String) (strings: List String): String">
<code class="descname">def catWith (separator: String) (strings: List String): String</code><a class="headerlink" href="#function-def catWith (separator: String) (strings: List String): String" title="Permalink to this definition">¶</a></dt>
<dd><p>catWith: concatenate a List of Strings with a separator.</p>
<p>seq 10
| map str
| catWith “:”
—
“0:1:2:3:4:5:6:7:8:9”</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">separator:</span> <span class="pre">String,</span>&#160; <span class="pre">strings:</span> <span class="pre">List</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">String</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def explode (string: String): List String">
<code class="descname">def explode (string: String): List String</code><a class="headerlink" href="#function-def explode (string: String): List String" title="Permalink to this definition">¶</a></dt>
<dd><p>explode: split a String up into Unicode code points
This is rarely useful; consider using a RegExp instead.</p>
<p>explode “hello” = “h”, “e”, “l”, “l”, “o”, Nil
explode “süß”   = “s”, “ü”, “ß”, Nil</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">string:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">String</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def strbase (base: Integer): Option (Integer">
<code class="descname">def strbase (base: Integer): Option (Integer</code><a class="headerlink" href="#function-def strbase (base: Integer): Option (Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>strbase: convert an Integer into a String using a given base.</p>
<p>For 2 &lt;= base &lt;= 36, the characters used for the encoding are:
0123456789abcdefghijklmnopqrstuvwxyz
^^^^^^^^^^^^^^^^ = base 16
^^^^^^^^^^ = base 10
For 37 &lt;= base &lt;= 62, the characters used for the encoding are:
0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
For -36 &lt;=x &lt;= -2, the characters used for the encoding are:
0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ
For any other (invalid) base, the String “” is returned.</p>
<p>strbase   10    500 =  “500”
strbase   16  65535 = “ffff”
strbase (-15) 65535 = “FFFF”</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">base:</span> <span class="pre">Integer,</span>&#160; <span class="pre">Option</span> <span class="pre">integerToFormat:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">String)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def intbase (base: Integer) (stringToParse: String): Option Integer">
<code class="descname">def intbase (base: Integer) (stringToParse: String): Option Integer</code><a class="headerlink" href="#function-def intbase (base: Integer) (stringToParse: String): Option Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>intbase: convert a String into an Option Integer using a given base.</p>
<p>For base == 0, the string is checked for these prefixes:
“0b” or “0B” – base= 2 processing for everything after the prefix
“0x” or “0X” – base=16 processing for everything after the prefix
“0”          – base= 8 processing for everything after the prefix
otherwise, process the String as base=10
For 2  &lt;= base &lt;= 36, upper- and lower-case characters are treated identically.
For 37 &lt;= base &lt;= 62, upper-case letters represent 10..35 while lower-case letters represent 36..61.</p>
<p>For any other base (or an illegal input String), None is returned.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">base:</span> <span class="pre">Integer,</span>&#160; <span class="pre">stringToParse:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def int (stringToParse: String): Option Integer">
<code class="descname">def int (stringToParse: String): Option Integer</code><a class="headerlink" href="#function-def int (stringToParse: String): Option Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>int: convert a String into an Integer with the usual prefixes.</p>
<p>The base used for the conversion depends on the prefix:
“0b” or “0B” – base= 2 processing for everything after the prefix
“0x” or “0X” – base=16 processing for everything after the prefix
“0”          – base= 8 processing for everything after the prefix
otherwise, process the String as base=10</p>
<p>int “0x10” = Some 16
int “10”   = Some 10
int “0b10” = Some 2
int “0y10” = None</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">stringToParse:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def integerToUnicode (codepoint: Integer): String">
<code class="descname">def integerToUnicode (codepoint: Integer): String</code><a class="headerlink" href="#function-def integerToUnicode (codepoint: Integer): String" title="Permalink to this definition">¶</a></dt>
<dd><p>integerToUnicode: convert an Integer into a Unicode codepoint.
For Integers &lt;= 127, this is the ASCII character set.
For Integers &lt; 0, returns “”.</p>
<p>integerToUnicode (-2) = “”
integerToUnicode 48 = “0”
integerToUnicode 65 = “A”
integerToUnicode 97 = “a”
integerToUnicode 231 = “ç”
integerToUnicode 0x1f600 = “😀”
integerToUnicode 0 = “x00”</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">codepoint:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">String</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def unicodeToInteger (firstCharacterToConvert: String): Integer">
<code class="descname">def unicodeToInteger (firstCharacterToConvert: String): Integer</code><a class="headerlink" href="#function-def unicodeToInteger (firstCharacterToConvert: String): Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>unicodeToInteger: convert the first codepoint in a String to an Integer.</p>
<p>unicodeToInteger “A” = 65
unicodeToInteger “a” = 97
unicodeToInteger “0123” = 48
unicodeToInteger “😀!” = 128512
unicodeToInteger “” = 0
unicodeToInteger “0a” = 0</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">firstCharacterToConvert:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def integerToByte (byte: Integer): String">
<code class="descname">def integerToByte (byte: Integer): String</code><a class="headerlink" href="#function-def integerToByte (byte: Integer): String" title="Permalink to this definition">¶</a></dt>
<dd><p>integerToByte: convert an Integer into a String using raw binary.
WARNING: For 128 &lt;= byte &lt;= 255, this function creates invalid UTF-8 / Unicode.
Instead of calling this function, you probably meant to call integerToUnicode.
For byte &lt; 0 or byte &gt; 255, returns “”.</p>
<p>integerToByte 0 = “x00”
integerToByte 65 = “A”
integerToByte 97 = “A”
integerToByte 256 = “”
integerToByte 231 = (an illegal UTF-8 String which includes a byte with value 0xe7)</p>
<p>It is possible to create legal UTF-8 from illegal String fragments; eg:
“{integerToByte 0xc3}{integerToByte 0xa7}” = “ç”</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">byte:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">String</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def byteToInteger (firstByteToConvert: String): Integer">
<code class="descname">def byteToInteger (firstByteToConvert: String): Integer</code><a class="headerlink" href="#function-def byteToInteger (firstByteToConvert: String): Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>byteToInteger: convert the first byte of a UTF-8-encoded String into an Integer.
Instead of calling this function, you probably meant to call unicodeToInteger.</p>
<p>byteToInteger “” = 0
byteToInteger “x00” = 0
byteToInteger “A” = 65
byteToInteger (integerToByte 231) = 231</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">firstByteToConvert:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def unicodeCanonical (str: String): String">
<code class="descname">def unicodeCanonical (str: String): String</code><a class="headerlink" href="#function-def unicodeCanonical (str: String): String" title="Permalink to this definition">¶</a></dt>
<dd><p>unicodeCanonical: eliminate combining characters; C+◌̧ =&gt; Ç</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">str:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">String</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def unicodeIdentifier (str: String): String">
<code class="descname">def unicodeIdentifier (str: String): String</code><a class="headerlink" href="#function-def unicodeIdentifier (str: String): String" title="Permalink to this definition">¶</a></dt>
<dd><p>unicodeIdentifier: eliminate rendering distinctions; ¼i⁹ =&gt; 1/4i9</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">str:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">String</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def unicodeLowercase (str: String): String">
<code class="descname">def unicodeLowercase (str: String): String</code><a class="headerlink" href="#function-def unicodeLowercase (str: String): String" title="Permalink to this definition">¶</a></dt>
<dd><p>unicodeLowercase: eliminate case distinctions; C =&gt; c</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">str:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">String</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def sortStrings (list: List String): List String">
<code class="descname">def sortStrings (list: List String): List String</code><a class="headerlink" href="#function-def sortStrings (list: List String): List String" title="Permalink to this definition">¶</a></dt>
<dd><p>sortStrings: sort a list of strings as a human would judge them.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">list:</span> <span class="pre">List</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">String</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def scmpCanonical (x: String) (y: String): Order">
<code class="descname">def scmpCanonical (x: String) (y: String): Order</code><a class="headerlink" href="#function-def scmpCanonical (x: String) (y: String): Order" title="Permalink to this definition">¶</a></dt>
<dd><p>Unicode NFC string comparison Ç == C+◌̧</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">String,</span>&#160; <span class="pre">y:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Order</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def scmpIdentifier (x: String) (y: String): Order">
<code class="descname">def scmpIdentifier (x: String) (y: String): Order</code><a class="headerlink" href="#function-def scmpIdentifier (x: String) (y: String): Order" title="Permalink to this definition">¶</a></dt>
<dd><p>Unicode NFKC string comparison (¼i⁹ = 1/4i9)</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">String,</span>&#160; <span class="pre">y:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Order</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def scmpLowercase (x: String) (y: String): Order">
<code class="descname">def scmpLowercase (x: String) (y: String): Order</code><a class="headerlink" href="#function-def scmpLowercase (x: String) (y: String): Order" title="Permalink to this definition">¶</a></dt>
<dd><p>Unicode case insensitive NFKC comparison</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">String,</span>&#160; <span class="pre">y:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Order</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def scmp (x: String) (y: String): Order">
<code class="descname">def scmp (x: String) (y: String): Order</code><a class="headerlink" href="#function-def scmp (x: String) (y: String): Order" title="Permalink to this definition">¶</a></dt>
<dd><p>Raw binary string comparison; no normalization performed</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">String,</span>&#160; <span class="pre">y:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Order</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: String) &lt;=&gt;~ (y: String): Order">
<code class="descname">def (x: String) &lt;=&gt;~ (y: String): Order</code><a class="headerlink" href="#function-def (x: String) <=>~ (y: String): Order" title="Permalink to this definition">¶</a></dt>
<dd><p>NFKC order (fancy format removed) – secure default
This is the string order you should use to compare human inputs</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">String,</span>&#160; <span class="pre">y:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Order</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: String) &lt;~ (y: String): Boolean">
<code class="descname">def (x: String) &lt;~ (y: String): Boolean</code><a class="headerlink" href="#function-def (x: String) <~ (y: String): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if x is less than y, as a human would judge it.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">String,</span>&#160; <span class="pre">y:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: String) &gt;~ (y: String): Boolean">
<code class="descname">def (x: String) &gt;~ (y: String): Boolean</code><a class="headerlink" href="#function-def (x: String) >~ (y: String): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if x is greater than y, as a human would judge it.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">String,</span>&#160; <span class="pre">y:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: String) &gt;=~ (y: String): Boolean">
<code class="descname">def (x: String) &gt;=~ (y: String): Boolean</code><a class="headerlink" href="#function-def (x: String) >=~ (y: String): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if x is greater than or equal to y, as a human would judge it.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">String,</span>&#160; <span class="pre">y:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: String) &lt;=~ (y: String): Boolean">
<code class="descname">def (x: String) &lt;=~ (y: String): Boolean</code><a class="headerlink" href="#function-def (x: String) <=~ (y: String): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if x is less than or equal to y, as a human would judge it.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">String,</span>&#160; <span class="pre">y:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: String)">
<code class="descname">def (x: String)</code><a class="headerlink" href="#function-def (x: String)" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if x is equal to y, as a human would judge it.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">String,</span>&#160; <span class="pre">y:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: String) !=~ (y: String): Boolean">
<code class="descname">def (x: String) !=~ (y: String): Boolean</code><a class="headerlink" href="#function-def (x: String) !=~ (y: String): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if x is not equal to y, as a human would judge it.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">String,</span>&#160; <span class="pre">y:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: String) &lt;=&gt;^ (y: String): Order">
<code class="descname">def (x: String) &lt;=&gt;^ (y: String): Order</code><a class="headerlink" href="#function-def (x: String) <=>^ (y: String): Order" title="Permalink to this definition">¶</a></dt>
<dd><p>Case insensitive order (^ = capitals ignored)</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">String,</span>&#160; <span class="pre">y:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Order</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: String) &lt;^ (y: String): Boolean">
<code class="descname">def (x: String) &lt;^ (y: String): Boolean</code><a class="headerlink" href="#function-def (x: String) <^ (y: String): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if x is less than y, ignoring case.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">String,</span>&#160; <span class="pre">y:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: String) &gt;^ (y: String): Boolean">
<code class="descname">def (x: String) &gt;^ (y: String): Boolean</code><a class="headerlink" href="#function-def (x: String) >^ (y: String): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if x is greater than y, ignoring case.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">String,</span>&#160; <span class="pre">y:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: String) &gt;=^ (y: String): Boolean">
<code class="descname">def (x: String) &gt;=^ (y: String): Boolean</code><a class="headerlink" href="#function-def (x: String) >=^ (y: String): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if x is greater than or equal to y, ignoring case.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">String,</span>&#160; <span class="pre">y:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: String) &lt;=^ (y: String): Boolean">
<code class="descname">def (x: String) &lt;=^ (y: String): Boolean</code><a class="headerlink" href="#function-def (x: String) <=^ (y: String): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if x is less than or equal to y, ignoring case.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">String,</span>&#160; <span class="pre">y:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: String)">
<code class="descname">def (x: String)</code><a class="headerlink" href="#function-def (x: String)" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if x is equal to y, ignoring case.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">String,</span>&#160; <span class="pre">y:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: String) !=^ (y: String): Boolean">
<code class="descname">def (x: String) !=^ (y: String): Boolean</code><a class="headerlink" href="#function-def (x: String) !=^ (y: String): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if x is not equal to y, ignoring case.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">String,</span>&#160; <span class="pre">y:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: String) &lt;=&gt;* (y: String): Order">
<code class="descname">def (x: String) &lt;=&gt;* (y: String): Order</code><a class="headerlink" href="#function-def (x: String) <=>* (y: String): Order" title="Permalink to this definition">¶</a></dt>
<dd><p>Raw binary string order
Only use this for non-textual data</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">String,</span>&#160; <span class="pre">y:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Order</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: String) &lt;* (y: String): Boolean">
<code class="descname">def (x: String) &lt;* (y: String): Boolean</code><a class="headerlink" href="#function-def (x: String) <* (y: String): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if x is less than y, in UTF-8 representation.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">String,</span>&#160; <span class="pre">y:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: String) &gt;* (y: String): Boolean">
<code class="descname">def (x: String) &gt;* (y: String): Boolean</code><a class="headerlink" href="#function-def (x: String) >* (y: String): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if x is greater than y, in UTF-8 representation.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">String,</span>&#160; <span class="pre">y:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: String) &gt;=* (y: String): Boolean">
<code class="descname">def (x: String) &gt;=* (y: String): Boolean</code><a class="headerlink" href="#function-def (x: String) >=* (y: String): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if x is greater than or equal to y, in UTF-8 representation.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">String,</span>&#160; <span class="pre">y:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: String) &lt;=* (y: String): Boolean">
<code class="descname">def (x: String) &lt;=* (y: String): Boolean</code><a class="headerlink" href="#function-def (x: String) <=* (y: String): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if x is less than or equal to y, in UTF-8 representation.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">String,</span>&#160; <span class="pre">y:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: String)">
<code class="descname">def (x: String)</code><a class="headerlink" href="#function-def (x: String)" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if x is equal to y, in UTF-8 representation.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">String,</span>&#160; <span class="pre">y:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: String) !=* (y: String): Boolean">
<code class="descname">def (x: String) !=* (y: String): Boolean</code><a class="headerlink" href="#function-def (x: String) !=* (y: String): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if x is not equal to y, in UTF-8 representation.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">String,</span>&#160; <span class="pre">y:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

</div>
<div class="section" id="integer-wake">
<h2>integer.wake<a class="headerlink" href="#integer-wake" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="function-def +(x: Integer): Integer">
<code class="descname">def +(x: Integer): Integer</code><a class="headerlink" href="#function-def +(x: Integer): Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Unary positive sign operator for Integer values.
(+5) = 5</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def -(x: Integer): Integer">
<code class="descname">def -(x: Integer): Integer</code><a class="headerlink" href="#function-def -(x: Integer): Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Unary negative sign operator for Integer values.
(-5) = 0-5</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def ~(x: Integer): Integer">
<code class="descname">def ~(x: Integer): Integer</code><a class="headerlink" href="#function-def ~(x: Integer): Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Unary two’s complement operator for Integer values.
~0 = -1
~4 = -5</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: Integer) + (y: Integer): Integer">
<code class="descname">def (x: Integer) + (y: Integer): Integer</code><a class="headerlink" href="#function-def (x: Integer) + (y: Integer): Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary addition operator for Integer values.
1 + 2 = 3
1 + 5 = 6</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer,</span>&#160; <span class="pre">y:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: Integer) - (y: Integer): Integer">
<code class="descname">def (x: Integer) - (y: Integer): Integer</code><a class="headerlink" href="#function-def (x: Integer) - (y: Integer): Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary subtraction operator for Integer values.
2 - 1 =  1
3 - 4 = -1</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer,</span>&#160; <span class="pre">y:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: Integer) * (y: Integer): Integer">
<code class="descname">def (x: Integer) * (y: Integer): Integer</code><a class="headerlink" href="#function-def (x: Integer) * (y: Integer): Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary multiplication operator for Integer values.
3 *   4  = 12
-3 * (-4) = 12</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer,</span>&#160; <span class="pre">y:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: Integer) / (y: Integer): Integer">
<code class="descname">def (x: Integer) / (y: Integer): Integer</code><a class="headerlink" href="#function-def (x: Integer) / (y: Integer): Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary division operator for Integer values.
12 / 3 =  4
13 / 3 =  4
-8 / 4 = -2</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer,</span>&#160; <span class="pre">y:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: Integer) % (y: Integer): Integer">
<code class="descname">def (x: Integer) % (y: Integer): Integer</code><a class="headerlink" href="#function-def (x: Integer) % (y: Integer): Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary remainder operator for Integer values.
11 % 5 = 1
4 % 5 = 5
7 % 5 = 2</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer,</span>&#160; <span class="pre">y:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: Integer) &lt;&lt; (y: Integer): Integer">
<code class="descname">def (x: Integer) &lt;&lt; (y: Integer): Integer</code><a class="headerlink" href="#function-def (x: Integer) << (y: Integer): Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary left shift operator for Integer values.
1 &lt;&lt; 10 = 1024
3 &lt;&lt;  8 =  768</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer,</span>&#160; <span class="pre">y:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: Integer) &gt;&gt; (y: Integer): Integer">
<code class="descname">def (x: Integer) &gt;&gt; (y: Integer): Integer</code><a class="headerlink" href="#function-def (x: Integer) >> (y: Integer): Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary right shift operator for Integer values.
1024 &gt;&gt; 11 = 0
1024 &gt;&gt;  9 = 2
768 &gt;&gt;  8 = 3</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer,</span>&#160; <span class="pre">y:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: Integer) ^ (y: Integer): Integer">
<code class="descname">def (x: Integer) ^ (y: Integer): Integer</code><a class="headerlink" href="#function-def (x: Integer) ^ (y: Integer): Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary exponentiation operator for Integer values.
2^8 = 256
3^2 = 9
5^3 = 125</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer,</span>&#160; <span class="pre">y:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def root (n: Integer) (x: Integer): Option Integer">
<code class="descname">def root (n: Integer) (x: Integer): Option Integer</code><a class="headerlink" href="#function-def root (n: Integer) (x: Integer): Option Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the n-th root of x.
root 2  9    = Some 3
root 3 27    = Some 3
root 3 28    = Some 3
root 3 (-27) = Some -3
root 2 (-9)  = None</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">n:</span> <span class="pre">Integer,</span>&#160; <span class="pre">x:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def sqrt (x: Integer): Option Integer">
<code class="descname">def sqrt (x: Integer): Option Integer</code><a class="headerlink" href="#function-def sqrt (x: Integer): Option Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Unary square root operator.
sqrt 9    = Some 3
sqrt (-9) = None</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def abs (x: Integer): Integer">
<code class="descname">def abs (x: Integer): Integer</code><a class="headerlink" href="#function-def abs (x: Integer): Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Unary absolute-value operator.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def xor (x: Integer) (y: Integer): Integer">
<code class="descname">def xor (x: Integer) (y: Integer): Integer</code><a class="headerlink" href="#function-def xor (x: Integer) (y: Integer): Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary bitwise XOR operator.
xor 4 4 = 0
xor 4 3 = 7
xor (-4) (-3) = 1</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer,</span>&#160; <span class="pre">y:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def and (x: Integer) (y: Integer): Integer">
<code class="descname">def and (x: Integer) (y: Integer): Integer</code><a class="headerlink" href="#function-def and (x: Integer) (y: Integer): Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary bitwise AND operator.
and 4 4 = 4
and 4 3 = 0
and (-4) (-3) = -4</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer,</span>&#160; <span class="pre">y:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def or (x: Integer) (y: Integer): Integer">
<code class="descname">def or (x: Integer) (y: Integer): Integer</code><a class="headerlink" href="#function-def or (x: Integer) (y: Integer): Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary bitwise OR operator.
or 4 4 = 4
or 4 3 = 7
or (-4) (-3) = -3</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer,</span>&#160; <span class="pre">y:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def gcd (x: Integer) (y: Integer): Integer">
<code class="descname">def gcd (x: Integer) (y: Integer): Integer</code><a class="headerlink" href="#function-def gcd (x: Integer) (y: Integer): Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Greatest Common Divisor.
gcd 4 4 = 4
gcd 4 3 = 1
gcd (-4) (-3) = 1</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer,</span>&#160; <span class="pre">y:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def lcm (x: Integer) (y: Integer): Integer">
<code class="descname">def lcm (x: Integer) (y: Integer): Integer</code><a class="headerlink" href="#function-def lcm (x: Integer) (y: Integer): Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Least Common Multiple.
lcm 4 4 = 4
lcm 4 3 = 12
lcm (-4) (-3) = 12</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer,</span>&#160; <span class="pre">y:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def powm (x: Integer) (y: Integer) (m: Integer): Integer">
<code class="descname">def powm (x: Integer) (y: Integer) (m: Integer): Integer</code><a class="headerlink" href="#function-def powm (x: Integer) (y: Integer) (m: Integer): Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes (x^y) % m.
powm 2 7 5 = 4
powm 3 2 2 = 1</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer,</span>&#160; <span class="pre">y:</span> <span class="pre">Integer,</span>&#160; <span class="pre">m:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def icmp (x: Integer) (y: Integer): Order">
<code class="descname">def icmp (x: Integer) (y: Integer): Order</code><a class="headerlink" href="#function-def icmp (x: Integer) (y: Integer): Order" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two Integers for Order
icmp 4 5 = LT
icmp 5 5 = EQ
icmp 5 4 = GT</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer,</span>&#160; <span class="pre">y:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Order</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: Integer) &lt;=&gt; (y: Integer): Order">
<code class="descname">def (x: Integer) &lt;=&gt; (y: Integer): Order</code><a class="headerlink" href="#function-def (x: Integer) <=> (y: Integer): Order" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two Integers for Order
4 &lt;=&gt; 5 = LT
5 &lt;=&gt; 5 = EQ
5 &lt;=&gt; 4 = GT</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer,</span>&#160; <span class="pre">y:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Order</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: Integer) &lt; (y: Integer): Boolean">
<code class="descname">def (x: Integer) &lt; (y: Integer): Boolean</code><a class="headerlink" href="#function-def (x: Integer) < (y: Integer): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary Less-Than operator for Integers.
4 &lt; 5 = True
4 &lt; 4 = False
5 &lt; 4 = False</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer,</span>&#160; <span class="pre">y:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: Integer) &gt; (y: Integer): Boolean">
<code class="descname">def (x: Integer) &gt; (y: Integer): Boolean</code><a class="headerlink" href="#function-def (x: Integer) > (y: Integer): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary Greater-Than operator for Integers.
4 &gt; 5 = False
4 &gt; 4 = False
5 &gt; 4 = True</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer,</span>&#160; <span class="pre">y:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: Integer) &gt;= (y: Integer): Boolean">
<code class="descname">def (x: Integer) &gt;= (y: Integer): Boolean</code><a class="headerlink" href="#function-def (x: Integer) >= (y: Integer): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary Greater-Or-Equal operator for Integers.
4 &gt;= 5 = False
4 &gt;= 4 = True
5 &gt;= 4 = True</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer,</span>&#160; <span class="pre">y:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: Integer) &lt;= (y: Integer): Boolean">
<code class="descname">def (x: Integer) &lt;= (y: Integer): Boolean</code><a class="headerlink" href="#function-def (x: Integer) <= (y: Integer): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary Less-Or-Equal operator for Integers.
4 &lt;= 5 = True
4 &lt;= 4 = True
5 &lt;= 4 = False</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer,</span>&#160; <span class="pre">y:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: Integer)">
<code class="descname">def (x: Integer)</code><a class="headerlink" href="#function-def (x: Integer)" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary Is-Equal operator for Integers.
4 == 5 = False
4 == 4 = True
5 == 4 = False</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer,</span>&#160; <span class="pre">y:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: Integer) != (y: Integer): Boolean">
<code class="descname">def (x: Integer) != (y: Integer): Boolean</code><a class="headerlink" href="#function-def (x: Integer) != (y: Integer): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary Not-Equal operator for Integers.
4 == 5 = True
4 == 4 = False
5 == 4 = True</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer,</span>&#160; <span class="pre">y:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def min (x: Integer) (y: Integer): Integer">
<code class="descname">def min (x: Integer) (y: Integer): Integer</code><a class="headerlink" href="#function-def min (x: Integer) (y: Integer): Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the minimum of two Integers.
min 4 5 = 4</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer,</span>&#160; <span class="pre">y:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def max (x: Integer) (y: Integer): Integer">
<code class="descname">def max (x: Integer) (y: Integer): Integer</code><a class="headerlink" href="#function-def max (x: Integer) (y: Integer): Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the maximum of two Integers.
max 4 5 = 5</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer,</span>&#160; <span class="pre">y:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def ∏ (l: List Integer): Integer">
<code class="descname">def ∏ (l: List Integer): Integer</code><a class="headerlink" href="#function-def ∏ (l: List Integer): Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">l:</span> <span class="pre">List</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def ∑ (l: List Integer): Integer">
<code class="descname">def ∑ (l: List Integer): Integer</code><a class="headerlink" href="#function-def ∑ (l: List Integer): Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">l:</span> <span class="pre">List</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Integer</span></code></p>
</dd></dl>

</div>
<div class="section" id="json-wake">
<h2>json.wake<a class="headerlink" href="#json-wake" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="function-def getJString: JValue =&gt; Option String">
<code class="descname">def getJString: JValue =&gt; Option String</code><a class="headerlink" href="#function-def getJString: JValue => Option String" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">JValue</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">String</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def getJInteger: JValue =&gt; Option Integer">
<code class="descname">def getJInteger: JValue =&gt; Option Integer</code><a class="headerlink" href="#function-def getJInteger: JValue => Option Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">JValue</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def getJDouble: JValue =&gt; Option Double">
<code class="descname">def getJDouble: JValue =&gt; Option Double</code><a class="headerlink" href="#function-def getJDouble: JValue => Option Double" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">JValue</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def getJBoolean: JValue =&gt; Option Boolean">
<code class="descname">def getJBoolean: JValue =&gt; Option Boolean</code><a class="headerlink" href="#function-def getJBoolean: JValue => Option Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">JValue</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def getJObject: JValue =&gt; Option (List (Pair String JValue))">
<code class="descname">def getJObject: JValue =&gt; Option (List (Pair String JValue))</code><a class="headerlink" href="#function-def getJObject: JValue => Option (List (Pair String JValue))" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">JValue</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">(List</span> <span class="pre">(Pair</span> <span class="pre">String</span> <span class="pre">JValue))</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def getJArray: JValue =&gt; Option (List JValue)">
<code class="descname">def getJArray: JValue =&gt; Option (List JValue)</code><a class="headerlink" href="#function-def getJArray: JValue => Option (List JValue)" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">JValue</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">(List</span> <span class="pre">JValue)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def parseJSONBody (body: String): Result JValue Error">
<code class="descname">def parseJSONBody (body: String): Result JValue Error</code><a class="headerlink" href="#function-def parseJSONBody (body: String): Result JValue Error" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">body:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Result</span> <span class="pre">JValue</span> <span class="pre">Error</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def parseJSONFile (path: Path): Result JValue Error">
<code class="descname">def parseJSONFile (path: Path): Result JValue Error</code><a class="headerlink" href="#function-def parseJSONFile (path: Path): Result JValue Error" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">path:</span> <span class="pre">Path</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Result</span> <span class="pre">JValue</span> <span class="pre">Error</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def jsonEscape str">
<code class="descname">def jsonEscape str</code><a class="headerlink" href="#function-def jsonEscape str" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">str:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">String</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def prettyJSONFormat">
<code class="descname">def prettyJSONFormat</code><a class="headerlink" href="#function-def prettyJSONFormat" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: None</p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">JSONFormat</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def customFormatJSON fmt body">
<code class="descname">def customFormatJSON fmt body</code><a class="headerlink" href="#function-def customFormatJSON fmt body" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">fmt:</span> <span class="pre">JSONFormat,</span>&#160; <span class="pre">body:</span> <span class="pre">JValue</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">String</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def formatJSON">
<code class="descname">def formatJSON</code><a class="headerlink" href="#function-def formatJSON" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">body:</span> <span class="pre">JValue</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">String</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def prettyJSON">
<code class="descname">def prettyJSON</code><a class="headerlink" href="#function-def prettyJSON" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">body:</span> <span class="pre">JValue</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">String</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def root /| filterFn">
<code class="descname">def root /| filterFn</code><a class="headerlink" href="#function-def root /| filterFn" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">root:</span> <span class="pre">JValue,</span>&#160; <span class="pre">filterFn:</span> <span class="pre">JValue,</span>&#160; <span class="pre">Boolean</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">JValue</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def jfilter filterFn root">
<code class="descname">def jfilter filterFn root</code><a class="headerlink" href="#function-def jfilter filterFn root" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">filterFn:</span> <span class="pre">JValue,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">root:</span> <span class="pre">JValue</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">JValue</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def root /../ filterFn">
<code class="descname">def root /../ filterFn</code><a class="headerlink" href="#function-def root /../ filterFn" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">root:</span> <span class="pre">JValue,</span>&#160; <span class="pre">filterFn:</span> <span class="pre">JValue,</span>&#160; <span class="pre">Boolean</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">JValue</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def jfind filterFn root">
<code class="descname">def jfind filterFn root</code><a class="headerlink" href="#function-def jfind filterFn root" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">filterFn:</span> <span class="pre">JValue,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">root:</span> <span class="pre">JValue</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">JValue</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def jempty root">
<code class="descname">def jempty root</code><a class="headerlink" href="#function-def jempty root" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">root:</span> <span class="pre">JValue</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def jlist root">
<code class="descname">def jlist root</code><a class="headerlink" href="#function-def jlist root" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">root:</span> <span class="pre">JValue</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">JValue</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def x // y">
<code class="descname">def x // y</code><a class="headerlink" href="#function-def x // y" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">JValue,</span>&#160; <span class="pre">y:</span> <span class="pre">RegExp</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">JValue</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def x ==/ y">
<code class="descname">def x ==/ y</code><a class="headerlink" href="#function-def x ==/ y" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">JValue,</span>&#160; <span class="pre">y:</span> <span class="pre">JValue</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def normalizeJSONWith (fmt: JSONNormalize) (json: JValue): Result JValue Error">
<code class="descname">def normalizeJSONWith (fmt: JSONNormalize) (json: JValue): Result JValue Error</code><a class="headerlink" href="#function-def normalizeJSONWith (fmt: JSONNormalize) (json: JValue): Result JValue Error" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplify a JSON structure according to the rules given.
For example, Wake’s implementation of JSON is more lenient than the base
standards, so if maximum compatibility is desired in situations where some
other implementation may be parsing generated output, <cite>normalizeJSONCompat</cite>
may be used to target that lowest common denominator (see <cite>normalizeJSON</cite> for
that particular case).</p>
<p>Note that the relevant normalization is applied to each member of a <cite>JArray</cite>
or <cite>JObject</cite> <em>before</em> the enclosing container. This means that if some
normalization fails anywhere in the JSON tree the entire call will fail, even
if the specific branch causing the failure would later have been pruned.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">fmt:</span> <span class="pre">JSONNormalize,</span>&#160; <span class="pre">json:</span> <span class="pre">JValue</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Result</span> <span class="pre">JValue</span> <span class="pre">Error</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def mergeJSON (jsons: List JValue): Result JValue Error">
<code class="descname">def mergeJSON (jsons: List JValue): Result JValue Error</code><a class="headerlink" href="#function-def mergeJSON (jsons: List JValue): Result JValue Error" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt to merge several JSON structures, while resolving any duplicate keys.
In particular, this function will concatenate the members of two <cite>JArray</cite>
values, treat <cite>JNull</cite> as a wildcard placeholder, and otherwise return the
original value if both instances are equal. It fails if the same location in
the object tree is associated with multiple values of different types or with
different values of a type which cannot be combined. Returns a <cite>JNull</cite> value
if passed an empty list.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">jsons:</span> <span class="pre">List</span> <span class="pre">JValue</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Result</span> <span class="pre">JValue</span> <span class="pre">Error</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def overrideJSON (jsons: List JValue): JValue">
<code class="descname">def overrideJSON (jsons: List JValue): JValue</code><a class="headerlink" href="#function-def overrideJSON (jsons: List JValue): JValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the value of the key appearing last in the list, but recurse into <cite>JObject`s.
Essentially, allows overwriting any key in the object tree by specifying a new
value at the same place in a later tree. Returns `JNull</cite> if given an empty list.</p>
<p>If some location has <em>both</em> <cite>JObject</cite> values and values of other types, any
<cite>JObject</cite> values before the last non-<cite>JObject</cite> value will be dropped:</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">(&quot;\{\&quot;key\&quot;:\{\&quot;firstSubkey\&quot;:1\}\}&quot;,</span> <span class="pre">&quot;\{\&quot;key\&quot;:\{\&quot;secondSubkey\&quot;:2\}\}&quot;,</span> <span class="pre">Nil)</span>
<span class="pre">|</span> <span class="pre">findFailFn</span> <span class="pre">parseJSONBody</span>
<span class="pre">|</span> <span class="pre">rmapPass</span> <span class="pre">lastValueInList</span>
<span class="pre">|</span> <span class="pre">rmap</span> <span class="pre">formatJSON</span>
<span class="pre">Pass</span> <span class="pre">&quot;\{\&quot;key\&quot;:\{\&quot;firstSubkey\&quot;:1,\&quot;secondSubkey\&quot;:2\}\}&quot;</span>
<span class="pre">`</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">(&quot;\{\&quot;firstKey\&quot;:1\}&quot;,</span> <span class="pre">&quot;2&quot;,</span> <span class="pre">&quot;\{\&quot;secondKey\&quot;:3\}&quot;,</span> <span class="pre">Nil)</span>
<span class="pre">|</span> <span class="pre">findFailFn</span> <span class="pre">parseJSONBody</span>
<span class="pre">|</span> <span class="pre">rmapPass</span> <span class="pre">lastValueInList</span>
<span class="pre">|</span> <span class="pre">rmap</span> <span class="pre">formatJSON</span>
<span class="pre">Pass</span> <span class="pre">&quot;\{\&quot;secondKey\&quot;:3\}&quot;</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">jsons:</span> <span class="pre">List</span> <span class="pre">JValue</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">JValue</span></code></p>
</dd></dl>

<dl class="tuple">
<dt id="function-tuple JSONNormalize">
<code class="descname">tuple JSONNormalize</code><a class="headerlink" href="#function-tuple JSONNormalize" title="Permalink to this definition">¶</a></dt>
<dd><p>The rules by which <cite>normalizeJSONWith</cite> will simplify JSON values.
If any particular function is unable to operate on every input value (e.g. a
<cite>JObject</cite> contains duplicate keys of types which cannot be combined), that
rule may return a <cite>Fail</cite> which halts the broader processing.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">String:</span> <span class="pre">String,</span>&#160; <span class="pre">Result</span> <span class="pre">String</span> <span class="pre">Error,</span>&#160; <span class="pre">Integer:</span> <span class="pre">Integer,</span>&#160; <span class="pre">Result</span> <span class="pre">Integer</span> <span class="pre">Error,</span>&#160; <span class="pre">Double:</span> <span class="pre">Double,</span>&#160; <span class="pre">Result</span> <span class="pre">Double</span> <span class="pre">Error,</span>&#160; <span class="pre">Boolean:</span> <span class="pre">Boolean,</span>&#160; <span class="pre">Result</span> <span class="pre">Boolean</span> <span class="pre">Error,</span>&#160; <span class="pre">Object:</span> <span class="pre">List</span> <span class="pre">Pair</span> <span class="pre">String</span> <span class="pre">JValue,</span>&#160; <span class="pre">Result</span> <span class="pre">List</span> <span class="pre">Pair</span> <span class="pre">String</span> <span class="pre">JValue</span> <span class="pre">Error,</span>&#160; <span class="pre">Array:</span> <span class="pre">List</span> <span class="pre">JValue,</span>&#160; <span class="pre">Result</span> <span class="pre">List</span> <span class="pre">JValue</span> <span class="pre">Error</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">JSONNormalize</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def lastValueInList (values: List JValue): Result JValue Error">
<code class="descname">def lastValueInList (values: List JValue): Result JValue Error</code><a class="headerlink" href="#function-def lastValueInList (values: List JValue): Result JValue Error" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the value of the key appearing last in the list, but recurse into <cite>JObject`s.
Essentially, allows overwriting any key in the object tree by specifying a new
value at the same place in a later tree. Will always always succeed, returning
`Pass JNull</cite> if given an empty list.</p>
<p>See <cite>overrideJSON</cite> for examples of usage.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">values:</span> <span class="pre">List</span> <span class="pre">JValue</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Result</span> <span class="pre">JValue</span> <span class="pre">Error</span></code></p>
</dd></dl>

</div>
<div class="section" id="order-wake">
<h2>order.wake<a class="headerlink" href="#order-wake" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="function-def isLT: Order =&gt; Boolean">
<code class="descname">def isLT: Order =&gt; Boolean</code><a class="headerlink" href="#function-def isLT: Order => Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Is less-than: convert Order to Boolean
def a &lt; b = a &lt;=&gt; b | isLT
isLT LT = True
isLT EQ = False
isLT GT = False</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">Order</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def isEQ: Order =&gt; Boolean">
<code class="descname">def isEQ: Order =&gt; Boolean</code><a class="headerlink" href="#function-def isEQ: Order => Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Is equal: convert Order Boolean
def a == b = a &lt;=&gt; b | isEQ
isEQ LT = False
isEQ EQ = True
isEQ GT = False</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">Order</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def isGT: Order =&gt; Boolean">
<code class="descname">def isGT: Order =&gt; Boolean</code><a class="headerlink" href="#function-def isGT: Order => Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Is greater-than: convert Order to Boolean
def a &gt; b = a &lt;=&gt; b | isGT
isGT LT = False
isGT EQ = False
isGT GT = True</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">Order</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def isLE: Order =&gt; Boolean">
<code class="descname">def isLE: Order =&gt; Boolean</code><a class="headerlink" href="#function-def isLE: Order => Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Is less-than-or-equal: convert Order to Boolean
def a &lt;= b = a &lt;=&gt; b | isLE
isLE LT = True
isLE EQ = True
isLE GT = False</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">Order</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def isNE: Order =&gt; Boolean">
<code class="descname">def isNE: Order =&gt; Boolean</code><a class="headerlink" href="#function-def isNE: Order => Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Is not-equal: convert Order to Boolean
def a != b = a &lt;=&gt; b | isNE
isEQ LT = True
isEQ EQ = False
isEQ GT = True</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">Order</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def isGE: Order =&gt; Boolean">
<code class="descname">def isGE: Order =&gt; Boolean</code><a class="headerlink" href="#function-def isGE: Order => Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Is greater-than-or-equal: convert Order to Boolean
def a &gt;= b = a &lt;=&gt; b | isGE
isGE LT = False
isGE EQ = True
isGE GT = True</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">Order</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

</div>
<div class="section" id="option-wake">
<h2>option.wake<a class="headerlink" href="#option-wake" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="function-def isSome: Option a =&gt; Boolean">
<code class="descname">def isSome: Option a =&gt; Boolean</code><a class="headerlink" href="#function-def isSome: Option a => Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>isSome: Report if an Option has a value.
If you find yourself using the function, consider using a match instead.</p>
<p>isSome (Some 451) = True
isSome (Some “x”) = True
isSome None       = False</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def isNone: Option a =&gt; Boolean">
<code class="descname">def isNone: Option a =&gt; Boolean</code><a class="headerlink" href="#function-def isNone: Option a => Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>isNone: Report if an Option has no value.
If you find yourself using the function, consider using a match instead.</p>
<p>isNone (Some 451) = False
isNone (Some “x”) = False
isNone None       = True</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def getOrElse (default: a): Option a =&gt; a">
<code class="descname">def getOrElse (default: a): Option a =&gt; a</code><a class="headerlink" href="#function-def getOrElse (default: a): Option a => a" title="Permalink to this definition">¶</a></dt>
<dd><p>getOrElse: extract the value from an Option, with a supplied default if None.
The default value expression is evaluated whether or not the Option is None.</p>
<p>int “not-an-integer”     # Option Integer
| getOrElse 5            # Integer
—
5</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">default:</span> <span class="pre">a,</span>&#160; <span class="pre">Option</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def getOrElseFn (fn: Unit =&gt; a): Option a =&gt; a">
<code class="descname">def getOrElseFn (fn: Unit =&gt; a): Option a =&gt; a</code><a class="headerlink" href="#function-def getOrElseFn (fn: Unit => a): Option a => a" title="Permalink to this definition">¶</a></dt>
<dd><p>getOrElse: extract the value from an Option, with a supplied default function if None.
The default value function is evaluated only when the Option is None.</p>
<p>int “567”
| getOrElseFn (Unit firstFactorOf 8947289472892423423423423235325)
—
567</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">fn:</span> <span class="pre">Unit,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">Option</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def orElse (alternate: Option a): Option a =&gt; Option a">
<code class="descname">def orElse (alternate: Option a): Option a =&gt; Option a</code><a class="headerlink" href="#function-def orElse (alternate: Option a): Option a => Option a" title="Permalink to this definition">¶</a></dt>
<dd><p>orElse: combine two Options, using the first value found, if any.</p>
<p>int “not-an-integer”
| orElse (int “343”)
| orElse (int “asd”)
—
Some 343</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">alternate:</span> <span class="pre">Option</span> <span class="pre">a,</span>&#160; <span class="pre">Option</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def omap (f: a =&gt; b): Option a =&gt; Option b">
<code class="descname">def omap (f: a =&gt; b): Option a =&gt; Option b</code><a class="headerlink" href="#function-def omap (f: a => b): Option a => Option b" title="Permalink to this definition">¶</a></dt>
<dd><p>omap: apply function <cite>f</cite> to the optional contents
If you find yourself using the function with getOrElse, consider using a match instead.</p>
<p>omap (_+1) (Some 4) = Some 5
omap (_+1) None     = None</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">Option</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def omapPartial (f: a =&gt; Option b): Option a =&gt; Option b">
<code class="descname">def omapPartial (f: a =&gt; Option b): Option a =&gt; Option b</code><a class="headerlink" href="#function-def omapPartial (f: a => Option b): Option a => Option b" title="Permalink to this definition">¶</a></dt>
<dd><p>omapPartial: apply partial function ‘f’ to the optional contents
A partial function returns Option; only Some cases result in a value.</p>
<p>def divideEven x =
if x&amp;1 == 1 then
None
else
Some (x / 2)</p>
<p>omapPartial divideEven None     = None
omapPartial divideEven (Some 8) = Some 4
omapPartial divideEven (Some 7) = None</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">a,</span>&#160; <span class="pre">Option</span> <span class="pre">b,</span>&#160; <span class="pre">Option</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def ofilter (f: a =&gt; Boolean): Option a =&gt; Option a">
<code class="descname">def ofilter (f: a =&gt; Boolean): Option a =&gt; Option a</code><a class="headerlink" href="#function-def ofilter (f: a => Boolean): Option a => Option a" title="Permalink to this definition">¶</a></dt>
<dd><p>ofilter: remove the contents of an option when <cite>f</cite> returns False.</p>
<p>def isEven x =
x&amp;x == 0
ofilter isEven None     = None
ofilter isEven (Some 7) = None
ofilter isEven (Some 8) = Some 8</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">a,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">Option</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def findSomeFn (fn: a">
<code class="descname">def findSomeFn (fn: a</code><a class="headerlink" href="#function-def findSomeFn (fn: a" title="Permalink to this definition">¶</a></dt>
<dd><p>findSomeFn: return the first Some output by ‘fn’ on a List or else None
Once a Some is found, fn is not evaluated on further elements.
This means that fn is applied to the List mostly sequentially.
If more parallelism is desired, use ‘map fn | findSome’ instead.</p>
<p>findSomeFn int (“abc”, “456”, “zz”, “123”, Nil) = Some 456
findSomeFn int (“abc”, “_56”, “zz”, “_23”, Nil) = None</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">fn:</span> <span class="pre">a,</span>&#160; <span class="pre">Option</span> <span class="pre">b,</span>&#160; <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def findNoneFn (fn: a">
<code class="descname">def findNoneFn (fn: a</code><a class="headerlink" href="#function-def findNoneFn (fn: a" title="Permalink to this definition">¶</a></dt>
<dd><p>findNoneFn: if fn returns Some for all List elements, return the outputs else None
Once a None is found, fn is not evaluated on further elements.
This means that fn is applied to the List mostly sequentially.
If more parallelism is desired, use ‘map fn | findNone’ instead.</p>
<p>findNoneFn int (“456”, “123”, Nil) = Some (456, 123, Nil)
findNoneFn int (“_56”, “123”, Nil) = None</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">fn:</span> <span class="pre">a,</span>&#160; <span class="pre">Option</span> <span class="pre">b,</span>&#160; <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">(List</span> <span class="pre">b)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def getOrFail (failVal: fail): Option pass">
<code class="descname">def getOrFail (failVal: fail): Option pass</code><a class="headerlink" href="#function-def getOrFail (failVal: fail): Option pass" title="Permalink to this definition">¶</a></dt>
<dd><p>getOrFail: Convert Some to Pass and None to a Fail with the supplied value.
The fail expression is evaluated even when the Option is None.</p>
<p>int “not-an-integer”
| getOrFail “some error”
—
Fail “some error”</p>
<p>int “81234”
| getOrFail “some error”
—
Pass 81234</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">failVal:</span> <span class="pre">a,</span>&#160; <span class="pre">Option</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Result</span> <span class="pre">b</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def getOrFailFn (failFn: Unit =&gt; fail): Option pass =&gt; Result pass fail">
<code class="descname">def getOrFailFn (failFn: Unit =&gt; fail): Option pass =&gt; Result pass fail</code><a class="headerlink" href="#function-def getOrFailFn (failFn: Unit => fail): Option pass => Result pass fail" title="Permalink to this definition">¶</a></dt>
<dd><p>getOrFailFn: Convert Some to Pass and None to a Fail with the function output.
The fail function is evaluated only when the Option is None.</p>
<p>int “not-an-integer”
| getOrFailFn (Unit “some error”)
—
Fail “some error”</p>
<p>int “81234”
| getOrFailFn (Unit “some error”)
—
Pass 81234</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">failFn:</span> <span class="pre">Unit,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">Option</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Result</span> <span class="pre">b</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def getOrPass (passVal: pass): Option fail">
<code class="descname">def getOrPass (passVal: pass): Option fail</code><a class="headerlink" href="#function-def getOrPass (passVal: pass): Option fail" title="Permalink to this definition">¶</a></dt>
<dd><p>getOrPass: Convert Some to Fail and None to a Pass with the supplied value.
The fail expression is evaluated even when the Option is None.</p>
<p>int “not-an-integer”
| getOrPass “some error”
—
Pass “some error”</p>
<p>int “81234”
| getOrPass “some error”
—
Fail 81234</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">passVal:</span> <span class="pre">a,</span>&#160; <span class="pre">Option</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Result</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def getOrPassFn (passFn: Unit =&gt; pass): Option fail =&gt; Result pass fail">
<code class="descname">def getOrPassFn (passFn: Unit =&gt; pass): Option fail =&gt; Result pass fail</code><a class="headerlink" href="#function-def getOrPassFn (passFn: Unit => pass): Option fail => Result pass fail" title="Permalink to this definition">¶</a></dt>
<dd><p>getOrPassFn: Convert Some to Fail and None to a Pass with the function output.
The pass function is evaluated only when the Option is None.</p>
<p>int “not-an-integer”
| getOrFailFn (Unit “some error”)
—
Pass “some error”</p>
<p>int “81234”
| getOrFailFn (Unit “some error”)
—
Fail 81234</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">passFn:</span> <span class="pre">Unit,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">Option</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Result</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
</dd></dl>

</div>
<div class="section" id="double-wake">
<h2>double.wake<a class="headerlink" href="#double-wake" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="function-def dabs (x: Double): Double">
<code class="descname">def dabs (x: Double): Double</code><a class="headerlink" href="#function-def dabs (x: Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Unary absolute value operator for a Double.
dabs (+. 2.5) = 2.5
dabs (-. 2.5) = 2.5</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def -. (x: Double): Double">
<code class="descname">def -. (x: Double): Double</code><a class="headerlink" href="#function-def -. (x: Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Unary negative sign for a Double.
-. (-. 2.5) =  2.5
-. (+. 2.5) = -2.5</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def +. (x: Double): Double">
<code class="descname">def +. (x: Double): Double</code><a class="headerlink" href="#function-def +. (x: Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Unary positive sign for a Double.
+. 2.5 = 2.5</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: Double) +. (y: Double): Double">
<code class="descname">def (x: Double) +. (y: Double): Double</code><a class="headerlink" href="#function-def (x: Double) +. (y: Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary addition operator for Double values.
1.1 +. 2.0 = 3.1
0.1 +. 0.5 = 0.6</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double,</span>&#160; <span class="pre">y:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: Double) -. (y: Double): Double">
<code class="descname">def (x: Double) -. (y: Double): Double</code><a class="headerlink" href="#function-def (x: Double) -. (y: Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary subtraction operator for Double values.
4.0 -. 2.2 = 1.8
1.1 -. 2.0 = -. 0.9</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double,</span>&#160; <span class="pre">y:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: Double) *. (y: Double): Double">
<code class="descname">def (x: Double) *. (y: Double): Double</code><a class="headerlink" href="#function-def (x: Double) *. (y: Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary multiplication operator for Double values.
2.0 <a href="#id15"><span class="problematic" id="id16">*</span></a>. 3.3 = 6.6
2.0 <a href="#id17"><span class="problematic" id="id18">*</span></a>. 4.1 = 8.2</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double,</span>&#160; <span class="pre">y:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: Double) /. (y: Double): Double">
<code class="descname">def (x: Double) /. (y: Double): Double</code><a class="headerlink" href="#function-def (x: Double) /. (y: Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary division operator for Double valuess.
4.0 /. 2.0 = 2.0
5.0 /. 2.0 = 2.5</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double,</span>&#160; <span class="pre">y:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: Double) ^. (y: Double): Double">
<code class="descname">def (x: Double) ^. (y: Double): Double</code><a class="headerlink" href="#function-def (x: Double) ^. (y: Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary exponentiation operator for Double values.
2.0 ^. 3.0 = 8.0
0.5 ^. 2.0 = 0.25</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double,</span>&#160; <span class="pre">y:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def dfma (x: Double) (y: Double) (z: Double): Double">
<code class="descname">def dfma (x: Double) (y: Double) (z: Double): Double</code><a class="headerlink" href="#function-def dfma (x: Double) (y: Double) (z: Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes x*y + z with rounding only at the end.
The fused-multiply-add operation is useful in numeric algorithms.
It is necessary in order compute values with full precision.
dfma 2.0 3.0 1.0 = 7.0
dfma 1.0 1.0 1.0 = 3.0</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double,</span>&#160; <span class="pre">y:</span> <span class="pre">Double,</span>&#160; <span class="pre">z:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def droot (n: Double): Double">
<code class="descname">def droot (n: Double): Double</code><a class="headerlink" href="#function-def droot (n: Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the n-th root.
droot 2.0 9.0  = 3.0
droot 3.0 27.0 = 3.0
droot 3.0 (-. 27.0) = nan</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">n:</span> <span class="pre">Double,</span>&#160; <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def √ (x: Double): Double">
<code class="descname">def √ (x: Double): Double</code><a class="headerlink" href="#function-def √ (x: Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Unary operator for square root, using the unicode character.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def ∛ (x: Double): Double">
<code class="descname">def ∛ (x: Double): Double</code><a class="headerlink" href="#function-def ∛ (x: Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Unary operator for cube root.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def ∜ (x: Double): Double">
<code class="descname">def ∜ (x: Double): Double</code><a class="headerlink" href="#function-def ∜ (x: Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Unary operator for fourth root.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def dcmp (x: Double) (y: Double): Option Order">
<code class="descname">def dcmp (x: Double) (y: Double): Option Order</code><a class="headerlink" href="#function-def dcmp (x: Double) (y: Double): Option Order" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two Double values.
NaN values cannot be compared, so return None
nan &lt;=&gt;. 4.5 = None
4.5 &lt;=&gt;. nan = None
nan &lt;=&gt;. nan = None
4.5 &lt;=&gt;. 4.5 = Some EQ
4.5 &lt;=&gt;. 5.0 = Some LT
4.0 &lt;=&gt;. 4.5 = Some GT</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double,</span>&#160; <span class="pre">y:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">Order</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: Double) &lt;=&gt;. (y: Double): Option Order">
<code class="descname">def (x: Double) &lt;=&gt;. (y: Double): Option Order</code><a class="headerlink" href="#function-def (x: Double) <=>. (y: Double): Option Order" title="Permalink to this definition">¶</a></dt>
<dd><p>Comparison of two Doubles.
NaN values cannot be compared, so return None
nan &lt;=&gt;. 4.5 = None
4.5 &lt;=&gt;. nan = None
nan &lt;=&gt;. nan = None
4.5 &lt;=&gt;. 4.5 = Some EQ
4.5 &lt;=&gt;. 5.0 = Some LT
4.0 &lt;=&gt;. 4.5 = Some GT</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double,</span>&#160; <span class="pre">y:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">Order</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: Double) &lt;. (y: Double): Boolean">
<code class="descname">def (x: Double) &lt;. (y: Double): Boolean</code><a class="headerlink" href="#function-def (x: Double) <. (y: Double): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary Less-Than Operator.
IEEE 754 requires comparison with NaN to return False
nan &lt;. nan = False
nan &lt;. 1.0 = False
1.0 &lt;. nan = False
1.0 &lt;. 1.0 = False
1.0 &lt;. 0.0 = False
1.0 &lt;. 2.0 = True</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double,</span>&#160; <span class="pre">y:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: Double) &gt;. (y: Double): Boolean">
<code class="descname">def (x: Double) &gt;. (y: Double): Boolean</code><a class="headerlink" href="#function-def (x: Double) >. (y: Double): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary Greater-Than Operator.
IEEE 754 requires comparison with NaN to return False
nan &gt;. nan = False
nan &gt;. 1.0 = False
1.0 &gt;. nan = False
1.0 &gt;. 1.0 = False
1.0 &gt;. 0.0 = True
1.0 &gt;. 2.0 = False</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double,</span>&#160; <span class="pre">y:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: Double) &gt;=. (y: Double): Boolean">
<code class="descname">def (x: Double) &gt;=. (y: Double): Boolean</code><a class="headerlink" href="#function-def (x: Double) >=. (y: Double): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary Greater-Or-Equal Operator.
IEEE 754 requires comparison with NaN to return False
nan &gt;=. nan = False
nan &gt;=. 1.0 = False
1.0 &gt;=. nan = False
1.0 &gt;=. 1.0 = True
1.0 &gt;=. 0.0 = True
1.0 &gt;=. 2.0 = False</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double,</span>&#160; <span class="pre">y:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: Double) &lt;=. (y: Double): Boolean">
<code class="descname">def (x: Double) &lt;=. (y: Double): Boolean</code><a class="headerlink" href="#function-def (x: Double) <=. (y: Double): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary Less-Or-Equal Operator.
IEEE 754 requires comparison with NaN to return False
nan &lt;=. nan = False
nan &lt;=. 1.0 = False
1.0 &lt;=. nan = False
1.0 &lt;=. 1.0 = True
1.0 &lt;=. 0.0 = False
1.0 &lt;=. 2.0 = True</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double,</span>&#160; <span class="pre">y:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: Double)">
<code class="descname">def (x: Double)</code><a class="headerlink" href="#function-def (x: Double)" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary Equal-To Operator.
IEEE 754 requires comparison with NaN to return False
nan ==. nan = False
nan ==. 1.0 = False
1.0 ==. nan = False
1.0 ==. 1.0 = True
1.0 ==. 0.0 = False
1.0 ==. 2.0 = False</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double,</span>&#160; <span class="pre">y:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (x: Double) !=. (y: Double): Boolean">
<code class="descname">def (x: Double) !=. (y: Double): Boolean</code><a class="headerlink" href="#function-def (x: Double) !=. (y: Double): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary Not-Equal Operator.
IEEE 754 requires comparison with NaN to return True
nan !=. nan = True
nan !=. 1.0 = True
1.0 !=. nan = True
1.0 !=. 1.0 = False
1.0 !=. 0.0 = True
1.0 !=. 2.0 = True</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double,</span>&#160; <span class="pre">y:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def dmin (x: Double) (y: Double): Double">
<code class="descname">def dmin (x: Double) (y: Double): Double</code><a class="headerlink" href="#function-def dmin (x: Double) (y: Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the minimum of two Double values.
If either is nan, the result is nan.
dmin nan nan = nan
dmin nan 1.0 = nan
dmin 1.0 nan = nan
dmin 1.0 3.0 = 1.0
dmin 3.0 1.0 = 1.0</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double,</span>&#160; <span class="pre">y:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def dmax (x: Double) (y: Double): Double">
<code class="descname">def dmax (x: Double) (y: Double): Double</code><a class="headerlink" href="#function-def dmax (x: Double) (y: Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the maximum of two Doubles.
If either is nan, the result is nan
dmax nan nan = nan
dmax nan 1.0 = nan
dmax 1.0 nan = nan
dmax 1.0 3.0 = 3.0
dmax 3.0 1.0 = 3.0</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double,</span>&#160; <span class="pre">y:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def ∏. (l: List Double): Double">
<code class="descname">def ∏. (l: List Double): Double</code><a class="headerlink" href="#function-def ∏. (l: List Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">l:</span> <span class="pre">List</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def ∑. (l: List Double): Double">
<code class="descname">def ∑. (l: List Double): Double</code><a class="headerlink" href="#function-def ∑. (l: List Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">l:</span> <span class="pre">List</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def dformat (format: DoubleFormat): (digits: Integer)">
<code class="descname">def dformat (format: DoubleFormat): (digits: Integer)</code><a class="headerlink" href="#function-def dformat (format: DoubleFormat): (digits: Integer)" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a Double as a String; for digits=3:
DoubleFixed       1000.000   1.000       # exactly 3 digits after the decimal
DoubleScientific  1.000e+03  1.000e+00   # exactly 3 digits after the decimal
DoubleHex         0x1.f40p+9 0x1.000p+0  # exactly 3 digits after the decimal
DoubleDefault     1e+03      1e0         # at 3 digits of precision</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">format:</span> <span class="pre">DoubleFormat,</span>&#160; <span class="pre">p:</span> <span class="pre">Integer,</span>&#160; <span class="pre">x:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">String</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def double (doubleInString: String): Option Double">
<code class="descname">def double (doubleInString: String): Option Double</code><a class="headerlink" href="#function-def double (doubleInString: String): Option Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a String into a Double
Can parse any Double formatted by dformat.
If the value could not be processed; returns None
double “1.0” = Some 1e0
double “xyz” = None</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">doubleInString:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def dint (x: Integer): Double">
<code class="descname">def dint (x: Integer): Double</code><a class="headerlink" href="#function-def dint (x: Integer): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an Integer into a Double
dint 55 = 55e0
dint (1 &lt;&lt; 2000) = inf</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def dclass (x: Double): DoubleClass">
<code class="descname">def dclass (x: Double): DoubleClass</code><a class="headerlink" href="#function-def dclass (x: Double): DoubleClass" title="Permalink to this definition">¶</a></dt>
<dd><p>Categorize a Double based on the type of number
dclass inf = DoubleInfinite
dclass nan = DoubleNaN
dclass 1.0 = DoubleNormal
dclass 1.0e-322 = DoubleSubNormal</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">DoubleClass</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def dfrexp (x: Double): Pair Double Integer">
<code class="descname">def dfrexp (x: Double): Pair Double Integer</code><a class="headerlink" href="#function-def dfrexp (x: Double): Pair Double Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Split ‘x’ into (Pair sig exp), such that:
x = sig * 2^exp
0.5 &lt;= sig &lt; 1.0</p>
<p>dfrexp 1.0 = Pair 0.5  1
dfrexp 2.0 = Pair 0.5  2
dfrexp 4.0 = Pair 0.5  3
dfrexp 3.0 = Pair 0.75 2</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Pair</span> <span class="pre">Double</span> <span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def dldexp (fraction: Double) (exponent: Integer): Double">
<code class="descname">def dldexp (fraction: Double) (exponent: Integer): Double</code><a class="headerlink" href="#function-def dldexp (fraction: Double) (exponent: Integer): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse the effects of dfrexp</p>
<p>dldexp 0.5  1 = 1.0
dldexp 0.5  2 = 2.0
dldexp 0.5  3 = 4.0
dldexp 0.75 2 = 3.0</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">fraction:</span> <span class="pre">Double,</span>&#160; <span class="pre">exponent:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def dmodf (x: Double): Pair Integer Double">
<code class="descname">def dmodf (x: Double): Pair Integer Double</code><a class="headerlink" href="#function-def dmodf (x: Double): Pair Integer Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Split ‘x’ into (Pair int fraction), such that:
x = int + fraction
-1 &lt; fraction &lt; 1
sign(fraction) = sign(x)</p>
<p>dmodf 5.0 = Pair 5 0.0
dmodf 5.1 = Pair 5 0.1
dmodf (-.5.1) = Pair -5 -0.1</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Pair</span> <span class="pre">Integer</span> <span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def dcos (radians: Double): Double">
<code class="descname">def dcos (radians: Double): Double</code><a class="headerlink" href="#function-def dcos (radians: Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the cosine of a Double.
dcos nan       =   nan
dcos 0.0       =   1.0
dcos (pi/.2.0) =   0.0
dcos pi        = -.1.0</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">radians:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def dsin (radians: Double): Double">
<code class="descname">def dsin (radians: Double): Double</code><a class="headerlink" href="#function-def dsin (radians: Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the sine of a Double.
dsin nan       = nan
dsin 0.0       = 0.0
dsin (pi/.2.0) = 1.0
dins pi        = 0.0</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">radians:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def dtan (radians: Double): Double">
<code class="descname">def dtan (radians: Double): Double</code><a class="headerlink" href="#function-def dtan (radians: Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the tangent of a Double.
dtan (-.pi/.2.0) = -inf
dtan 0.0         =  0.0
dtan (  pi/.2.0) = +inf</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">radians:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def dacos (x: Double): Double">
<code class="descname">def dacos (x: Double): Double</code><a class="headerlink" href="#function-def dacos (x: Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the inverse cosine of a Double.
dacos (-.1.0) = pi
dacos 0.0     = pi /. 2.0
dacos 1.0     = 0.0
dacos 2.0     = nan</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def dasin (x: Double): Double">
<code class="descname">def dasin (x: Double): Double</code><a class="headerlink" href="#function-def dasin (x: Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the inverse sine of a Double.
dasin (-.1.0) = -.(pi/2.0)
dasin 0.0     = 0.0
dasin 1.0     = pi/2.0</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def datan (x: Double) (y: Double): Double">
<code class="descname">def datan (x: Double) (y: Double): Double</code><a class="headerlink" href="#function-def datan (x: Double) (y: Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the inverse tangent of y/x, giving the angle of the point(x, y) in the coordinate plane.
The advantage of 2-argument datan over 1-argument datan is it is defined even where x is 0.
datan (-. 1.0) (-. 1.0) = pi * -0.75
datan (-. 1.0)     0.0  = pi * -0.50
datan (-. 1.0)     1.0  = pi * -0.25
datan     0.0      1.0  = pi *  0.00
datan     1.0      1.0  = pi *  0.25
datan     1.0      0.0  = pi *  0.50
datan     1.0  (-. 1.0) = pi *  0.75
datan     0.0  (-. 1.0) = pi *  1.00</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double,</span>&#160; <span class="pre">y:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def dexp (x: Double): Double">
<code class="descname">def dexp (x: Double): Double</code><a class="headerlink" href="#function-def dexp (x: Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates e^x.
dexp 0.0 = 1.0
dexp 1.0 = 2.71828
dexp (-.inf) = 0.0</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def dlog (x: Double): Double">
<code class="descname">def dlog (x: Double): Double</code><a class="headerlink" href="#function-def dlog (x: Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the natural logarithm of x.
dlog (dexp x) = x
dlog (-. 1.0) = nan</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def dexpm1 (x: Double): Double">
<code class="descname">def dexpm1 (x: Double): Double</code><a class="headerlink" href="#function-def dexpm1 (x: Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates e^.x -. 1.0
Useful for values of ‘x’ close to 0.0
dexpm1 (-.0.2) = -.0.18
dexpm1 0.0     = 0.0
dexpm1 0.2     = 0.22</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def dlog1p  (x: Double): Double">
<code class="descname">def dlog1p  (x: Double): Double</code><a class="headerlink" href="#function-def dlog1p  (x: Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates dlog (1.0 +. x)
dlog1p (dexpm1 x) = x
Useful for values of ‘x’ close to 0.0
dlog1p (-.0.2) = -.0.22
dlog1p 0.0     = 0.0
dlog1p 0.2     = 0.18</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def derf (x: Double): Double">
<code class="descname">def derf (x: Double): Double</code><a class="headerlink" href="#function-def derf (x: Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the ‘error function’.
2/sqrt(pi) Integral_{0..x} e^(-t^2) dt
This function is handy for statistics</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def derfc (x: Double): Double">
<code class="descname">def derfc (x: Double): Double</code><a class="headerlink" href="#function-def derfc (x: Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the complementary ‘error function’ (1-erf).
2/sqrt(pi) Integral_{0..x} e^(-t^2) dt
This function is handy for statistics</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def dtgamma (x: Double): Double">
<code class="descname">def dtgamma (x: Double): Double</code><a class="headerlink" href="#function-def dtgamma (x: Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the gamma function; Integral_{0..inf} t^{x-1} e^t dt
This is an everywhere-defined factorial method; dtgamma (x+1) = x!</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def dlgamma (x: Double): Double">
<code class="descname">def dlgamma (x: Double): Double</code><a class="headerlink" href="#function-def dlgamma (x: Double): Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the logarithm of the gamma function
This is useful to approximate statistics like (n choose m)</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Double</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Double</span></code></p>
</dd></dl>

</div>
<div class="section" id="map-wake">
<h2>map.wake<a class="headerlink" href="#map-wake" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="function-def mnew (cmpKey: k">
<code class="descname">def mnew (cmpKey: k</code><a class="headerlink" href="#function-def mnew (cmpKey: k" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize an empty <cite>Map</cite> which will use the given total order function.</p>
<p><em>Parameters:</em>
* <cite>cmpKey</cite>:
A function providing a total ordering over values of the key type.</p>
<p><em>Example:</em>
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">mnew</span> <span class="pre">scmp</span> <span class="pre">|</span> <span class="pre">msize</span> <span class="pre">=</span> <span class="pre">0</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">cmpKey:</span> <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">Order</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def listToMap (cmpKey: k">
<code class="descname">def listToMap (cmpKey: k</code><a class="headerlink" href="#function-def listToMap (cmpKey: k" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <cite>Map</cite> from the pre-associated key-value pairs in the <cite>List</cite>.
If multiple <cite>Pair`s have the same left value (key), then the resulting `Map</cite>
will contain the right value of only the <em>first</em> occurrence.</p>
<p><em>Parameters:</em>
* <cite>cmpKey</cite>:
A function providing a total ordering over values of the key type.
* <cite>pairs</cite>:
The keys and values which the <cite>Map</cite> should contain.  This does not have
to be sorted, but each left-hand value should be unique.</p>
<p><em>Examples:</em>
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">True,</span> <span class="pre">&quot;b&quot;</span> <span class="pre">→</span> <span class="pre">False,</span> <span class="pre">&quot;c&quot;</span> <span class="pre">→</span> <span class="pre">False,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">msize</span> <span class="pre">=</span> <span class="pre">3</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">2,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">mlookup</span> <span class="pre">&quot;a&quot;</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">1</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">cmpKey:</span> <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">Order,</span>&#160; <span class="pre">pairs:</span> <span class="pre">List</span> <span class="pre">Pair</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vectorToMap (cmpKey: k">
<code class="descname">def vectorToMap (cmpKey: k</code><a class="headerlink" href="#function-def vectorToMap (cmpKey: k" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <cite>Map</cite> from the pre-associated key-value pairs in the <cite>Vector</cite>.
If multiple <cite>Pair`s have the same left value (key), then the resulting `Map</cite>
will contain the right value of only the <em>first</em> occurrence.</p>
<p><em>Parameters:</em>
* <cite>cmpKey</cite>:
A function providing a total ordering over values of the key type.
* <cite>pairs</cite>:
The keys and values which the <cite>Map</cite> should contain.  This does not have
to be sorted, but each left-hand value should be unique.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">cmpKey:</span> <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">Order,</span>&#160; <span class="pre">pairs:</span> <span class="pre">Vector</span> <span class="pre">Pair</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def msize (map: Map k v): Integer">
<code class="descname">def msize (map: Map k v): Integer</code><a class="headerlink" href="#function-def msize (map: Map k v): Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Count how many key-value associations are contained in the <cite>Map</cite>.</p>
<p><em>Examples:</em>
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">mnew</span> <span class="pre">scmp</span> <span class="pre">|</span> <span class="pre">msize</span> <span class="pre">=</span> <span class="pre">0</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">True,</span> <span class="pre">&quot;b&quot;</span> <span class="pre">→</span> <span class="pre">False,</span> <span class="pre">&quot;c&quot;</span> <span class="pre">→</span> <span class="pre">False,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">msize</span> <span class="pre">=</span> <span class="pre">3</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">map:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def mempty (map: Map k v): Boolean">
<code class="descname">def mempty (map: Map k v): Boolean</code><a class="headerlink" href="#function-def mempty (map: Map k v): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the <cite>Map</cite> does not contain any elements.</p>
<p><em>Examples:</em>
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">mnew</span> <span class="pre">scmp</span> <span class="pre">|</span> <span class="pre">mempty</span> <span class="pre">=</span> <span class="pre">True</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">True,</span> <span class="pre">&quot;b&quot;</span> <span class="pre">→</span> <span class="pre">False,</span> <span class="pre">&quot;c&quot;</span> <span class="pre">→</span> <span class="pre">False,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">mempty</span> <span class="pre">=</span> <span class="pre">False</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">map:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def minsert (key: k) (value: v) (map: Map k v): Map k v">
<code class="descname">def minsert (key: k) (value: v) (map: Map k v): Map k v</code><a class="headerlink" href="#function-def minsert (key: k) (value: v) (map: Map k v): Map k v" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a given value into the map under the key, if that key does not already exist.
Any pair with the same key which already exists in the map <em>remains unchanged</em>.</p>
<p>For a similar function which uses the new value provided, see <cite>minsertReplace</cite>
or <cite>minsertWith</cite>.</p>
<p><em>Examples:</em>
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">mnew</span> <span class="pre">scmp</span> <span class="pre">|</span> <span class="pre">minsert</span> <span class="pre">&quot;a&quot;</span> <span class="pre">2</span> <span class="pre">|</span> <span class="pre">mlookup</span> <span class="pre">&quot;a&quot;</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">2</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">minsert</span> <span class="pre">&quot;a&quot;</span> <span class="pre">2</span> <span class="pre">|</span> <span class="pre">mlookup</span> <span class="pre">&quot;a&quot;</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">1</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">key:</span> <span class="pre">a,</span>&#160; <span class="pre">value:</span> <span class="pre">b,</span>&#160; <span class="pre">map:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def minsertReplace (key: k) (value: v) (map: Map k v): Map k v">
<code class="descname">def minsertReplace (key: k) (value: v) (map: Map k v): Map k v</code><a class="headerlink" href="#function-def minsertReplace (key: k) (value: v) (map: Map k v): Map k v" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a given value into the map under the key, whether or not it already exists.</p>
<p>For a similar function which preserves the original value contained in the
map, see <cite>minsert</cite> or <cite>minsertWith</cite>.</p>
<p><em>Examples:</em>
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">mnew</span> <span class="pre">scmp</span> <span class="pre">|</span> <span class="pre">minsertReplace</span> <span class="pre">&quot;a&quot;</span> <span class="pre">2</span> <span class="pre">|</span> <span class="pre">mlookup</span> <span class="pre">&quot;a&quot;</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">2</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">minsertReplace</span> <span class="pre">&quot;a&quot;</span> <span class="pre">2</span> <span class="pre">|</span> <span class="pre">mlookup</span> <span class="pre">&quot;a&quot;</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">2</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">key:</span> <span class="pre">a,</span>&#160; <span class="pre">value:</span> <span class="pre">b,</span>&#160; <span class="pre">map:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def minsertWith (fn: k">
<code class="descname">def minsertWith (fn: k</code><a class="headerlink" href="#function-def minsertWith (fn: k" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a given value into the map under the key, resolving conflicts as specified.</p>
<p>If just replacing or keeping the original, consider using <cite>minsert</cite> or
<cite>minsertReplace</cite> instead. Prefer <cite>minsertWith</cite> when accumulating values over
multiple inserts.</p>
<p><em>Examples:</em>
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">mnew</span> <span class="pre">scmp</span> <span class="pre">|</span> <span class="pre">minsertWith</span> <span class="pre">(\_k</span> <span class="pre">(_+_))</span> <span class="pre">&quot;a&quot;</span> <span class="pre">2</span> <span class="pre">|</span> <span class="pre">mlookup</span> <span class="pre">&quot;a&quot;</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">2</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">minsertWith</span> <span class="pre">(\_k</span> <span class="pre">(_+_))</span> <span class="pre">&quot;a&quot;</span> <span class="pre">2</span> <span class="pre">|</span> <span class="pre">mlookup</span> <span class="pre">&quot;a&quot;</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">3</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">fn:</span> <span class="pre">a,</span>&#160; <span class="pre">incoming:</span> <span class="pre">b,</span>&#160; <span class="pre">existing:</span> <span class="pre">b,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">key:</span> <span class="pre">a,</span>&#160; <span class="pre">value:</span> <span class="pre">b,</span>&#160; <span class="pre">map:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def mdelete (key: k) (map: Map k v): Map k v">
<code class="descname">def mdelete (key: k) (map: Map k v): Map k v</code><a class="headerlink" href="#function-def mdelete (key: k) (map: Map k v): Map k v" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove any value contained in the map under the given key.</p>
<p><em>Examples:</em>
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">&quot;b&quot;</span> <span class="pre">→</span> <span class="pre">2,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">mdelete</span> <span class="pre">&quot;b&quot;</span> <span class="pre">|</span> <span class="pre">mlookup</span> <span class="pre">&quot;b&quot;</span> <span class="pre">=</span> <span class="pre">None</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">&quot;b&quot;</span> <span class="pre">→</span> <span class="pre">2,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">mdelete</span> <span class="pre">&quot;x&quot;</span> <span class="pre">|</span> <span class="pre">msize</span> <span class="pre">=</span> <span class="pre">2</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">key:</span> <span class="pre">a,</span>&#160; <span class="pre">map:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def mfoldl (fn: k">
<code class="descname">def mfoldl (fn: k</code><a class="headerlink" href="#function-def mfoldl (fn: k" title="Permalink to this definition">¶</a></dt>
<dd><p>Accumulate and combine every value in the map, starting from the “smallest” key.</p>
<p><em>Parameters:</em>
* <cite>fn</cite>:
The manner in which each value should be added to the accumulator.
* <cite>base</cite>:
The value used to initialize the accumulator.  If <cite>map</cite> is empty, this
value is returned unchanged.
* <cite>map</cite>:
The key-value pairs which will be combined.</p>
<p><em>Examples:</em>
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">mnew</span> <span class="pre">scmp</span> <span class="pre">|</span> <span class="pre">mfoldl</span> <span class="pre">(\_\a\v</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">v)</span> <span class="pre">0</span> <span class="pre">=</span> <span class="pre">0</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">&quot;b&quot;</span> <span class="pre">→</span> <span class="pre">2,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">mfoldl</span> <span class="pre">(\_\a\v</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">v)</span> <span class="pre">0</span> <span class="pre">=</span> <span class="pre">3</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">&quot;b&quot;</span> <span class="pre">→</span> <span class="pre">2,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">mfoldl</span> <span class="pre">(\k\a\v</span> <span class="pre">&quot;{a}</span> <span class="pre">{k}={str</span> <span class="pre">v}&quot;)</span> <span class="pre">&quot;k=v:&quot;</span> <span class="pre">=</span> <span class="pre">&quot;k=v:</span> <span class="pre">a=1</span> <span class="pre">b=2&quot;</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">fn:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">c,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">base:</span> <span class="pre">b,</span>&#160; <span class="pre">map:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">c</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def mfoldr (fn: k">
<code class="descname">def mfoldr (fn: k</code><a class="headerlink" href="#function-def mfoldr (fn: k" title="Permalink to this definition">¶</a></dt>
<dd><p>Accumulate and combine every value in the map, starting from the “largest” key.</p>
<p><em>Parameters:</em>
* <cite>fn</cite>:
The manner in which each value should be added to the accumulator.
* <cite>base</cite>:
The value used to initialize the accumulator.  If <cite>map</cite> is empty, this
value is returned unchanged.
* <cite>map</cite>:
The key-value pairs which will be combined.</p>
<p><em>Examples:</em>
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">mnew</span> <span class="pre">scmp</span> <span class="pre">|</span> <span class="pre">mfoldr</span> <span class="pre">(\_\v\a</span> <span class="pre">v</span> <span class="pre">+</span> <span class="pre">a)</span> <span class="pre">0</span> <span class="pre">=</span> <span class="pre">0</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">&quot;b&quot;</span> <span class="pre">→</span> <span class="pre">2,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">mfoldr</span> <span class="pre">(\_\v\a</span> <span class="pre">v</span> <span class="pre">+</span> <span class="pre">a)</span> <span class="pre">0</span> <span class="pre">=</span> <span class="pre">3</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">&quot;b&quot;</span> <span class="pre">→</span> <span class="pre">2,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">mfoldr</span> <span class="pre">(\k\v\a</span> <span class="pre">&quot;{a}</span> <span class="pre">{k}={str</span> <span class="pre">v}&quot;)</span> <span class="pre">&quot;k=v:&quot;</span> <span class="pre">=</span> <span class="pre">&quot;k=v:</span> <span class="pre">b=2</span> <span class="pre">a=1&quot;</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">fn:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">c,</span>&#160; <span class="pre">c,</span>&#160; <span class="pre">base:</span> <span class="pre">c,</span>&#160; <span class="pre">map:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">c</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def mfoldmap (combineFn: a">
<code class="descname">def mfoldmap (combineFn: a</code><a class="headerlink" href="#function-def mfoldmap (combineFn: a" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform and combine every value in the map in parallel.</p>
<p><em>Parameters:</em>
* <cite>combineFn</cite>:
The manner in which two values of the target type should be joined.
* <cite>base</cite>:
The value used to initialize the accumulator.  If <cite>map</cite> is empty, this
value is returned unchanged.
* <cite>transformFn</cite>:
The function which should be applied to every key-value pair in the map.
This might just be to prepare them to be combined, or it might be some
more complex function which happens to have a more-easily-joined output.
* <cite>map</cite>:
The key-value pairs which will be processed.</p>
<p><em>Examples:</em>
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">mnew</span> <span class="pre">scmp</span> <span class="pre">|</span> <span class="pre">mfoldmap</span> <span class="pre">(_+_)</span> <span class="pre">0</span> <span class="pre">(\_\v</span> <span class="pre">v)</span> <span class="pre">=</span> <span class="pre">0</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">&quot;b&quot;</span> <span class="pre">→</span> <span class="pre">2,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">mfoldmap</span> <span class="pre">(_+_)</span> <span class="pre">0</span> <span class="pre">(\_\v</span> <span class="pre">v)</span> <span class="pre">=</span> <span class="pre">3</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">&quot;b&quot;</span> <span class="pre">→</span> <span class="pre">2,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">mfoldmap</span> <span class="pre">(&quot;{_}</span> <span class="pre">{_}&quot;)</span> <span class="pre">&quot;k=v:&quot;</span> <span class="pre">(&quot;{_}={str</span> <span class="pre">_}&quot;)</span> <span class="pre">=</span> <span class="pre">&quot;k=v:</span> <span class="pre">a=1</span> <span class="pre">b=2&quot;</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">combineFn:</span> <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">base:</span> <span class="pre">a,</span>&#160; <span class="pre">transformFn:</span> <span class="pre">b,</span>&#160; <span class="pre">c,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">map:</span> <span class="pre">Map</span> <span class="pre">b</span> <span class="pre">c</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def mapToList (map: Map k v): List (Pair k v)">
<code class="descname">def mapToList (map: Map k v): List (Pair k v)</code><a class="headerlink" href="#function-def mapToList (map: Map k v): List (Pair k v)" title="Permalink to this definition">¶</a></dt>
<dd><p>Flatten every key-value pair in the map into a simple list.</p>
<p><em>Examples:</em>
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">mnew</span> <span class="pre">scmp</span> <span class="pre">|</span> <span class="pre">mapToList</span> <span class="pre">=</span> <span class="pre">Nil</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">minsert</span> <span class="pre">&quot;b&quot;</span> <span class="pre">2</span> <span class="pre">|</span> <span class="pre">mapToList</span> <span class="pre">=</span> <span class="pre">Pair</span> <span class="pre">&quot;a&quot;</span> <span class="pre">1,</span> <span class="pre">Pair</span> <span class="pre">&quot;b&quot;</span> <span class="pre">2,</span> <span class="pre">Nil</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">map:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">(Pair</span> <span class="pre">a</span> <span class="pre">b)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def mmap (fn: k">
<code class="descname">def mmap (fn: k</code><a class="headerlink" href="#function-def mmap (fn: k" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply some function to every value contained in the map.</p>
<p><em>Examples:</em>
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">&quot;b&quot;</span> <span class="pre">→</span> <span class="pre">2,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">mmap</span> <span class="pre">(\_\v</span> <span class="pre">v</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">|</span> <span class="pre">mlookup</span> <span class="pre">&quot;b&quot;</span> <span class="pre">=</span> <span class="pre">3</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">&quot;b&quot;</span> <span class="pre">→</span> <span class="pre">2,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">mmap</span> <span class="pre">(\k\v</span> <span class="pre">&quot;{k}={str</span> <span class="pre">v}&quot;)</span> <span class="pre">|</span> <span class="pre">mlookup</span> <span class="pre">&quot;b&quot;</span> <span class="pre">=</span> <span class="pre">&quot;b=2&quot;</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">fn:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">c,</span>&#160; <span class="pre">map:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">a</span> <span class="pre">c</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def mmapPass (fn: k">
<code class="descname">def mmapPass (fn: k</code><a class="headerlink" href="#function-def mmapPass (fn: k" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply some failable function to every value, passing only if every computation does.</p>
<p><em>Example:</em>
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">&quot;1&quot;,</span> <span class="pre">&quot;b&quot;</span> <span class="pre">→</span> <span class="pre">&quot;2&quot;,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">mmapPass</span> <span class="pre">(int</span> <span class="pre">_</span> <span class="pre">|</span> <span class="pre">getOrFail</span> <span class="pre">&quot;&quot;)</span> <span class="pre">=</span> <span class="pre">Pass</span> <span class="pre">...</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">fn:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">Result</span> <span class="pre">c</span> <span class="pre">d,</span>&#160; <span class="pre">map:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Result</span> <span class="pre">(Map</span> <span class="pre">a</span> <span class="pre">c)</span> <span class="pre">d</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def mmin (map: Map k v): Option (Pair k v)">
<code class="descname">def mmin (map: Map k v): Option (Pair k v)</code><a class="headerlink" href="#function-def mmin (map: Map k v): Option (Pair k v)" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the “smallest” key from the map and its associated value.
This is determined according to the comparison function specified when the map
was originally created.</p>
<p><em>Examples:</em>
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">mnew</span> <span class="pre">scmp</span> <span class="pre">|</span> <span class="pre">mmin</span> <span class="pre">=</span> <span class="pre">None</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">&quot;b&quot;</span> <span class="pre">→</span> <span class="pre">2,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">mmin</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">(Pair</span> <span class="pre">&quot;a&quot;</span> <span class="pre">1)</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">map:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">(Pair</span> <span class="pre">a</span> <span class="pre">b)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def mmax (map: Map k v): Option (Pair k v)">
<code class="descname">def mmax (map: Map k v): Option (Pair k v)</code><a class="headerlink" href="#function-def mmax (map: Map k v): Option (Pair k v)" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the “largest” key from the map and its associated value.
This is determined according to the comparison function specified when the map
was originally created.</p>
<p><em>Examples:</em>
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">mnew</span> <span class="pre">scmp</span> <span class="pre">|</span> <span class="pre">mmax</span> <span class="pre">=</span> <span class="pre">None</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">&quot;b&quot;</span> <span class="pre">→</span> <span class="pre">2,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">mmax</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">(Pair</span> <span class="pre">&quot;b&quot;</span> <span class="pre">2)</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">map:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">(Pair</span> <span class="pre">a</span> <span class="pre">b)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def mlowerGE (key: k) (map: Map k v): Option (Pair k v)">
<code class="descname">def mlowerGE (key: k) (map: Map k v): Option (Pair k v)</code><a class="headerlink" href="#function-def mlowerGE (key: k) (map: Map k v): Option (Pair k v)" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the “smallest” key from the map that is equal to or “larger than” a known point.
This is determined according to the comparison function specified when the map
was originally created.</p>
<p><em>Examples:</em>
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">mnew</span> <span class="pre">scmp</span> <span class="pre">|</span> <span class="pre">mmax</span> <span class="pre">=</span> <span class="pre">None</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">&quot;b&quot;</span> <span class="pre">→</span> <span class="pre">2,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">mlowerGE</span> <span class="pre">&quot;a&quot;</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">(Pair</span> <span class="pre">&quot;a&quot;</span> <span class="pre">1)</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">&quot;b&quot;</span> <span class="pre">→</span> <span class="pre">2,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">mlowerGE</span> <span class="pre">&quot;aaa&quot;</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">(Pair</span> <span class="pre">&quot;b&quot;</span> <span class="pre">2)</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">key:</span> <span class="pre">a,</span>&#160; <span class="pre">map:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">(Pair</span> <span class="pre">a</span> <span class="pre">b)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def mlowerGT (key: k) (map: Map k v): Option (Pair k v)">
<code class="descname">def mlowerGT (key: k) (map: Map k v): Option (Pair k v)</code><a class="headerlink" href="#function-def mlowerGT (key: k) (map: Map k v): Option (Pair k v)" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the “smallest” key from the map that is strictly “larger than” a known point.
This is determined according to the comparison function specified when the map
was originally created.</p>
<p><em>Examples:</em>
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">mnew</span> <span class="pre">scmp</span> <span class="pre">|</span> <span class="pre">mmax</span> <span class="pre">=</span> <span class="pre">None</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">&quot;b&quot;</span> <span class="pre">→</span> <span class="pre">2,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">mlowerGT</span> <span class="pre">&quot;a&quot;</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">(Pair</span> <span class="pre">&quot;b&quot;</span> <span class="pre">2)</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">&quot;b&quot;</span> <span class="pre">→</span> <span class="pre">2,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">mlowerGT</span> <span class="pre">&quot;aaa&quot;</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">(Pair</span> <span class="pre">&quot;b&quot;</span> <span class="pre">2)</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">key:</span> <span class="pre">a,</span>&#160; <span class="pre">map:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">(Pair</span> <span class="pre">a</span> <span class="pre">b)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def mupperLT (key: k) (map: Map k v): Option (Pair k v)">
<code class="descname">def mupperLT (key: k) (map: Map k v): Option (Pair k v)</code><a class="headerlink" href="#function-def mupperLT (key: k) (map: Map k v): Option (Pair k v)" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the “largest” key from the map that is strictly “smaller than” a known point.
This is determined according to the comparison function specified when the map
was originally created.</p>
<p><em>Examples:</em>
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">mnew</span> <span class="pre">scmp</span> <span class="pre">|</span> <span class="pre">mmax</span> <span class="pre">=</span> <span class="pre">None</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">&quot;b&quot;</span> <span class="pre">→</span> <span class="pre">2,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">mupperLT</span> <span class="pre">&quot;b&quot;</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">(Pair</span> <span class="pre">&quot;a&quot;</span> <span class="pre">1)</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">&quot;b&quot;</span> <span class="pre">→</span> <span class="pre">2,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">mupperLT</span> <span class="pre">&quot;aaa&quot;</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">(Pair</span> <span class="pre">&quot;a&quot;</span> <span class="pre">1)</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">key:</span> <span class="pre">a,</span>&#160; <span class="pre">map:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">(Pair</span> <span class="pre">a</span> <span class="pre">b)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def mupperLE (key: k) (map: Map k v): Option (Pair k v)">
<code class="descname">def mupperLE (key: k) (map: Map k v): Option (Pair k v)</code><a class="headerlink" href="#function-def mupperLE (key: k) (map: Map k v): Option (Pair k v)" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the “largest” key from the map that is equal to or “smaller than” a known point.
This is determined according to the comparison function specified when the map
was originally created.</p>
<p><em>Examples:</em>
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">mnew</span> <span class="pre">scmp</span> <span class="pre">|</span> <span class="pre">mmax</span> <span class="pre">=</span> <span class="pre">None</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">&quot;b&quot;</span> <span class="pre">→</span> <span class="pre">2,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">mupperLE</span> <span class="pre">&quot;b&quot;</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">(Pair</span> <span class="pre">&quot;b&quot;</span> <span class="pre">2)</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">&quot;b&quot;</span> <span class="pre">→</span> <span class="pre">2,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">mupperLE</span> <span class="pre">&quot;aaa&quot;</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">(Pair</span> <span class="pre">&quot;a&quot;</span> <span class="pre">1)</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">key:</span> <span class="pre">a,</span>&#160; <span class="pre">map:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">(Pair</span> <span class="pre">a</span> <span class="pre">b)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def mlookup (key: k) (map: Map k v): Option v">
<code class="descname">def mlookup (key: k) (map: Map k v): Option v</code><a class="headerlink" href="#function-def mlookup (key: k) (map: Map k v): Option v" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the value associated with a particular key in the map, if one exists.</p>
<p>If only the presence of the value matters, see <cite>mexists</cite>.</p>
<p><em>Examples:</em>
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">mnew</span> <span class="pre">scmp</span> <span class="pre">|</span> <span class="pre">mlookup</span> <span class="pre">&quot;a&quot;</span> <span class="pre">=</span> <span class="pre">None</span>
<span class="pre">mnew</span> <span class="pre">scmp</span> <span class="pre">|</span> <span class="pre">minsert</span> <span class="pre">&quot;a&quot;</span> <span class="pre">1</span> <span class="pre">|</span> <span class="pre">mlookup</span> <span class="pre">&quot;a&quot;</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">1</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">&quot;b&quot;</span> <span class="pre">→</span> <span class="pre">2,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">mdelete</span> <span class="pre">&quot;b&quot;</span> <span class="pre">|</span> <span class="pre">mlookup</span> <span class="pre">&quot;b&quot;</span> <span class="pre">=</span> <span class="pre">None</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">key:</span> <span class="pre">a,</span>&#160; <span class="pre">map:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def mcontains (key: k) (map: Map k v): Boolean">
<code class="descname">def mcontains (key: k) (map: Map k v): Boolean</code><a class="headerlink" href="#function-def mcontains (key: k) (map: Map k v): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether some key is associated with any value in the map.</p>
<p><em>Examples:</em>
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">mnew</span> <span class="pre">scmp</span> <span class="pre">|</span> <span class="pre">mcontains</span> <span class="pre">&quot;a&quot;</span> <span class="pre">=</span> <span class="pre">False</span>
<span class="pre">mnew</span> <span class="pre">scmp</span> <span class="pre">|</span> <span class="pre">minsert</span> <span class="pre">&quot;a&quot;</span> <span class="pre">1</span> <span class="pre">|</span> <span class="pre">mcontains</span> <span class="pre">&quot;a&quot;</span> <span class="pre">=</span> <span class="pre">True</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">&quot;b&quot;</span> <span class="pre">→</span> <span class="pre">2,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">mdelete</span> <span class="pre">&quot;b&quot;</span> <span class="pre">|</span> <span class="pre">mcontains</span> <span class="pre">&quot;b&quot;</span> <span class="pre">=</span> <span class="pre">False</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">key:</span> <span class="pre">a,</span>&#160; <span class="pre">map:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def mexists (fn: k">
<code class="descname">def mexists (fn: k</code><a class="headerlink" href="#function-def mexists (fn: k" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the predicate succeeds for any key-value pair in the map.</p>
<p><em>Examples:</em>
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">mnew</span> <span class="pre">scmp</span> <span class="pre">|</span> <span class="pre">mcexists</span> <span class="pre">&quot;a&quot;</span> <span class="pre">=</span> <span class="pre">False</span>
<span class="pre">mnew</span> <span class="pre">scmp</span> <span class="pre">|</span> <span class="pre">minsert</span> <span class="pre">&quot;a&quot;</span> <span class="pre">1</span> <span class="pre">|</span> <span class="pre">mexists</span> <span class="pre">&quot;a&quot;</span> <span class="pre">=</span> <span class="pre">True</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">&quot;b&quot;</span> <span class="pre">→</span> <span class="pre">2,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">mdelete</span> <span class="pre">&quot;b&quot;</span> <span class="pre">|</span> <span class="pre">mexists</span> <span class="pre">&quot;b&quot;</span> <span class="pre">=</span> <span class="pre">False</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">fn:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">map:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def msplitBy (fn: k">
<code class="descname">def msplitBy (fn: k</code><a class="headerlink" href="#function-def msplitBy (fn: k" title="Permalink to this definition">¶</a></dt>
<dd><p>Divide the key-value pairs comprising one map into two according to some predicate.</p>
<p><em>Returns:</em>
<cite>Pair trues falses</cite> where <cite>trues</cite> contains all the values for which <cite>fn</cite>
returned <cite>True</cite> and <cite>falses</cite> where it returned <cite>False</cite>.  Both resulting maps
use the same key-comparison function as the original <cite>map</cite>.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">fn:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">map:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Pair</span> <span class="pre">(Map</span> <span class="pre">a</span> <span class="pre">b)</span> <span class="pre">(Map</span> <span class="pre">a</span> <span class="pre">b)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def mfilter (fn: k">
<code class="descname">def mfilter (fn: k</code><a class="headerlink" href="#function-def mfilter (fn: k" title="Permalink to this definition">¶</a></dt>
<dd><p>Discard any key-value pairs in the map for which the predicate fails.</p>
<p><em>Examples:</em>
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">&quot;b&quot;</span> <span class="pre">→</span> <span class="pre">2,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">mfilter</span> <span class="pre">(\k\_</span> <span class="pre">isVowel</span> <span class="pre">k)</span> <span class="pre">|</span> <span class="pre">mlookup</span> <span class="pre">&quot;a&quot;</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">1</span>
<span class="pre">listToMap</span> <span class="pre">scmp</span> <span class="pre">(&quot;a&quot;</span> <span class="pre">→</span> <span class="pre">1,</span> <span class="pre">&quot;b&quot;</span> <span class="pre">→</span> <span class="pre">2,</span> <span class="pre">Nil)</span> <span class="pre">|</span> <span class="pre">mfilter</span> <span class="pre">(\k\_</span> <span class="pre">isVowel</span> <span class="pre">k)</span> <span class="pre">|</span> <span class="pre">mlookup</span> <span class="pre">&quot;b&quot;</span> <span class="pre">=</span> <span class="pre">None</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">fn:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">map:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def munion (left: Map k v) (right: Map k v): Map k v">
<code class="descname">def munion (left: Map k v) (right: Map k v): Map k v</code><a class="headerlink" href="#function-def munion (left: Map k v) (right: Map k v): Map k v" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect all key-value associations in either of two maps into a single one.
If the same key occurs in both, the value from <cite>left</cite> is kept and the one from
<cite>right</cite> is discarded.  However, if the key comparison function differs between
the two inputs, then the one from the <cite>right</cite> is used.</p>
<p>For a similar function which provides control over how to join values of keys
occurring in both maps, see <cite>munionWith</cite>.</p>
<p><em>Examples:</em>
<a href="#id19"><span class="problematic" id="id20">``</span></a>`
def left  = listToMap scmp (“a” → 1, “b” → 2, Nil)
def right = listToMap scmp (“b” → 11, “f” → 15, Nil)</p>
<p>munion left right | mlookup “a” = Some 1
munion left right | mlookup “b” = Some 2
munion left right | mlookup “f” = Some 15
<a href="#id21"><span class="problematic" id="id22">``</span></a><a href="#id23"><span class="problematic" id="id24">`</span></a></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">left:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b,</span>&#160; <span class="pre">right:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def munionWith (fn: k">
<code class="descname">def munionWith (fn: k</code><a class="headerlink" href="#function-def munionWith (fn: k" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect all key-value associations in maps, with the given conflict resolultion.
If the key comparison function differs between the two inputs, then the one
from the <cite>right</cite> is used.</p>
<p>If simply keeping the original in any conflicts, consider using <cite>munion</cite> instead.</p>
<p><em>Examples:</em>
<a href="#id25"><span class="problematic" id="id26">``</span></a>`
def left  = listToMap scmp (“a” → 1, “b” → 2, Nil)
def right = listToMap scmp (“b” → 11, “f” → 15, Nil)</p>
<p>munionWith (_lvrv lv + rv) left right | mlookup “a” = Some 1
munionWith (_lvrv lv + rv) left right | mlookup “b” = Some 13
munionWith (_lvrv lv + rv) left right | mlookup “f” = Some 15
<a href="#id27"><span class="problematic" id="id28">``</span></a><a href="#id29"><span class="problematic" id="id30">`</span></a></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">fn:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">left:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b,</span>&#160; <span class="pre">right:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def msubtract (left: Map k v) (right: Map k v): Map k v">
<code class="descname">def msubtract (left: Map k v) (right: Map k v): Map k v</code><a class="headerlink" href="#function-def msubtract (left: Map k v) (right: Map k v): Map k v" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all keys from the left map which occur (regardless of value) in the right.
If the key comparison function differs between the two inputs, then the one
from the <cite>right</cite> is used.</p>
<p><em>Examples:</em>
<a href="#id31"><span class="problematic" id="id32">``</span></a>`
def left  = listToMap scmp (“a” → 1, “b” → 2, Nil)
def right = listToMap scmp (“b” → 11, “f” → 15, Nil)</p>
<p>msubtract left right | mlookup “a” = Some 1
msubtract left right | mlookup “b” = None
msubtract left right | mlookup “f” = None
<a href="#id33"><span class="problematic" id="id34">``</span></a><a href="#id35"><span class="problematic" id="id36">`</span></a></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">left:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b,</span>&#160; <span class="pre">right:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def mintersect (left: Map k v) (right: Map k v): Map k v">
<code class="descname">def mintersect (left: Map k v) (right: Map k v): Map k v</code><a class="headerlink" href="#function-def mintersect (left: Map k v) (right: Map k v): Map k v" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all keys from the left map which do not occur in the right.
For all keys, the value from <cite>left</cite> is kept and the one from <cite>right</cite> is
discarded.  However, if the key comparison function differs between the two
inputs, then the one from the <cite>right</cite> is used.</p>
<p>For a similar function which provides control over how to join the values
contained in the map, see <cite>mintersectWith</cite>.</p>
<p><em>Examples:</em>
<a href="#id37"><span class="problematic" id="id38">``</span></a>`
def left  = listToMap scmp (“a” → 1, “b” → 2, Nil)
def right = listToMap scmp (“b” → 11, “f” → 15, Nil)</p>
<p>mintersect left right | mlookup “a” = None
mintersect left right | mlookup “b” = Some 2
mintersect left right | mlookup “f” = None
<a href="#id39"><span class="problematic" id="id40">``</span></a><a href="#id41"><span class="problematic" id="id42">`</span></a></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">left:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b,</span>&#160; <span class="pre">right:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def mintersectWith (fn: k">
<code class="descname">def mintersectWith (fn: k</code><a class="headerlink" href="#function-def mintersectWith (fn: k" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all keys which do not occur in <em>both</em> maps, joining values accordingly.
If the key comparison function differs between the two inputs, then the one
from the <cite>right</cite> is used.</p>
<p>If simply keeping the original, consider using <cite>mintersect</cite> instead.</p>
<p><em>Examples:</em>
<a href="#id43"><span class="problematic" id="id44">``</span></a>`
def left  = listToMap scmp (“a” → 1, “b” → 2, Nil)
def right = listToMap scmp (“b” → 11, “f” → 15, Nil)</p>
<p>mintersectWith (_lvrv lv + rv) left right | mlookup “a” = None
mintersectWith (_lvrv lv + rv) left right | mlookup “b” = Some 13
mintersectWith (_lvrv lv + rv) left right | mlookup “f” = None
<a href="#id45"><span class="problematic" id="id46">``</span></a><a href="#id47"><span class="problematic" id="id48">`</span></a></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">fn:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">left:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b,</span>&#160; <span class="pre">right:</span> <span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">a</span> <span class="pre">b</span></code></p>
</dd></dl>

</div>
<div class="section" id="syntax-wake">
<h2>syntax.wake<a class="headerlink" href="#syntax-wake" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="function-def (argument: a) . (memberFn: a">
<code class="descname">def (argument: a) . (memberFn: a</code><a class="headerlink" href="#function-def (argument: a) . (memberFn: a" title="Permalink to this definition">¶</a></dt>
<dd><p>Flip function and argument order.
fn obj.getXYZ = fn (getXYZ obj)</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">argument:</span> <span class="pre">a,</span>&#160; <span class="pre">memberFn:</span> <span class="pre">a,</span>&#160; <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (argument: a) | (pipeFn: a">
<code class="descname">def (argument: a) | (pipeFn: a</code><a class="headerlink" href="#function-def (argument: a) | (pipeFn: a" title="Permalink to this definition">¶</a></dt>
<dd><p>Flip function and argument order.
seq 10 | map str | catWith ” ” = catWith ” ” (map str (seq 10))</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">argument:</span> <span class="pre">a,</span>&#160; <span class="pre">pipeFn:</span> <span class="pre">a,</span>&#160; <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (dollarFn: a">
<code class="descname">def (dollarFn: a</code><a class="headerlink" href="#function-def (dollarFn: a" title="Permalink to this definition">¶</a></dt>
<dd><p>Avoid ()s without changing order.
catWith ” ” $ map str $ seq 10 = catWith ” ” (map str (seq 10))</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">dollarFn:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">argument:</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (f: b">
<code class="descname">def (f: b</code><a class="headerlink" href="#function-def (f: b" title="Permalink to this definition">¶</a></dt>
<dd><p>The ring operator is used to denote the composition of functions.
(f ∘ g) x = f (g x)</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">g:</span> <span class="pre">c,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">x:</span> <span class="pre">c</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def flip (f: a">
<code class="descname">def flip (f: a</code><a class="headerlink" href="#function-def flip (f: a" title="Permalink to this definition">¶</a></dt>
<dd><p>Allows flipping the parameters of a function.
icmp.flip 4 5 = GT
icmp.flip 5 4 = LT</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">c,</span>&#160; <span class="pre">x:</span> <span class="pre">b,</span>&#160; <span class="pre">y:</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">c</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def wait (f: a">
<code class="descname">def wait (f: a</code><a class="headerlink" href="#function-def wait (f: a" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for ‘x’ to be computed before invoking (f x).
If ‘x’ is a list, f will run once ‘x’ can be distinguished between Nil and (_, _).
Normally, ‘f x’ may invoke ‘f’ before even this basic fact is known.
You generally only need ‘wait’ when interfacing with other wake primitives.
Therefore, ask a wake expert before you resort to using this function.
The correct way to sequence events is by consuming the results of prior events in later events.
A ‘match x’ expression on list ‘x’ with different case results also acts like ‘wait’.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">x:</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def unreachable (reason: String): a">
<code class="descname">def unreachable (reason: String): a</code><a class="headerlink" href="#function-def unreachable (reason: String): a" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell the wake interpreter that it is impossible to reach this expression.
The behaviour of an execution which DOES reach <cite>unreachable</cite> is undefined.</p>
<p>### FUNCTION IS NOT INTENDED TO STOP A BUILD! ###
### To report Errors use a Result             ###</p>
<p>Parameters:
- <cite>reason</cite>: A String describing why this code is impossible to reach</p>
<p>An example of a legitimate use of unreachable:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">def</span> <span class="pre">hasUniqueMinimum</span> <span class="pre">list</span> <span class="pre">=</span>
<span class="pre">match</span> <span class="pre">(sortBy</span> <span class="pre">(_&lt;_)</span> <span class="pre">list)</span>
<span class="pre">Nil</span>&#160;&#160;&#160;&#160; <span class="pre">=</span> <span class="pre">False</span>
<span class="pre">x,</span> <span class="pre">Nil</span>&#160; <span class="pre">=</span> <span class="pre">True</span>
<span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">_</span> <span class="pre">=</span> <span class="pre">match</span> <span class="pre">(x</span> <span class="pre">&lt;=&gt;</span> <span class="pre">y)</span>
<span class="pre">LT</span> <span class="pre">=</span> <span class="pre">True</span>
<span class="pre">EQ</span> <span class="pre">=</span> <span class="pre">False</span>
<span class="pre">GT</span> <span class="pre">=</span> <span class="pre">unreachable</span> <span class="pre">&quot;Sorted</span> <span class="pre">list</span> <span class="pre">{format</span> <span class="pre">list}</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">sorted&quot;</span>
<span class="pre">`</span></code></p>
<p>The optimizer can legally remove unreachables (they are by definition unreachable).
Furthermore, the optimizer can even eliminate code that coexists with a unreachable.
Thus, here is an example of why you should never use unreachable for error reporting:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">def</span> <span class="pre">myFun</span> <span class="pre">x</span> <span class="pre">=</span>
<span class="pre">def</span> <span class="pre">_</span> <span class="pre">=</span> <span class="pre">unreachable</span> <span class="pre">&quot;stop</span> <span class="pre">the</span> <span class="pre">program&quot;</span>
<span class="pre">42</span> <span class="pre">+</span> <span class="pre">x</span>
<span class="pre">`</span></code></p>
<p>When this funciton is called from the command-line, the behaviour is undefined:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">$</span> <span class="pre">wake</span> <span class="pre">--no-optimize</span> <span class="pre">-x</span> <span class="pre">'myFun</span> <span class="pre">33'</span>
<span class="pre">PANIC:</span> <span class="pre">stop</span> <span class="pre">the</span> <span class="pre">program</span>
<span class="pre">$</span> <span class="pre">wake</span> <span class="pre">-x</span> <span class="pre">'myFun</span> <span class="pre">33'</span>
<span class="pre">75</span>
<span class="pre">$</span> <span class="pre">future-version-of-wake</span> <span class="pre">-x</span> <span class="pre">'myFun</span> <span class="pre">33'</span>
<span class="pre">200</span>
<span class="pre">`</span></code></p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">reason:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">a</span></code></p>
</dd></dl>

</div>
<div class="section" id="vector-wake">
<h2>vector.wake<a class="headerlink" href="#vector-wake" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="function-def treeToVector (t: Tree a): Vector a">
<code class="descname">def treeToVector (t: Tree a): Vector a</code><a class="headerlink" href="#function-def treeToVector (t: Tree a): Vector a" title="Permalink to this definition">¶</a></dt>
<dd><p>treeToVector: converts a <code class="docutils literal notranslate"><span class="pre">Tree</span></code> to a <code class="docutils literal notranslate"><span class="pre">Vector</span></code>.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">t:</span> <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Vector</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vempty (v: Vector a): Boolean">
<code class="descname">def vempty (v: Vector a): Boolean</code><a class="headerlink" href="#function-def vempty (v: Vector a): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>vempty: returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the <code class="docutils literal notranslate"><span class="pre">Vector</span></code> has no entries, otherwise <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>vempty (vseq 4) = False
vempty (vseq 0) = True</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">v:</span> <span class="pre">Vector</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vlen (v: Vector a): Integer">
<code class="descname">def vlen (v: Vector a): Integer</code><a class="headerlink" href="#function-def vlen (v: Vector a): Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>vlen: returns the length of the <code class="docutils literal notranslate"><span class="pre">Vector</span></code>.</p>
<p>vlen (vseq x) = x
vlen [] = 0
vlen [0, 5] = 2</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">v:</span> <span class="pre">Vector</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vsplitAt (index: Integer) (Vector v s e: Vector a): Pair (Vector a) (Vector a)">
<code class="descname">def vsplitAt (index: Integer) (Vector v s e: Vector a): Pair (Vector a) (Vector a)</code><a class="headerlink" href="#function-def vsplitAt (index: Integer) (Vector v s e: Vector a): Pair (Vector a) (Vector a)" title="Permalink to this definition">¶</a></dt>
<dd><p>vsplitAt: given an index, cut a Vector into elements before and after the index</p>
<p>vsplitAt 4 (vseq 8) = Pair [0, 1, 2, 3] [4, 5, 6, 7]
vsplitAt 0 (vseq 8) = Pair [] [0, 1, 2, 3, 4, 5, 6, 7]
vsplitAt 8 (vseq 8) = Pair [0, 1, 2, 3, 4, 5, 6, 7] []</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">Integer,</span>&#160; <span class="pre">Vector</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Pair</span> <span class="pre">(Vector</span> <span class="pre">a)</span> <span class="pre">(Vector</span> <span class="pre">a)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vtake (length: Integer) (v: Vector a): Vector a">
<code class="descname">def vtake (length: Integer) (v: Vector a): Vector a</code><a class="headerlink" href="#function-def vtake (length: Integer) (v: Vector a): Vector a" title="Permalink to this definition">¶</a></dt>
<dd><p>vtake: keep only the first <cite>length</cite> elements</p>
<p>vtake 2 (vseq 100) = [0, 1]
vtake 0 (vseq 100) = []
vtake 2 (vseq 0)   = []</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">length:</span> <span class="pre">Integer,</span>&#160; <span class="pre">v:</span> <span class="pre">Vector</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Vector</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vdrop (index: Integer) (v: Vector a): Vector a">
<code class="descname">def vdrop (index: Integer) (v: Vector a): Vector a</code><a class="headerlink" href="#function-def vdrop (index: Integer) (v: Vector a): Vector a" title="Permalink to this definition">¶</a></dt>
<dd><p>vdrop: remove elements up to <code class="docutils literal notranslate"><span class="pre">index</span></code> from the <code class="docutils literal notranslate"><span class="pre">Vector</span></code></p>
<p>vdrop 4 (vseq 6) = [4, 5]
vdrop 6 (vseq 6) = []
vdrop 0 (vseq 3) = [0, 1, 2]</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">index:</span> <span class="pre">Integer,</span>&#160; <span class="pre">v:</span> <span class="pre">Vector</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Vector</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vat (index: Integer) (Vector v s e: Vector a): Option a">
<code class="descname">def vat (index: Integer) (Vector v s e: Vector a): Option a</code><a class="headerlink" href="#function-def vat (index: Integer) (Vector v s e: Vector a): Option a" title="Permalink to this definition">¶</a></dt>
<dd><p>vat: Returns an <code class="docutils literal notranslate"><span class="pre">Option</span></code>, containing either the <code class="docutils literal notranslate"><span class="pre">i``th</span> <span class="pre">element</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">vector,</span> <span class="pre">or</span> <span class="pre">``None</span></code> if <code class="docutils literal notranslate"><span class="pre">i</span></code> is out of range.</p>
<p>vat 4 (vseq 8) = Some 4
vat 4 (vseq 4) = None
vat (-1) (vseq 4) = None</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">Integer,</span>&#160; <span class="pre">Vector</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vmap (f: a">
<code class="descname">def vmap (f: a</code><a class="headerlink" href="#function-def vmap (f: a" title="Permalink to this definition">¶</a></dt>
<dd><p>vmap: create a new Vector by applying a function f to each element of a Vector.</p>
<p>vmap str    (vseq 5) = [“0”, “1”, “2”, “3”, “4”]
vmap (_+10) (vseq 5) = [10, 11, 12, 13, 14]</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">v:</span> <span class="pre">Vector</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Vector</span> <span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vtab (f: Integer">
<code class="descname">def vtab (f: Integer</code><a class="headerlink" href="#function-def vtab (f: Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>vtab: create a Vector of specified size in parallel by calling <cite>f</cite> on the index to generate.</p>
<p>vtab (_+100) 5 = [100, 101, 102, 103, 104]</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">Integer,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">length:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Vector</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vfoldl (combiningFn: accum">
<code class="descname">def vfoldl (combiningFn: accum</code><a class="headerlink" href="#function-def vfoldl (combiningFn: accum" title="Permalink to this definition">¶</a></dt>
<dd><p>vfoldl: combine the elements of a Vector front-to-back into a single value.
An accumulator is updated from its initial value by combiningFn for each element.</p>
<p>In C++ syntax, <cite>vfoldl &lt;combiningFn&gt; &lt;accumulateInitalValue&gt; &lt;Vector&gt;</cite> does:
auto accumulator = &lt;accumulateInitalValue&gt;;
for (element : &lt;Vector&gt;) accumulator = combiningFn(accumulator, element);
return accumulator;</p>
<p>Examples:
vfoldl f x [a, b, c] = f (f (f x a) b) c
vfoldl (_+_) 0 (vseq 6) = 15</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">combiningFn:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">Vector</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vfoldr (combiningFn: element">
<code class="descname">def vfoldr (combiningFn: element</code><a class="headerlink" href="#function-def vfoldr (combiningFn: element" title="Permalink to this definition">¶</a></dt>
<dd><p>vfoldr: combine the elements of a Vector back-to-front into a single value.
An accumulator is updated from its initial value by combiningFn for each element.</p>
<p>vfoldr f x [a, b, c] = f a (f b (f c x))</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">combiningFn:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">Vector</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vmapReduce (mapFn: element">
<code class="descname">def vmapReduce (mapFn: element</code><a class="headerlink" href="#function-def vmapReduce (mapFn: element" title="Permalink to this definition">¶</a></dt>
<dd><p>vmapReduce: combine the elements of a Vector in parallel
Unlike vfold[lr], takes a map function, because reduceFn operates on the same type.
reduceFn must be an associative operator; ie: f x (f y z) = f (f x y) z
Both the mapFn and reduceFn are called exactly once for each element of the input Vector.</p>
<p>vmapReduce str (“{_}{_}”) “&gt;” (vseq 10) = “&gt;0123456789”</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">mapFn:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">reduceFn:</span> <span class="pre">b,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">Vector</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vfind (acceptFn: a">
<code class="descname">def vfind (acceptFn: a</code><a class="headerlink" href="#function-def vfind (acceptFn: a" title="Permalink to this definition">¶</a></dt>
<dd><p>vfind: find the location of the first element accepted by <cite>acceptFn</cite>
Returns: <cite>Pair value index</cite>, such that <cite>value</cite> is <cite>at index</cite>
Once <cite>acceptFn</cite> returns True, <cite>acceptFn</cite> is not evaulated on further elements.
This means that <cite>acceptFn</cite> is applied to the Vector mostly sequentially.
If more parallelism is desired, use ‘vmap f | vfind (_)’.</p>
<p>def v = vseq 10 | vmap (_+10)
vfind (_%4==0) v = Some (Pair 12 2)
vfind (_%4==4) v = None</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">acceptFn:</span> <span class="pre">a,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">Vector</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">(Pair</span> <span class="pre">a</span> <span class="pre">Integer)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vsplitUntil (stopFn: a">
<code class="descname">def vsplitUntil (stopFn: a</code><a class="headerlink" href="#function-def vsplitUntil (stopFn: a" title="Permalink to this definition">¶</a></dt>
<dd><p>vsplitUntil: cut the Vector at the point <cite>stopFn</cite> is first True
Once <cite>stopFn</cite> returns True, <cite>stopFn</cite> is not evaulated on further elements.
This means that <cite>stopFn</cite> is applied to the List mostly sequentially.
If more parallelism is desired, use ‘vmap f | vfind (_)’ and vsplitAt.</p>
<p>vsplitUntil (_&gt;=4) (vseq 8) = Pair [0, 1, 2, 3] [4, 5, 6, 7]
vsplitUntil (_&gt;=0) (vseq 8) = Pair [] [0, 1, 2, 3, 4, 5, 6, 7]
vsplitUntil (_&gt;=8) (vseq 8) = Pair [0, 1, 2, 3, 4, 5, 6, 7] []</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">stopFn:</span> <span class="pre">a,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">Vector</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Pair</span> <span class="pre">(Vector</span> <span class="pre">a)</span> <span class="pre">(Vector</span> <span class="pre">a)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vtakeUntil (stopFn: a">
<code class="descname">def vtakeUntil (stopFn: a</code><a class="headerlink" href="#function-def vtakeUntil (stopFn: a" title="Permalink to this definition">¶</a></dt>
<dd><p>vtakeUntil: take the longest prefix of a list where <cite>stopFn</cite> is False
Once <cite>stopFn</cite> returns True, <cite>stopFn</cite> is not evaulated on further elements.
This means that <cite>stopFn</cite> is applied to the List mostly sequentially.
If more parallelism is desired, use ‘vmap f | vfind (_)’ and vtake.</p>
<p>vtakeUntil (_&gt;=4) (vseq 8) = [0, 1, 2, 3]
vtakeUntil (_&gt;=0) (vseq 8) = []
vtakeUntil (_&gt;=8) (vseq 8) = [0, 1, 2, 3, 4, 5, 6, 7]</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">stopFn:</span> <span class="pre">a,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">Vector</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Vector</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vdropUntil (stopFn: a">
<code class="descname">def vdropUntil (stopFn: a</code><a class="headerlink" href="#function-def vdropUntil (stopFn: a" title="Permalink to this definition">¶</a></dt>
<dd><p>dropUntil: discard elements from the list until ‘stopFn’ returns True
Once <cite>stopFn</cite> returns True, <cite>stopFn</cite> is not evaulated on further elements.
This means that <cite>stopFn</cite> is applied to the List mostly sequentially.
If more parallelism is desired, use ‘vmap f | vfind (_)’ and vdrop.</p>
<p>vdropUntil (_&gt;=4) (vseq 8) = [4, 5, 6, 7]
vdropUntil (_&gt;=0) (vseq 8) = [0, 1, 2, 3, 4, 5, 6, 7]
vdropUntil (_&gt;=8) (vseq 8) = []</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">stopFn:</span> <span class="pre">a,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">Vector</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Vector</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vexists (acceptFn: a">
<code class="descname">def vexists (acceptFn: a</code><a class="headerlink" href="#function-def vexists (acceptFn: a" title="Permalink to this definition">¶</a></dt>
<dd><p>vexists: does <cite>acceptFn</cite> return True for any element in the vector?
Once <cite>acceptFn</cite> returns True, <cite>acceptFn</cite> is not evaulated on further elements.
This means that <cite>acceptFn</cite> is applied to the Vector mostly sequentially.
If more parallelism is desired, use ‘vmap f | vexists (_)’.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">acceptFn:</span> <span class="pre">a,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">Vector</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vforall (acceptFn: a">
<code class="descname">def vforall (acceptFn: a</code><a class="headerlink" href="#function-def vforall (acceptFn: a" title="Permalink to this definition">¶</a></dt>
<dd><p>vforall: does <cite>acceptFn</cite> return True for all element in the vector?
Once <cite>acceptFn</cite> returns False, <cite>acceptFn</cite> is not evaulated on further elements.
This means that <cite>acceptFn</cite> is applied to the Vector mostly sequentially.
If more parallelism is desired, use ‘vmap f | vforall (_)’.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">acceptFn:</span> <span class="pre">a,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">Vector</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vsplitBy (f: a">
<code class="descname">def vsplitBy (f: a</code><a class="headerlink" href="#function-def vsplitBy (f: a" title="Permalink to this definition">¶</a></dt>
<dd><p>vsplitBy: partition a Vector into those elements with <cite>f</cite> True and False</p>
<p>def isEven x = x%2 == 0
vsplitBy isEven (vseq 6) = Pair [0, 2, 4] [1, 3, 5]</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">a,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">v:</span> <span class="pre">Vector</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Pair</span> <span class="pre">(Vector</span> <span class="pre">a)</span> <span class="pre">(Vector</span> <span class="pre">a)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vfilter (f: a">
<code class="descname">def vfilter (f: a</code><a class="headerlink" href="#function-def vfilter (f: a" title="Permalink to this definition">¶</a></dt>
<dd><p>vfilter: keep only those elements in the List where <cite>f</cite> evaluates to True</p>
<p>def isEven x = x%2 == 0
vfilter isEven (vseq 10) = [0, 2, 4, 6, 8]</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">a,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">v:</span> <span class="pre">Vector</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Vector</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vunfoldl (generatingFn: accum">
<code class="descname">def vunfoldl (generatingFn: accum</code><a class="headerlink" href="#function-def vunfoldl (generatingFn: accum" title="Permalink to this definition">¶</a></dt>
<dd><p>vunfoldl: create a Vector from a generator function.
The generatingFn is called repeatedly</p>
<p>vunfoldl (x Pair (x+1) (str x)) 3 5 = [“3”, “4”, “5”, “6”, “7”]</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">generatingFn:</span> <span class="pre">a,</span>&#160; <span class="pre">Pair</span> <span class="pre">a</span> <span class="pre">b,</span>&#160; <span class="pre">a:</span> <span class="pre">a,</span>&#160; <span class="pre">n:</span> <span class="pre">Integer</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Vector</span> <span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vscanl (f: a">
<code class="descname">def vscanl (f: a</code><a class="headerlink" href="#function-def vscanl (f: a" title="Permalink to this definition">¶</a></dt>
<dd><p>vscanl: create a new Vector from an accumulator run over the elements front-to-back.
The last element of the produced Vector is equivalent to the result of vfoldl.</p>
<p>Examples:
vscanl (_+_) 100 (vseq 6) = [100, 100, 101, 103, 106, 110, 115]
^^^- 100+0+1+2+3+4+5
^^^- 100+0+1+2
^^^- 100+0
^^^- 100</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">Vector</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Vector</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vscanr (f: b">
<code class="descname">def vscanr (f: b</code><a class="headerlink" href="#function-def vscanr (f: b" title="Permalink to this definition">¶</a></dt>
<dd><p>vscanr: create a new Vector from an accumulator run over the elements back-to-front.
The first element of the produced List is equivalent to the result of a foldr.</p>
<p>Examples:
vscanr (_+_) 100 (vseq 6) = 115, 115, 114, 112, 109, 105, 100, Nil
^^^- 100
^^^- 5+100
^^^- 1+2+3+4+5+100
^^^- 0+1+2+3+4+5+100</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">Vector</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Vector</span> <span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vmapScan (mapFn: element">
<code class="descname">def vmapScan (mapFn: element</code><a class="headerlink" href="#function-def vmapScan (mapFn: element" title="Permalink to this definition">¶</a></dt>
<dd><p>vmapScan: a parallel version of vscanl.
Unlike vscanl, takes a map function, because combineFn operates on the same type.
combineFn must be an associative operator; ie: f x (f y z) = f (f x y) z.
The mapFn is called exactly once for each element of the input Vector.
The combineFn may be called up to twice per input.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">mapFn:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">combineFn:</span> <span class="pre">b,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">acc:</span> <span class="pre">b,</span>&#160; <span class="pre">v:</span> <span class="pre">Vector</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Vector</span> <span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vscan (f: a">
<code class="descname">def vscan (f: a</code><a class="headerlink" href="#function-def vscan (f: a" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">acc:</span> <span class="pre">a,</span>&#160; <span class="pre">v:</span> <span class="pre">Vector</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Vector</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vsortBy (cmpFn: a">
<code class="descname">def vsortBy (cmpFn: a</code><a class="headerlink" href="#function-def vsortBy (cmpFn: a" title="Permalink to this definition">¶</a></dt>
<dd><p>vsortBy: sort the input vector so that it is ascending wrt. lessThanFn
Runtime when almost-sorted is O(n), otherwise O(nlogn)
This is a stable sort; two equal values will retain their relative order.</p>
<p>vtab vseq 10 | vflatten | vsortBy (_&lt;_) =
[0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 3 3 3 3 3 3 4 4 4 4 4 5 5 5 5 6 6 6 7 7 8]</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">cmpFn:</span> <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">Order,</span>&#160; <span class="pre">v:</span> <span class="pre">Vector</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Vector</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vdistinctBy (cmp: a">
<code class="descname">def vdistinctBy (cmp: a</code><a class="headerlink" href="#function-def vdistinctBy (cmp: a" title="Permalink to this definition">¶</a></dt>
<dd><p>vdistinctBy: keep only the first occurrence of a value
The order of non-duplicated elements is retained.</p>
<p>vdistinctBy (_&lt;=&gt;_) [1, 2, 1, 3, 4, 3] = [1, 2, 3, 4]</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">cmp:</span> <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">Order,</span>&#160; <span class="pre">v:</span> <span class="pre">Vector</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Vector</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vdistinctRunBy (eq: a">
<code class="descname">def vdistinctRunBy (eq: a</code><a class="headerlink" href="#function-def vdistinctRunBy (eq: a" title="Permalink to this definition">¶</a></dt>
<dd><p>vdistinctRunBy: keep only the first occurrence in a run of equal values</p>
<p>vdistinctRunBy (_==_) [1, 1, 2, 1, 3, 3] = [1, 2, 1, 3]</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">eq:</span> <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">v:</span> <span class="pre">Vector</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Vector</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vcmp (compareFn: a">
<code class="descname">def vcmp (compareFn: a</code><a class="headerlink" href="#function-def vcmp (compareFn: a" title="Permalink to this definition">¶</a></dt>
<dd><p>vcmp: compare two Vectors using an Order comparator</p>
<p>vcmp (_&lt;=&gt;_) (vseq 5)  (vseq 5)  = EQ
vcmp (_&lt;=&gt;_) (vseq 5)  (vseq 4)  = GT
vcmp (_&lt;=&gt;_) [0] [1] = LT</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">compareFn:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">Order,</span>&#160; <span class="pre">Vector</span> <span class="pre">a,</span>&#160; <span class="pre">Vector</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Order</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vmapPartial (f: a">
<code class="descname">def vmapPartial (f: a</code><a class="headerlink" href="#function-def vmapPartial (f: a" title="Permalink to this definition">¶</a></dt>
<dd><p>vmapPartial: create a new Vector by applying a partial funciton to each element of a Vector.
Partial functions can return None, in which case the result is not included in the output.</p>
<p>vmapPartial int [“3”, “x”, “44”] = [3, 44]</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">a,</span>&#160; <span class="pre">Option</span> <span class="pre">b,</span>&#160; <span class="pre">v:</span> <span class="pre">Vector</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Vector</span> <span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vmapPartial2 (f: a">
<code class="descname">def vmapPartial2 (f: a</code><a class="headerlink" href="#function-def vmapPartial2 (f: a" title="Permalink to this definition">¶</a></dt>
<dd><p>vmapPartial2: create a new Vector by applying a partial function up to twice to each element of a Vector.
If <cite>f</cite> is very fast, vmapPartial2 is more efficient as it avoids walking the vector twice.</p>
<p>vmapPartial2 int [“3”, “x”, “44”] = [3, 44]</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">a,</span>&#160; <span class="pre">Option</span> <span class="pre">b,</span>&#160; <span class="pre">v:</span> <span class="pre">Vector</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Vector</span> <span class="pre">b</span></code></p>
</dd></dl>

</div>
<div class="section" id="print-wake">
<h2>print.wake<a class="headerlink" href="#print-wake" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="function-def format (anyType: a): String">
<code class="descname">def format (anyType: a): String</code><a class="headerlink" href="#function-def format (anyType: a): String" title="Permalink to this definition">¶</a></dt>
<dd><p>format: render any type into a printable String</p>
<p>format 44        = “44”
format “Hello”   = “”Hello””
format “n”      = “”\n””
format (seq 4)’  = “0, 1, 2, 3, Nil”
format pi        = “3.1415926535897931”
format (Pass 33) = “Pass 33”
format True      = “True”
format (_)       = “&lt;source-file.wake:line:column&gt;”</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">anyType:</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">String</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def getLogLevelName (LogLevel name): String">
<code class="descname">def getLogLevelName (LogLevel name): String</code><a class="headerlink" href="#function-def getLogLevelName (LogLevel name): String" title="Permalink to this definition">¶</a></dt>
<dd><p>getLogLevelName: return the name of the LogLevel</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">LogLevel</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">String</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def makeLogLevel (name: String) (colour: Option Colour): LogLevel">
<code class="descname">def makeLogLevel (name: String) (colour: Option Colour): LogLevel</code><a class="headerlink" href="#function-def makeLogLevel (name: String) (colour: Option Colour): LogLevel" title="Permalink to this definition">¶</a></dt>
<dd><p>makeLogLevel: define a new log level</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">name:</span> <span class="pre">String,</span>&#160; <span class="pre">colour:</span> <span class="pre">Option</span> <span class="pre">Colour</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">LogLevel</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def makeLogLevel2 (name: String) (colour: Option Colour) (intensity: Option Intensity): LogLevel">
<code class="descname">def makeLogLevel2 (name: String) (colour: Option Colour) (intensity: Option Intensity): LogLevel</code><a class="headerlink" href="#function-def makeLogLevel2 (name: String) (colour: Option Colour) (intensity: Option Intensity): LogLevel" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">name:</span> <span class="pre">String,</span>&#160; <span class="pre">colour:</span> <span class="pre">Option</span> <span class="pre">Colour,</span>&#160; <span class="pre">intensity:</span> <span class="pre">Option</span> <span class="pre">Intensity</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">LogLevel</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tap (consumerFn: a">
<code class="descname">def tap (consumerFn: a</code><a class="headerlink" href="#function-def tap (consumerFn: a" title="Permalink to this definition">¶</a></dt>
<dd><p>tap: inject a diagnostic into a pipeline
Oftern used in conjunction with println and/or format.</p>
<p>def foo =
“123123”
| tap (println “DEBUG; I SAW: {format _}”)
| int
| getOrElse 0</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">consumerFn:</span> <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">value:</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def printLevel (LogLevel name): String">
<code class="descname">def printLevel (LogLevel name): String</code><a class="headerlink" href="#function-def printLevel (LogLevel name): String" title="Permalink to this definition">¶</a></dt>
<dd><p>printLevel: print a String on the given LogLevel.</p>
<p># Produce a red hello on stderr
def Unit = printLevel logError “hellon”</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">LogLevel,</span>&#160; <span class="pre">outputStr:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Unit</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def printlnLevel (level: LogLevel): String">
<code class="descname">def printlnLevel (level: LogLevel): String</code><a class="headerlink" href="#function-def printlnLevel (level: LogLevel): String" title="Permalink to this definition">¶</a></dt>
<dd><p>printlnLevel: print a String with a newline on the given LogLevel.</p>
<p># Produce a yellow hello on stdout unless run with -q
def Unit = printlnLevel logWarning “hello”</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">level:</span> <span class="pre">LogLevel,</span>&#160; <span class="pre">outputStr:</span> <span class="pre">String</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Unit</span></code></p>
</dd></dl>

</div>
<div class="section" id="tree-wake">
<h2>tree.wake<a class="headerlink" href="#tree-wake" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="function-def tnew cmp">
<code class="descname">def tnew cmp</code><a class="headerlink" href="#function-def tnew cmp" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new Tree, sorted by cmp.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">cmp:</span> <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">Order</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def listToTree cmp list">
<code class="descname">def listToTree cmp list</code><a class="headerlink" href="#function-def listToTree cmp list" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a List to a Tree.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">cmp:</span> <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">Order,</span>&#160; <span class="pre">list:</span> <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def listToTreeMulti cmp list">
<code class="descname">def listToTreeMulti cmp list</code><a class="headerlink" href="#function-def listToTreeMulti cmp list" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">cmp:</span> <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">Order,</span>&#160; <span class="pre">list:</span> <span class="pre">List</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vectorToTreeMulti cmp v">
<code class="descname">def vectorToTreeMulti cmp v</code><a class="headerlink" href="#function-def vectorToTreeMulti cmp v" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">cmp:</span> <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">Order,</span>&#160; <span class="pre">v:</span> <span class="pre">Vector</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def vectorToTree cmp v">
<code class="descname">def vectorToTree cmp v</code><a class="headerlink" href="#function-def vectorToTree cmp v" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a Vector to a Tree.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">cmp:</span> <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">Order,</span>&#160; <span class="pre">v:</span> <span class="pre">Vector</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tlen (Tree _ root: Tree a): Integer">
<code class="descname">def tlen (Tree _ root: Tree a): Integer</code><a class="headerlink" href="#function-def tlen (Tree _ root: Tree a): Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total length of the Tree.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tempty (Tree _ root: Tree a): Boolean">
<code class="descname">def tempty (Tree _ root: Tree a): Boolean</code><a class="headerlink" href="#function-def tempty (Tree _ root: Tree a): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the Tree is empty, False otherwise.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tinsert (y: a) (Tree cmp root: Tree a): Tree a">
<code class="descname">def tinsert (y: a) (Tree cmp root: Tree a): Tree a</code><a class="headerlink" href="#function-def tinsert (y: a) (Tree cmp root: Tree a): Tree a" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert y into the tree only if no other keys == y</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a,</span>&#160; <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tinsertReplace (y: a) (tree: Tree a): Tree a">
<code class="descname">def tinsertReplace (y: a) (tree: Tree a): Tree a</code><a class="headerlink" href="#function-def tinsertReplace (y: a) (tree: Tree a): Tree a" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert y into the tree, removing any existing keys == y</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">y:</span> <span class="pre">a,</span>&#160; <span class="pre">tree:</span> <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tinsertMulti (y: a) (Tree cmp root: Tree a): Tree a">
<code class="descname">def tinsertMulti (y: a) (Tree cmp root: Tree a): Tree a</code><a class="headerlink" href="#function-def tinsertMulti (y: a) (Tree cmp root: Tree a): Tree a" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert y into the tree at the lowest rank of keys = y</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a,</span>&#160; <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tinsertWith (fn: (incoming: a)">
<code class="descname">def tinsertWith (fn: (incoming: a)</code><a class="headerlink" href="#function-def tinsertWith (fn: (incoming: a)" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert y into the tree, or the value resulting from fn on a collision
<cite>y</cite> is passed as the left-hand value of <cite>fn</cite>.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">fn:</span> <span class="pre">incoming:</span> <span class="pre">a,</span>&#160; <span class="pre">existing:</span> <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">y:</span> <span class="pre">a,</span>&#160; <span class="pre">tree:</span> <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (a: Tree x) ⊆ (b: Tree x): Boolean">
<code class="descname">def (a: Tree x) ⊆ (b: Tree x): Boolean</code><a class="headerlink" href="#function-def (a: Tree x) ⊆ (b: Tree x): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if <cite>a</cite> is a subset of <cite>b</cite> (every element of <cite>a</cite> is also in <cite>b</cite>).
Note that the comparison function of <cite>b</cite> is used to determine element
equality, if the two differ. See <cite>tsubset</cite> for a prefix form of the function.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a:</span> <span class="pre">Tree</span> <span class="pre">a,</span>&#160; <span class="pre">b:</span> <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (a: Tree x) ⊇ (b: Tree x): Boolean">
<code class="descname">def (a: Tree x) ⊇ (b: Tree x): Boolean</code><a class="headerlink" href="#function-def (a: Tree x) ⊇ (b: Tree x): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if <cite>a</cite> is a superset of <cite>b</cite> (<cite>a</cite> contains every element of <cite>b</cite>).
Note that the comparison function of <cite>b</cite> is used to determine element
equality, if the two differ.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a:</span> <span class="pre">Tree</span> <span class="pre">a,</span>&#160; <span class="pre">b:</span> <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (a: Tree x) ⊉ (b: Tree x): Boolean">
<code class="descname">def (a: Tree x) ⊉ (b: Tree x): Boolean</code><a class="headerlink" href="#function-def (a: Tree x) ⊉ (b: Tree x): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if <cite>a</cite> is <em>not</em> a superset of <cite>b</cite> (<cite>a</cite> is missing some element of <cite>b</cite>).
Note that the comparison function of <cite>b</cite> is used to determine element
equality, if the two differ.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a:</span> <span class="pre">Tree</span> <span class="pre">a,</span>&#160; <span class="pre">b:</span> <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (a: Tree x) ⊈ (b: Tree x): Boolean">
<code class="descname">def (a: Tree x) ⊈ (b: Tree x): Boolean</code><a class="headerlink" href="#function-def (a: Tree x) ⊈ (b: Tree x): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if <cite>a</cite> is <em>not</em> a subset of <cite>b</cite> (some element of <cite>a</cite> does not exist in <cite>b</cite>).
Note that the comparison function of <cite>b</cite> is used to determine element
equality, if the two differ.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a:</span> <span class="pre">Tree</span> <span class="pre">a,</span>&#160; <span class="pre">b:</span> <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (a: Tree x) ⊊ (b: Tree x): Boolean">
<code class="descname">def (a: Tree x) ⊊ (b: Tree x): Boolean</code><a class="headerlink" href="#function-def (a: Tree x) ⊊ (b: Tree x): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if <cite>a</cite> is a proper subset of <cite>b</cite>.
(Not only is every element of <cite>a</cite> is also in <cite>b</cite>, but the two sets aren’t equal.)
Note that the comparison function of <cite>b</cite> is used to determine element
equality, if the two differ.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a:</span> <span class="pre">Tree</span> <span class="pre">a,</span>&#160; <span class="pre">b:</span> <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def (a: Tree x) ⊋ (b: Tree x): Boolean">
<code class="descname">def (a: Tree x) ⊋ (b: Tree x): Boolean</code><a class="headerlink" href="#function-def (a: Tree x) ⊋ (b: Tree x): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if <cite>a</cite> is a proper superset of <cite>b</cite>.
(Not only does <cite>a</cite> contain every element <cite>b</cite>, but the two sets aren’t equal.)
Note that the comparison function of <cite>b</cite> is used to determine element
equality, if the two differ.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a:</span> <span class="pre">Tree</span> <span class="pre">a,</span>&#160; <span class="pre">b:</span> <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tsubset (a: Tree x) (b: Tree x): Boolean">
<code class="descname">def tsubset (a: Tree x) (b: Tree x): Boolean</code><a class="headerlink" href="#function-def tsubset (a: Tree x) (b: Tree x): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if <cite>a</cite> is a subset of <cite>b</cite> (every element of <cite>a</cite> is also in <cite>b</cite>).
Note that the comparison function of <cite>b</cite> is used to determine element
equality, if the two differ.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a:</span> <span class="pre">Tree</span> <span class="pre">a,</span>&#160; <span class="pre">b:</span> <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tdelete (y: a) (Tree cmp root: Tree a): Tree a">
<code class="descname">def tdelete (y: a) (Tree cmp root: Tree a): Tree a</code><a class="headerlink" href="#function-def tdelete (y: a) (Tree cmp root: Tree a): Tree a" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes all keys that are equal to y.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a,</span>&#160; <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tfoldl f a (Tree _ root)">
<code class="descname">def tfoldl f a (Tree _ root)</code><a class="headerlink" href="#function-def tfoldl f a (Tree _ root)" title="Permalink to this definition">¶</a></dt>
<dd><p>Folds from left to right.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">Tree</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tfoldr f a (Tree _ root)">
<code class="descname">def tfoldr f a (Tree _ root)</code><a class="headerlink" href="#function-def tfoldr f a (Tree _ root)" title="Permalink to this definition">¶</a></dt>
<dd><p>Folds from right to left.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">b</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tfoldmap (combineFn: b">
<code class="descname">def tfoldmap (combineFn: b</code><a class="headerlink" href="#function-def tfoldmap (combineFn: b" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform and collapse all values in a <cite>Tree</cite> in parallel.</p>
<p><em>Parameters:</em>
* <cite>combineFn</cite>: A function which can combine multiple output values into one.
This function should be parallel.
* <cite>base</cite>: A “seed” value with which to start the fold.  This will be applied
as the farthest-left value, before any values derived from <cite>tree</cite> itself.
* <cite>transformFn</cite>: A function performing some work to be applied to every
element in <cite>tree</cite> in parallel.
* <cite>tree</cite>: The values from which the result should be derived.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">combineFn:</span> <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">base:</span> <span class="pre">a,</span>&#160; <span class="pre">transformFn:</span> <span class="pre">b,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">tree:</span> <span class="pre">Tree</span> <span class="pre">b</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tfold f a t">
<code class="descname">def tfold f a t</code><a class="headerlink" href="#function-def tfold f a t" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">a:</span> <span class="pre">a,</span>&#160; <span class="pre">t:</span> <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def treeToList">
<code class="descname">def treeToList</code><a class="headerlink" href="#function-def treeToList" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a Tree to a List.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tappi f (Tree _ root)">
<code class="descname">def tappi f (Tree _ root)</code><a class="headerlink" href="#function-def tappi f (Tree _ root)" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">Integer,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">b,</span>&#160; <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Unit</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tat (i: Integer) (Tree _ root: Tree a): Option a">
<code class="descname">def tat (i: Integer) (Tree _ root: Tree a): Option a</code><a class="headerlink" href="#function-def tat (i: Integer) (Tree _ root: Tree a): Option a" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the i-th ranked element</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">Integer,</span>&#160; <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tsplitAt (i: Integer) (Tree cmp root: Tree a): Pair (Tree a) (Tree a)">
<code class="descname">def tsplitAt (i: Integer) (Tree cmp root: Tree a): Pair (Tree a) (Tree a)</code><a class="headerlink" href="#function-def tsplitAt (i: Integer) (Tree cmp root: Tree a): Pair (Tree a) (Tree a)" title="Permalink to this definition">¶</a></dt>
<dd><p>Split elements ranked [0,i) and [i,inf) into two trees</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">Integer,</span>&#160; <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Pair</span> <span class="pre">(Tree</span> <span class="pre">a)</span> <span class="pre">(Tree</span> <span class="pre">a)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def ttake i t">
<code class="descname">def ttake i t</code><a class="headerlink" href="#function-def ttake i t" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">i:</span> <span class="pre">Integer,</span>&#160; <span class="pre">t:</span> <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tdrop i t">
<code class="descname">def tdrop i t</code><a class="headerlink" href="#function-def tdrop i t" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">i:</span> <span class="pre">Integer,</span>&#160; <span class="pre">t:</span> <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tfind f (Tree _ root)">
<code class="descname">def tfind f (Tree _ root)</code><a class="headerlink" href="#function-def tfind f (Tree _ root)" title="Permalink to this definition">¶</a></dt>
<dd><p>Lowest rank element where f x = True  =&gt; Option (Pair x rank)</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">(Pair</span> <span class="pre">a</span> <span class="pre">Integer)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tsplitUntil f t">
<code class="descname">def tsplitUntil f t</code><a class="headerlink" href="#function-def tsplitUntil f t" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">a,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">t:</span> <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Pair</span> <span class="pre">(Tree</span> <span class="pre">a)</span> <span class="pre">(Tree</span> <span class="pre">a)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def ttakeUntil f t">
<code class="descname">def ttakeUntil f t</code><a class="headerlink" href="#function-def ttakeUntil f t" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">a,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">t:</span> <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tdropUntil f t">
<code class="descname">def tdropUntil f t</code><a class="headerlink" href="#function-def tdropUntil f t" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">a,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">t:</span> <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def texists f t">
<code class="descname">def texists f t</code><a class="headerlink" href="#function-def texists f t" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if there exists an x in t where f x = True</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">a,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">t:</span> <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tforall f t">
<code class="descname">def tforall f t</code><a class="headerlink" href="#function-def tforall f t" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">a,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">t:</span> <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tsplit y (Tree cmp root)">
<code class="descname">def tsplit y (Tree cmp root)</code><a class="headerlink" href="#function-def tsplit y (Tree cmp root)" title="Permalink to this definition">¶</a></dt>
<dd><p>Split tree into those elements &lt;, =, and &gt; y</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a,</span>&#160; <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Triple</span> <span class="pre">(Tree</span> <span class="pre">a)</span> <span class="pre">(Tree</span> <span class="pre">a)</span> <span class="pre">(Tree</span> <span class="pre">a)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tsplitBy (f: a">
<code class="descname">def tsplitBy (f: a</code><a class="headerlink" href="#function-def tsplitBy (f: a" title="Permalink to this definition">¶</a></dt>
<dd><p>Split tree into those elements where f x = True and those where f x = False</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Pair</span> <span class="pre">(Tree</span> <span class="pre">a)</span> <span class="pre">(Tree</span> <span class="pre">a)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tfilter (f: a">
<code class="descname">def tfilter (f: a</code><a class="headerlink" href="#function-def tfilter (f: a" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all elements x such that f x = False.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tmin (Tree _ root: Tree a): Option a">
<code class="descname">def tmin (Tree _ root: Tree a): Option a</code><a class="headerlink" href="#function-def tmin (Tree _ root: Tree a): Option a" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the smallest element in the tree.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tmax (Tree _ root: Tree a): Option a">
<code class="descname">def tmax (Tree _ root: Tree a): Option a</code><a class="headerlink" href="#function-def tmax (Tree _ root: Tree a): Option a" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the largest element in the tree.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tlowerGE (y: a) (Tree cmp root: Tree a): Option (Pair a Integer)">
<code class="descname">def tlowerGE (y: a) (Tree cmp root: Tree a): Option (Pair a Integer)</code><a class="headerlink" href="#function-def tlowerGE (y: a) (Tree cmp root: Tree a): Option (Pair a Integer)" title="Permalink to this definition">¶</a></dt>
<dd><p>Lowest rank element with x &gt;= y, along with that rank.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a,</span>&#160; <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">(Pair</span> <span class="pre">a</span> <span class="pre">Integer)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tlowerGT (y: a) (Tree cmp root: Tree a): Option (Pair a Integer)">
<code class="descname">def tlowerGT (y: a) (Tree cmp root: Tree a): Option (Pair a Integer)</code><a class="headerlink" href="#function-def tlowerGT (y: a) (Tree cmp root: Tree a): Option (Pair a Integer)" title="Permalink to this definition">¶</a></dt>
<dd><p>Lowest rank element with x &gt; y, along with that rank.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a,</span>&#160; <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">(Pair</span> <span class="pre">a</span> <span class="pre">Integer)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tupperLT (y: a) (Tree cmp root: Tree a): Option (Pair a Integer)">
<code class="descname">def tupperLT (y: a) (Tree cmp root: Tree a): Option (Pair a Integer)</code><a class="headerlink" href="#function-def tupperLT (y: a) (Tree cmp root: Tree a): Option (Pair a Integer)" title="Permalink to this definition">¶</a></dt>
<dd><p>Highest rank element with x &lt; y, along with that rank.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a,</span>&#160; <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">(Pair</span> <span class="pre">a</span> <span class="pre">Integer)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tupperLE (y: a) (Tree cmp root: Tree a): Option (Pair a Integer)">
<code class="descname">def tupperLE (y: a) (Tree cmp root: Tree a): Option (Pair a Integer)</code><a class="headerlink" href="#function-def tupperLE (y: a) (Tree cmp root: Tree a): Option (Pair a Integer)" title="Permalink to this definition">¶</a></dt>
<dd><p>Highest rank element with x &lt;= y, along with that rank.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a,</span>&#160; <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">(Pair</span> <span class="pre">a</span> <span class="pre">Integer)</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tequal y (Tree cmp root)">
<code class="descname">def tequal y (Tree cmp root)</code><a class="headerlink" href="#function-def tequal y (Tree cmp root)" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract all elements from the tree which are equal to y
=&gt; Pair (matches: List x) (rank: Integer)</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a,</span>&#160; <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Pair</span> <span class="pre">(List</span> <span class="pre">a)</span> <span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def x ∈ y">
<code class="descname">def x ∈ y</code><a class="headerlink" href="#function-def x ∈ y" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if x is an element of y, False otherwise.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">a,</span>&#160; <span class="pre">y:</span> <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def x ∉ y">
<code class="descname">def x ∉ y</code><a class="headerlink" href="#function-def x ∉ y" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if x is NOT an element of y, False otherwise.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">a,</span>&#160; <span class="pre">y:</span> <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def x ∋ y">
<code class="descname">def x ∋ y</code><a class="headerlink" href="#function-def x ∋ y" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if x contains y, False otherwise.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Tree</span> <span class="pre">a,</span>&#160; <span class="pre">y:</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def x ∌ y">
<code class="descname">def x ∌ y</code><a class="headerlink" href="#function-def x ∌ y" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if x does NOT contain y, False otherwise.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">x:</span> <span class="pre">Tree</span> <span class="pre">a,</span>&#160; <span class="pre">y:</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tcontains (y: a) (t: Tree a): Boolean">
<code class="descname">def tcontains (y: a) (t: Tree a): Boolean</code><a class="headerlink" href="#function-def tcontains (y: a) (t: Tree a): Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">y:</span> <span class="pre">a,</span>&#160; <span class="pre">t:</span> <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tdistinctBy (cmp: a =&gt; a =&gt; Order) (t: Tree a): Tree a">
<code class="descname">def tdistinctBy (cmp: a =&gt; a =&gt; Order) (t: Tree a): Tree a</code><a class="headerlink" href="#function-def tdistinctBy (cmp: a => a => Order) (t: Tree a): Tree a" title="Permalink to this definition">¶</a></dt>
<dd><p>Eliminate duplicates, as identified by cmp</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">cmp:</span> <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">Order,</span>&#160; <span class="pre">t:</span> <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tdistinctRunBy (f: a =&gt; a =&gt; Boolean) (t: Tree a): Tree a">
<code class="descname">def tdistinctRunBy (f: a =&gt; a =&gt; Boolean) (t: Tree a): Tree a</code><a class="headerlink" href="#function-def tdistinctRunBy (f: a => a => Boolean) (t: Tree a): Tree a" title="Permalink to this definition">¶</a></dt>
<dd><p>Eliminate duplicates, as identified by f</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">Boolean,</span>&#160; <span class="pre">t:</span> <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def a ∪ b">
<code class="descname">def a ∪ b</code><a class="headerlink" href="#function-def a ∪ b" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the union of trees a and b, keeps only values from a if they are equal to values in b.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a:</span> <span class="pre">Tree</span> <span class="pre">a,</span>&#160; <span class="pre">b:</span> <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tunion (Tree _ aroot: Tree a) (Tree cmp broot: Tree a): Tree a">
<code class="descname">def tunion (Tree _ aroot: Tree a) (Tree cmp broot: Tree a): Tree a</code><a class="headerlink" href="#function-def tunion (Tree _ aroot: Tree a) (Tree cmp broot: Tree a): Tree a" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the union of two trees, given their roots.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a,</span>&#160; <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tunionWith (fn: a">
<code class="descname">def tunionWith (fn: a</code><a class="headerlink" href="#function-def tunionWith (fn: a" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">fn:</span> <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">left:</span> <span class="pre">Tree</span> <span class="pre">a,</span>&#160; <span class="pre">right:</span> <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def a ⊎ b">
<code class="descname">def a ⊎ b</code><a class="headerlink" href="#function-def a ⊎ b" title="Permalink to this definition">¶</a></dt>
<dd><p>Union of two trees, keeping equal values of a before equal values of b</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a:</span> <span class="pre">Tree</span> <span class="pre">a,</span>&#160; <span class="pre">b:</span> <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tunionMulti (Tree _ aroot) (Tree cmp broot)">
<code class="descname">def tunionMulti (Tree _ aroot) (Tree cmp broot)</code><a class="headerlink" href="#function-def tunionMulti (Tree _ aroot) (Tree cmp broot)" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a,</span>&#160; <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tsubtract (Tree _ aroot: Tree a) (Tree cmp broot: Tree a): Tree a">
<code class="descname">def tsubtract (Tree _ aroot: Tree a) (Tree cmp broot: Tree a): Tree a</code><a class="headerlink" href="#function-def tsubtract (Tree _ aroot: Tree a) (Tree cmp broot: Tree a): Tree a" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the set difference of A and B, that is, a tree containing all elements of A which are not in B.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a,</span>&#160; <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def a ∩ b">
<code class="descname">def a ∩ b</code><a class="headerlink" href="#function-def a ∩ b" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tree containing all elements of A which are also in B.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">a:</span> <span class="pre">Tree</span> <span class="pre">a,</span>&#160; <span class="pre">b:</span> <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tintersect (Tree _ aroot) (Tree cmp broot)">
<code class="descname">def tintersect (Tree _ aroot) (Tree cmp broot)</code><a class="headerlink" href="#function-def tintersect (Tree _ aroot) (Tree cmp broot)" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a,</span>&#160; <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="function">
<dt id="function-def tintersectWith (fn: a">
<code class="descname">def tintersectWith (fn: a</code><a class="headerlink" href="#function-def tintersectWith (fn: a" title="Permalink to this definition">¶</a></dt>
<dd><p>No description for this feature yet.</p>
<p>Parameters: <code class="docutils literal notranslate"><span class="pre">fn:</span> <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">a,</span>&#160; <span class="pre">left:</span> <span class="pre">Tree</span> <span class="pre">a,</span>&#160; <span class="pre">right:</span> <span class="pre">Tree</span> <span class="pre">a</span></code></p>
<p>Return Type: <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code></p>
</dd></dl>

</div>
<div class="section" id="types-wake">
<h2>types.wake<a class="headerlink" href="#types-wake" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../contents.html">wake-manual</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../gcc_wake/gcc_wake.html">gcc_wake</a></li>
<li class="toctree-l1"><a class="reference internal" href="../versions/versions.html">versions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../system/system.html">system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nothing/nothing.html">nothing</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">core</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#tuple-wake">tuple.wake</a></li>
<li class="toctree-l2"><a class="reference internal" href="#boolean-wake">boolean.wake</a></li>
<li class="toctree-l2"><a class="reference internal" href="#regexp-wake">regexp.wake</a></li>
<li class="toctree-l2"><a class="reference internal" href="#result-wake">result.wake</a></li>
<li class="toctree-l2"><a class="reference internal" href="#list-wake">list.wake</a></li>
<li class="toctree-l2"><a class="reference internal" href="#string-wake">string.wake</a></li>
<li class="toctree-l2"><a class="reference internal" href="#integer-wake">integer.wake</a></li>
<li class="toctree-l2"><a class="reference internal" href="#json-wake">json.wake</a></li>
<li class="toctree-l2"><a class="reference internal" href="#order-wake">order.wake</a></li>
<li class="toctree-l2"><a class="reference internal" href="#option-wake">option.wake</a></li>
<li class="toctree-l2"><a class="reference internal" href="#double-wake">double.wake</a></li>
<li class="toctree-l2"><a class="reference internal" href="#map-wake">map.wake</a></li>
<li class="toctree-l2"><a class="reference internal" href="#syntax-wake">syntax.wake</a></li>
<li class="toctree-l2"><a class="reference internal" href="#vector-wake">vector.wake</a></li>
<li class="toctree-l2"><a class="reference internal" href="#print-wake">print.wake</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tree-wake">tree.wake</a></li>
<li class="toctree-l2"><a class="reference internal" href="#types-wake">types.wake</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../contents.html">Documentation overview</a><ul>
  <li><a href="../lib.html">&lt;no title&gt;</a><ul>
      <li>Previous: <a href="../nothing/nothing.html" title="previous chapter">nothing</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, John Andrews.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.8</a>
      
      |
      <a href="../_sources/core/core.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>