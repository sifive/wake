# Copyright 2019 SiFive, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You should have received a copy of LICENSE.Apache2 along with
# this software. If not, you may obtain a copy at
#
#    https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

package build_wake
from wake import _

# Useful build variants (arguments to all)
def toVariant = match _
  "default" = Pass (Pair "native-cpp11-release" "native-c99-release")
  "static"  = Pass (Pair "native-cpp11-static" "native-c99-static")
  "debug"   = Pass (Pair "native-cpp11-debug" "native-c99-debug")
  s = Fail "Unknown build target ({s})".makeError

export def build = match _
  "tarball", Nil = tarball Unit | rmap (\_ "TARBALL")
  kind, Nil =
    require Pass variant = toVariant kind
    all variant | rmap (\_ "BUILD")
  _ = Fail "no target specified (try: build default/debug/tarball)".makeError

export def install = match _
  dest, kind, Nil = doInstall (in cwd dest) kind | rmap (\_ "INSTALL")
  dest, Nil = doInstall (in cwd dest) "default" | rmap (\_ "INSTALL")
  _ = Fail "no directory specified (try: install /opt/local)".makeError

# Build all wake targets
def targets =
  def allPlatforms = buildWake, buildFuse, buildFuseDaemon, buildShim, buildPreload, buildPrelib, buildBSP, Nil
  def linuxOnly = buildWakeBox, Nil
  match sysname
    "Linux" = allPlatforms ++ linuxOnly
    _       = allPlatforms

def all variant = map (_ variant) targets | findFailFn getPathResult

# Install wake into a target location
def doInstall dest kind =
  require Pass variant = toVariant kind
  def datfiles = source "{here}/build/wake/stamp", sources "{here}/share" `.*`
  def binfilesResult = all variant
  def releaseBin exe = installAs "{dest}/{replace `\.[^.]*$` '' exe.getPathName}" exe
  def datinstall = map (installIn dest ".") datfiles
  def readme = installIn "{dest}/share/doc/wake" "." (source "README.md")
  require Pass binfiles = binfilesResult
  def bininstall = map releaseBin binfiles
  def outputs = readme, bininstall ++ datinstall
  findFailFn getPathResult outputs

# List Path => Result (List Path) Error
# findFailFn getPathResult
def a ;& b =
  require Pass x = a
  require Pass y = b
  Pass (x; y)

# Create a release tarball
def tarball Unit =
  require Pass (release; time) = buildAs Unit ;& buildOn Unit
  # Create debian + RedHat package files
  def setVersion file =
    def in = source "{file}.in"
    def script = "%
      set -e
      sed "s/@VERSION@/%{release}/g" "%{in.getPathName}" > "%{file}.tmp"
      mv "%{file}.tmp" "%{file}"
      %"
    shellJob script (in, Nil) | getJobOutput
  def changelog = setVersion "debian/changelog"
  def spec = setVersion "wake.spec"
  # Identify those sources files to include in the tarball
  def srcs =
    sources "." `.*`
    | filter (! matches `(debian/|wake.spec).*` _.getPathName) # omit packaging files
    | filter (! matches `(\.circleci/|\.github/).*|\.dockerignore` _.getPathName) # omit CI files
    | filter (! matches `(.*/)*\.gitignore` _.getPathName) # omit git files
  def Pair testPaths wakePaths = splitBy (matches `tests/.*` _.getPathName) srcs
  def wakeSourcesString =
    wakePaths
    | map (_.getPathName.format)
    | foldr (_, ",\n  ", _) Nil
    | cat
  def testSourcesString =
    testPaths
    | map (getPathName _ | format | replace `^"tests/` '"{here}/')
    | foldr (_, ",\n  ", _) Nil
    | cat
  def manifestStr = "%
    # Generated by 'wake tarball Unit':
    package build_wake
    from wake import source , Nil
    
    publish releaseAs = '%{release}', Nil
    publish releaseOn = '%{time}', Nil
    publish source =
      %{wakeSourcesString}Nil
    %"
  def testsManifestStr = "%
    # Generated by 'wake tarball Unit':
    package test_wake
    from wake import source , Nil
    
    publish source =
      %{testSourcesString}Nil
    %"
  # Create a manifest which describes the release and source files
  def manifest = write "manifest.wake" manifestStr
  def testManifest = write "tests/manifest.wake" testsManifestStr
  # Execute tar to create a tarball of manifest + sources
  def tarball =
    def cmd =
      def gnutar = which "gnutar"
      def tar = if gnutar ==* "gnutar" then which "tar" else gnutar
      def files = map getPathName (manifest, testManifest, spec, srcs) | sortBy (_<*_)
      tar, "--mtime={time}", "--transform=s@^@wake-{release}/@",
      "--owner=0", "--group=0", "--numeric-owner", "-cJf",
      "wake_{release}.tar.xz", files
    job cmd (manifest, testManifest, spec, srcs)
    | getJobOutput
  findFailFn getPathResult (tarball, changelog, Nil)

export def static _ =
  def filesResult = doInstall "tmp" "static"
  require Pass (release; time) = buildAs Unit ;& buildOn Unit
  require Pass files = filesResult
  def cmd =
    which "tar", "--mtime={time}", "--transform=s@^tmp/@wake-{release}/@",
    "--owner=0", "--group=0", "--numeric-owner", "-cJf",
    "wake-static_{release}.tar.xz", map getPathName files | sortBy (_<*_)
  job cmd files | getJobOutput | getPathResult

from test_wake import topic wakeTestBinary
publish wakeTestBinary = defaultWake, Nil

def defaultWake Unit =
    require Pass variant =
        toVariant "default"

    require Pass wakeVisible =
        all variant # build wake to test

    def wakeShare =
        sources "share" `.*`

    require Some wakeBin =
        wakeVisible
        | filter (matches `bin/wake.*` _.getPathName)
        | head
    else
        Fail (makeError "Wake compilation did not produce an executable to test!")

    Pass (Pair wakeBin.getPathName (wakeVisible ++ wakeShare))

