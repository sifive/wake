global x . f = f x
global f $ x = f x

# exceptions
def test     x = prim "test"
def catch    x = prim "catch"
global try f x = if test x then f (catch x) else x
global raise x = prim "raise"

# bools
global true  x y = x
global false x y = y
global !x = x false true
global x & y = x y x # both sides are evaluated
global x | y = x x y

# tuples
global pair first second = _ first second
global first  p = p true
global second p = p false

# lists
global head, tail = _ head tail
global nil _ = true
global empty l = l (\_\_ false)
global head l = if l.empty then raise "empty list" else l.first
global tail l = if l.empty then raise "empty list" else l.second

# list transforms
global map   f   l = if l.empty then nil else f l.head, map f l.tail
global foldl f a l =     if l.empty then a   else foldl f (f a l.head) l.tail
global scanl f a l = a, (if l.empty then nil else scanl f (f a l.head) l.tail)
global foldr f a l =     if l.empty then a   else f l.head (foldr f a l.tail)
global scanr f a l =
  if l.empty then a, nil else
    def finish r = f l.head r.head, r
    finish (scanr f a l.tail)

# list helpers
global l ++ r    = foldr (_,_) r l
global reverse l = foldl (\a\b b,a) nil l
global flatten l = foldr (_++_) nil l
global len l     = foldl (\a\_ a+1) 0 l

# list choppers
global splitAt i l =
  if i <= 0 | l.empty then pair nil l else
    def finish r = pair (l.head, r.first) r.second
    finish (splitAt (i-1) l.tail)

global take i l = (splitAt i l).first
global drop i l = (splitAt i l).second
global at   i l = if i < 0 then raise "at called with negative index" else (drop i l).head

global splitUntil f l =
  if l.empty then pair nil l else
    if f l.head then pair nil l else
      def finish r = pair (l.head, r.first) r.second
      finish (splitUntil f l.tail)

global takeUntil f l = (splitUntil f l).first
global dropUntil f l = (splitUntil f l).second
global find f l = take 1 (dropUntil f l)
global exists f l = !empty (dropUntil f l)
global forall f l = empty (dropUntil (!f _) l)

global splitBy f l =
  if l.empty then pair nil nil else
    def finish r =
      if f l.head
      then pair (l.head, r.first) r.second
      else pair r.first (l.head, r.second)
    finish (splitBy f l.tail)

global filter f l = (splitBy f l).first

# Tranposition is only it's own inverse when the lists have non-increasing size
global transpose l =
  def todo = filter (!_.empty) l
  def heads = map first todo
  def tails = map second todo
  if todo.empty then nil else heads, transpose tails

# f should be a less-than comparison
global sortBy f l =
  if l.empty then nil else
    def key = l.head
    def split = splitBy (f key) l.tail
    sortBy f split.second ++ (key, sortBy f split.first)
global sort l = sortBy (_<_) l

global collate f l r =
  if l.empty
  then
    if r.empty then 0 else -1
  else
    if r.empty then 1 else
      def cmp = f l.head r.head
      if cmp == 0
      then collate f l.tail r.tail
      else cmp

# string operations
global read path = prim "read"
global write path content mode = prim "write"
global getenv key = prim "getenv"
global mkdir path mode = prim "mkdir"
global format any = prim "format"
global print str = prim "print"
global println str = print "{str}\n"
global dbg any = print (format any)
global cat l =
  def catopen    = prim "catopen"
  def catclose c = prim "catclose"
  def catadd c s = prim "catadd"
  catclose (foldl catadd catopen l)
global catWith s l =
  if l.empty then "" else
    def inserted = foldr (s, _, _) nil l
    cat (inserted.tail)

# integer operations
global +x = x
global -x = prim "neg"
global ~x = prim "com"
global x + y = prim "add"
global x - y = prim "sub"
global x * y = prim "mul"
global x / y = prim "div"
global x % y = prim "mod"
global x << y = prim "shl"
global x >> y = prim "shr"
global x ^ y = prim "exp"
global root x n = (\_\_ prim "root") n x
global sqrt x = root 2 x
global abs x = prim "abs"
global xor x y = prim "xor"
global and x y = prim "and"
global or  x y = prim "or"
global gcd x y = prim "gcd"
global lcm x y = prim "lcm"
global powm x y m = prim "powm" # fast version of: (x^y) % m

global seq n =
  def helper i = if i >= n then nil else i, helper (i+1)
  helper 0

# Type conversion
global strbase base n = prim "str" # int -> string
global intbase base s = prim "int" # string -> int
global str n = strbase 10 n
global int s = intbase 0 s

# Comparison operators for integers and strings
global x <  y = prim "lt"
global x >  y = y < x
global x >= y = !(x < y)
global x <= y = !(y < x)
global x == y = prim "eq"
global x != y = !(x == y)
global cmp x y = prim "cmp" # lt=-1, eq=0, gt=1

# Regular expressions
global quote s = prim "quote" # str -> str  (quoted for use in a regexp)
global match r =              # regexp str -> bool
  def compile r = prim "re2"
  def match r s = prim "match"
  match (compile r)
global extract r =            # regexp-with-(exp)s str -> str list
  def compile r = prim "re2"
  def extract r s = prim "extract"
  extract (compile r)
global replace r =            # regexp replacement str -> str
  def compile r = prim "re2"
  def replace r s t = prim "replace"
  replace (compile r)
global tokenize r =            # regexp seperator str -> str list
  def compile r = prim "re2"
  def tokenize r s = prim "tokenize"
  tokenize (compile r)

# Private implementation of global sources
def add_sources str = prim "add_sources"
def implode l = cat (foldr (_, "\0", _) nil l)
def got_sources = add_sources (subscribe source).implode # returns true

# Find sources files
global sources dir regexp =
  def scan dir regexp = prim "sources"
  if got_sources then scan dir regexp else nil # force dependency on add_sources

# Operate on paths
global simplify path = prim "simplify"
global relative dir path = prim "relative"
global whichIn path exec = prim "search_path"
global which exec = whichIn path exec
global workspace = prim "getcwd"
def wakepath = prim "execpath"
global version = prim "version"

# The internal function operates on imploded strings, not lists
def primjob pool root dir stdin env cmd = prim "job_launch"
def oncejob root dir stdin env cmd = memoize primjob 1 root dir stdin env cmd
def primcache dir stdin env cmd visible = prim "job_cache"
def oncecache dir stdin env cmd visible = memoize primcache dir stdin env cmd visible

global jobcache build dir stdin env cmd visible =
  def cache = oncecache dir stdin env.implode cmd.implode visible.implode
  if test cache then build 0 else
    def out = wrap cache
    def notOk pair = hashcode pair.first != pair.second
    def bad = find notOk out.outputs
    if bad.empty then out else
      def file = bad.head.first
      def expect = hashcode file
      def saw = bad.head.second
      raise "Hash mismatch for {file} ({saw} != {expect}); remove it or run with -f"

# Launch a job, raw interface
# If you use this API, you MUST also run 'finish' on the result AFTER status is available
#   root:  fake root directory
#   dir:   directory where the command should be run
#   stdin: file to attach to standard input ("" = nothing)
#   env:   string list of all environement variables in the form key=value
#   cmd:   string list of command arguments (head is the full path to the command)
global launch root dir stdin env cmd = wrap (oncejob root dir stdin env.implode cmd.implode)

def fail job ok =
  if job.status == 0 then ok else
    raise "Non-zero exit status {str job.status})"

# Access the output of a job
def wrap result =
  def output  r f   = prim "job_output" # 1=stdout, 2=stderr; blocks till closed
  def kill    r s   = prim "job_kill"   # s != 0 => kills; blocks till exit; return status
  def finish  r i o = prim "job_finish" # ignored except on first call; blocks till exit; returns true
  def tree    r i   = prim "job_tree"   # 0=visible, 1=input, 2=output; blocks till finished
  _ output kill finish tree $ result
def    stdio   job = job (\x\_\_\_ x)
def    tree    job = job (\_\_\_\x x)
global kill    job = job (\_\x\_\_ x)
global status  job = kill job 0
global stdout  job = stdio job 1
global stderr  job = stdio job 2
global inputs  job = fail job (tree job 1)
global outputs job = fail job (tree job 2)
global output  job =
  def got = outputs job
  def num = got.len
  if      num == 1 then got.head.first
  else if num == 0 then raise "no outputs available"
  else                  raise "more than one output found"

# Complete a job, marking done and recording used inputs/outputs
global finish job inputs outputs = job (\_\_\x\_ x) inputs.implode outputs.implode

global hashpair f = memoize ( # pair file hash
  def job = launch "." "." "" nil (which "md5sum", f, nil)
  def final _ = finish job nil nil
  def wait = (job.status == 0) final final ""
  def add f h = prim "add_hash"
  if job.status == 0 then add f (head (extract '(.{32}).*' job.stdout)) else job.stderr
)
global hashname f = (hashpair f).first  # just the filename
global hashcode f = (hashpair f).second # just the hashcode

# A job where all inputs and outputs are known a-priori
global uncached_simple_job dir stdin env cmd inputs outputs =
  def job = launch "." dir stdin env cmd
  def final _ = finish job (map hashname inputs) (map hashname outputs)
  def wait = (job.status == 0) final final ""
  job

global cached_simple_job dir stdin env cmd inputs outputs =
  def build _ = uncached_simple_job dir stdin env cmd inputs outputs
  jobcache build dir stdin env cmd (map hashname inputs)

# Still not caching, just hermetic
def fusepath = relative workspace (simplify "{wakepath}/../lib/wake/fuse-wake")
global uncached_fuse_job dir stdin env cmd files dirs = memoize (
  def visible = map hashname files ++ (dir, dirs)
  def fuse = wrap (primjob 0 "." "." "" "" (fusepath, visible).implode)
  def endfuse _ = finish fuse nil nil
  def waitfuse = (fuse.status == 0) endfuse endfuse ""
  def err = fuse.stderr
  def handle _ = raise "Could not start fuse-wake: {err}"
  def list = try handle (extract 'OK: (.*)' err)
  def job = launch list.head dir stdin env cmd
  def final _ = # run once job exits
    def status = kill fuse 14 # SIGALRM
    def result = extract "(.*\0)\0(.*)" fuse.stdout
    def inputs = (tokenize "\0" (at 0 result)).reverse.tail
    def outputs = (tokenize "\0" (at 1 result)).reverse.tail
    finish job inputs (map hashname outputs)
  def wait = (job.status == 0) final final ""
  job
)

global cached_fuse_job dir stdin env cmd files dirs =
  def build _ = uncached_fuse_job dir stdin env cmd files dirs
  jobcache build dir stdin env cmd (map hashname files)

# Setup a default path
publish path = "/usr/bin"
publish path = "/bin"

global path = catWith ":" (subscribe path)
publish environment = "PATH={path}"

# Most jobs don't need explicit stdin/env control
global environment = map (_) (subscribe environment)
global job cmd files dirs = cached_fuse_job "." "" environment cmd files dirs
global simple_job cmd inputs outputs = cached_simple_job "." "" environment cmd inputs outputs
