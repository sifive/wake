global def x . f = f x
global def f $ x = f x

# exceptions
def test  x = prim "test"
def catch x = prim "catch"
global def try f x = if test x then f (catch x) else x
global def raise x = prim "raise"

# bools
global data Bool =
  True
  False

global def !x    = Bool (\_ False) (\_ True) x
global def x & y = Bool (\_ y) (\_ False) x
global def x | y = Bool (\_ True) (\_ y) x

# tuples
global data Pair a b =
  PPair a b

global def pair x y = PPair x y
global def first  = Pair (\_\x\_ x) _
global def second = Pair (\_\_\x x) _

# lists
global data List a =
  Nil
  a, (List a)

global def empty = List (\_ True) (\_\_\_ False) _

global def head l =
  def nil  _     = raise "empty list"
  def cons _ h t = h
  List nil cons l

global def tail l =
  def nil  _     = raise "empty list"
  def cons _ h t = t
  List nil cons l

global def map f l =
  def nil  _     = Nil
  def cons _ a t = f a, map f t
  List nil cons l

global def foldl f a l =
  def nil  _     = a
  def cons _ h t = foldl f (f a h) t
  List nil cons l

global def scanl f a l =
  def nil  _     = Nil
  def cons _ h t = scanl f (f a h) t
  a, List nil cons l

global def foldr f a l =
  def nil  _     = a
  def cons _ h t = f h (foldr f a t)
  List nil cons l

global def scanr f a l =
  def nil  _     = a, Nil
  def cons _ h t =
    def finish r = f h r.head, r
    finish (scanr f a t)
  List nil cons l

# list helpers
global def l ++ r    = foldr (_,_) r l
global def reverse l = foldl (\a\b b,a) Nil l
global def flatten l = foldr (_++_) Nil l
global def len l     = foldl (\a\_ a+1) 0 l

# list choppers
global def splitAt i l =
  if i <= 0 then pair Nil l else
    def nil  _     = pair Nil l
    def cons _ h t = Pair (\_\f\s pair (h, f) s) (splitAt (i-1) t)
    List nil cons l

global def take i l = (splitAt i l).first
global def drop i l = (splitAt i l).second
global def at   i l = if i < 0 then raise "at called with negative index" else (drop i l).head

global def splitUntil f l =
  def nil  _     = pair Nil l
  def cons _ h t = if f h then pair Nil l else Pair (\_\f\s pair (h, f) s) (splitUntil f t)
  List nil cons l

global def takeUntil f l = (splitUntil f l).first
global def dropUntil f l = (splitUntil f l).second
global def find f l = take 1 (dropUntil f l)
global def exists f l = !empty (dropUntil f l)
global def forall f l = empty (dropUntil (!f _) l)

global def splitBy f l =
  def nil  _     = pair Nil Nil
  def cons _ h t =
    def finish _ x y =
      if f h
      then pair (h, x) y
      else pair x (h, y)
    Pair finish (splitBy f t)
  List nil cons l

global def filter f l = (splitBy f l).first

# Tranposition is only it's own inverse when the lists have non-increasing size
global def transpose l =
  def todo = filter (!_.empty) l
  def heads = map head todo
  def tails = map tail todo
  if todo.empty then Nil else heads, transpose tails

# f should be a less-than comparison
global def sortBy f l =
  def nil  _     = Nil
  def cons _ h t =
    Pair (\_\x\y sortBy f y ++ (h, sortBy f x)) (splitBy (f h) t)
  List nil cons l

global def sort l = sortBy (_<_) l

global def collate f l r =
  def nil  _     =
    def nil  _       = 0
    def cons _ rh rt = -1
    List nil cons r
  def cons _ lh lt =
    def nil  _       = 1
    def cons _ rh rt =
      def cmp = f lh rh
      if cmp == 0 then collate f lt rt else cmp
    List nil cons r
  List nil cons l

# global def collate f = match _ _
#   Nil     Nil     =  0
#   Nil     _       = -1
#   _       Nil     =  1
#   (lh,lt) (rh,rt) =
#     def cmp = f lh rh
#     if cmp == 0 then collate f lr rt else cmp

# string operations
global def read path = prim "read"
global def write path content mode = prim "write"
global def getenv key = prim "getenv"
global def mkdir path mode = prim "mkdir"
global def format any = prim "format"
global def print str = prim "print"
global def println str = print "{str}\n"
global def dbg any = print (format any)
global def cat l =
  def catopen    = prim "catopen"
  def catclose c = prim "catclose"
  def catadd c s = prim "catadd"
  catclose (foldl catadd catopen l)
global def catWith s l =
  if l.empty then "" else
    def inserted = foldr (s, _, _) Nil l
    cat (inserted.tail)

# integer operations
global def +x = x
global def -x = prim "neg"
global def ~x = prim "com"
global def x + y = prim "add"
global def x - y = prim "sub"
global def x * y = prim "mul"
global def x / y = prim "div"
global def x % y = prim "mod"
global def x << y = prim "shl"
global def x >> y = prim "shr"
global def x ^ y = prim "exp"
global def root x n = (\_\_ prim "root") n x
global def sqrt x = root 2 x
global def abs x = prim "abs"
global def xor x y = prim "xor"
global def and x y = prim "and"
global def or  x y = prim "or"
global def gcd x y = prim "gcd"
global def lcm x y = prim "lcm"
global def powm x y m = prim "powm" # fast version of: (x^y) % m

global def seq n =
  def helper i = if i >= n then Nil else i, helper (i+1)
  helper 0

# Type conversion
global def strbase base n = prim "str" # int -> string
global def intbase base s = prim "int" # string -> int
global def str n = strbase 10 n
global def int s = intbase 0 s

# Comparison operators for integers and strings
global def x <  y = prim "lt"
global def x >  y = y < x
global def x >= y = !(x < y)
global def x <= y = !(y < x)
global def x == y = prim "eq"
global def x != y = !(x == y)
global def cmp x y = prim "cmp" # lt=-1, eq=0, gt=1

# Regular expressions
global def quote s = prim "quote" # str -> str  (quoted for use in a regexp)
global def match r =              # regexp str -> bool
  def compile r = prim "re2"
  def match r s = prim "match"
  match (compile r)
global def extract r =            # regexp-with-(exp)s str -> str list
  def compile r = prim "re2"
  def extract r s = prim "extract"
  extract (compile r)
global def replace r =            # regexp replacement str -> str
  def compile r = prim "re2"
  def replace r s t = prim "replace"
  replace (compile r)
global def tokenize r =            # regexp seperator str -> str list
  def compile r = prim "re2"
  def tokenize r s = prim "tokenize"
  tokenize (compile r)

# Private implementation of global sources
def add_sources str = prim "add_sources"
def implode l = cat (foldr (_, "\0", _) Nil l)
def got_sources = add_sources (subscribe source).implode # returns true

# Find sources files
global def sources dir regexp =
  def scan dir regexp = prim "sources"
  if got_sources then scan dir regexp else Nil # force dependency on add_sources

# Operate on paths
global def simplify path = prim "simplify"
global def relative dir path = prim "relative"
global def whichIn path exec = prim "search_path"
global def which exec = whichIn path exec
global def workspace = prim "getcwd"
def wakepath = prim "execpath"

# The internal function operates on imploded strings, not lists
def primjob pool root dir stdin env cmd = prim "job_launch"
def oncejob root dir stdin env cmd = memoize primjob 1 root dir stdin env cmd
def primcache dir stdin env cmd visible = prim "job_cache"
def oncecache dir stdin env cmd visible = memoize primcache dir stdin env cmd visible

global def jobcache build dir stdin env cmd visible =
  def cache = oncecache dir stdin env.implode cmd.implode visible.implode
  if test cache then build 0 else
    def out = cache
    def notOk pair = hashcode pair.first != pair.second
    def bad = find notOk out.outputs
    if bad.empty then out else
      def file = bad.head.first
      def expect = hashcode file
      def saw = bad.head.second
      raise "Hash mismatch for {file} ({saw} != {expect}); remove it or run with -f"

# Launch a job, raw interface
# If you use this API, you MUST also run 'finish' on the result AFTER status is available
#   root:  fake root directory
#   dir:   directory where the command should be run
#   stdin: file to attach to standard input ("" = nothing)
#   env:   string list of all environement variables in the form key=value
#   cmd:   string list of command arguments (head is the full path to the command)
global def launch root dir stdin env cmd = oncejob root dir stdin env.implode cmd.implode

def fail job ok =
  if job.status == 0 then ok else
    raise "Non-zero exit status {str job.status})"

# Access the output of a job
def stdio job fd  = prim "job_output" # 1=stdout, 2=stderr; blocks till closed
def tree  job typ = prim "job_tree"   # 0=visible, 1=input, 2=output; blocks till finished
global def kill    job signal = prim "job_kill" # s != 0 => kills; blocks till exit; return status
global def status  job = kill  job 0
global def stdout  job = stdio job 1
global def stderr  job = stdio job 2
global def inputs  job = fail job (tree job 1)
global def outputs job = fail job (tree job 2)
global def output  job =
  def got = outputs job
  def num = got.len
  if      num == 1 then got.head.first
  else if num == 0 then raise "no outputs available"
  else                  raise "more than one output found"

# Complete a job, marking done and recording used inputs/outputs
global def finish job inputs outputs =
  def imp job inputs outputs = prim "job_finish" # ignored except on first call; blocks till exit; returns true
  imp job inputs.implode outputs.implode

global def hashpair f = memoize ( # pair file hash
  def job = launch "." "." "" Nil (which "md5sum", f, Nil)
  def final _ = finish job Nil Nil
  def wait = if job.status == 0 then final else final
  def add f h = prim "add_hash"
  if job.status == 0 then add f (head (extract '(.{32}).*' job.stdout)) else raise "Hashing failed"
)
global def hashname f = (hashpair f).first  # just the filename
global def hashcode f = (hashpair f).second # just the hashcode

# A job where all inputs and outputs are known a-priori
global def uncached_simple_job dir stdin env cmd inputs outputs =
  def job = launch "." dir stdin env cmd
  def final _ = finish job (map hashname inputs) (map hashname outputs)
  def wait = if job.status == 0 then final else final
  job

global def cached_simple_job dir stdin env cmd inputs outputs =
  def build _ = uncached_simple_job dir stdin env cmd inputs outputs
  jobcache build dir stdin env cmd (map hashname inputs)

# Still not caching, just hermetic
def fusepath = relative workspace (simplify "{wakepath}/../lib/wake/fuse-wake")
global def uncached_fuse_job dir stdin env cmd files dirs = memoize (
  def visible = map hashname files ++ (dir, dirs)
  def fuse = primjob 0 "." "." "" "" (fusepath, visible).implode
  def endfuse _ = finish fuse Nil Nil
  def waitfuse = if fuse.status == 0 then endfuse else endfuse
  def err = fuse.stderr
  def handle _ = raise "Could not start fuse-wake: {err}"
  def list = try handle (extract 'OK: (.*)' err)
  def job = launch list.head dir stdin env cmd
  def final _ = # run once job exits
    def status = kill fuse 14 # SIGALRM
    def result = extract "(.*\0)\0(.*)" fuse.stdout
    def inputs = (tokenize "\0" (at 0 result)).reverse.tail
    def outputs = (tokenize "\0" (at 1 result)).reverse.tail
    finish job inputs (map hashname outputs)
  def wait = if job.status == 0 then final else final
  job
)

global def cached_fuse_job dir stdin env cmd files dirs =
  def build _ = uncached_fuse_job dir stdin env cmd files dirs
  jobcache build dir stdin env cmd (map hashname files)

# Setup a default path
publish path = "/usr/bin"
publish path = "/bin"

global def path = catWith ":" (subscribe path)
publish environment = "PATH={path}"

# Most jobs don't need explicit stdin/env control
global def environment = subscribe environment
global def job cmd files dirs = cached_fuse_job "." "" environment cmd files dirs
global def simple_job cmd inputs outputs = cached_simple_job "." "" environment cmd inputs outputs
