# Copyright 2024 SiFive, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You should have received a copy of LICENSE.Apache2 along with
# this software. If not, you may obtain a copy at
#
#    https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# TODO: change this to package remote_cache and deal with all the churn
package wake

from http import _

# Configuration details required to connect to the remote shared cache.
export tuple RemoteCacheApi =
    # The domain or ip address of the cache
    export Domain: String
    # The port serving the cache
    export Port: Integer
    # The api key required for authenicated routes. Not required for all requests
    export Authorization: Option String

## --- POST /job/matching types ---

# A request to the remote server to check if a job is cached
tuple CacheSearchRequest =
    # The label for the job. Not part of the key, used only for inspection
    Label: String
    # The command line of the job
    Cmd: List String
    # The directory of the job
    Cwd: String
    # The environment of the job
    Env: List String
    # User provided string to mark two jobs as different even if wake considers them the same
    HiddenInfo: String
    # If the job was ran as if a user was running it from a terminal
    IsAtty: Boolean
    # The stdin of the job
    Stdin: String
    # The list of files the job is allowed to read in the sandbox
    VisibleFiles: List Path

# A downloadable blob returned from the remote shared cache
tuple CacheSearchBlob =
    # The id of the blob on the remote server
    Id: String
    # The uri where the blob may be downloaded from. Not guaranteed to be http/https
    Uri: String

# A file backed by a blob that a cached job created
tuple CacheSearchOutputFile =
    # The path on disk of the file
    Path: String
    # The mode on disk of the file
    Mode: Integer
    # The description of how to download the files contents
    Blob: CacheSearchBlob

# A directory created by a cached job
tuple CacheSearchOutputDirectory =
    # The path on disk of the directory
    Path: String
    # The mode on disk of the directory
    Mode: Integer

# A symlink created by a cached job
tuple CacheSearchOutputSymlink =
    # The path on disk of the symlink
    Path: String
    # The file being linked to
    Link: String

# A match response from the server. Specifies all details of a cached job
tuple CacheSearchResponseMatch =
    # The symlinks that were output by the job
    OutputSymlinks: List CacheSearchOutputSymlink
    # The directories that were output by the job
    OutputDirs: List CacheSearchOutputDirectory
    # The files that were output by the job
    OutputFiles: List CacheSearchOutputFile
    # The stdout of the job
    StdoutBlob: CacheSearchBlob
    # The stderr of the job
    StderrBlob: CacheSearchBlob
    # The code that the job return on exit
    Status: Integer
    # The total runtime of the job
    Runtime: Double
    # The total cputime of the job
    Cputime: Double
    # The total memory of the job
    Memory: Integer
    # The number of bytes read by the job
    IBytes: Integer
    # The number of bytes written by the job
    OBytes: Integer

# A response from the server to a CacheSearchRequest
data CacheSearchResponse =
    # The job was not found on the remote server
    NoMatch
    # The job was found on the remote server
    Match CacheSearchResponseMatch

## --- POST /job types ---

# A file created by a job and uploaded to the server as a blob
tuple CachePostRequestOutputFile =
    # The path on disk of the file
    Path: String
    # The mode on disk of the file
    Mode: Integer
    # The blob id returned by the server from the blob upload
    BlobId: String

# A directory created by a job
tuple CachePostRequestOutputDirectory =
    # The path on disk of the directory
    Path: String
    # The mode on disk of the directory
    Mode: Integer

# A symlink created by a job
tuple CachePostRequestOutputSymlink =
    # The path on disk of the symlink
    Path: String
    # The file being linked to
    Link: String

# A request to the remote server to cache a job
tuple CachePostRequest =
    # The label for the job. Not part of the key, used only for inspection
    Label: String
    # The command line of the job
    Cmd: List String
    # The directory of the job
    Cwd: String
    # The environment of the job
    Env: List String
    # User provided string to mark two jobs as different even if wake considers them the same
    HiddenInfo: String
    # If the job was ran as if a user was running it from a terminal
    IsAtty: Boolean
    # The stdin of the job
    Stdin: String
    # The list of files the job is allowed to read in the sandbox
    VisibleFiles: List Path
    # The directories that were output by the job
    OutputDirs: List CachePostRequestOutputDirectory
    # The symlinks that were output by the job
    OutputSymlinks: List CachePostRequestOutputSymlink
    # The files that were output by the job
    OutputFiles: List CachePostRequestOutputFile
    # The blob id returned from the server for the stdout of the job
    StdoutBlobId: String
    # The blob id returned from the server for the stderr of the job
    StderrBlobId: String
    # The code that the job return on exit
    Status: Integer
    # The total runtime of the job
    Runtime: Double
    # The total cputime of the job
    Cputime: Double
    # The total memory of the job
    Memory: Integer
    # The number of bytes read by the job
    IBytes: Integer
    # The number of bytes written by the job
    OBytes: Integer

# makeRemoteCacheApi: Parses config string into RemoteCacheApi
#
# ```
#  makeRemoteCacheApi "local:1234:myauth" = Pass (RemoteCacheApi "local" 1234 (Some "myauth"))
#  makeRemoteCacheApi "local:1234:" = Pass (RemoteCacheApi "local" 1234 None)
#  makeRemoteCacheApi "local:1234" = Fail (...)
#  makeRemoteCacheApi "local" = Fail (...)
#  makeRemoteCacheApi "local:asdf:myauth" = Fail (...)
# ```
export def makeRemoteCacheApi (config: String): Result RemoteCacheApi Error =
    require (domain, portStr, authStr, Nil) =
        config
        | tokenize `:`
    else
        failWithError
        "Remote cache config was set with incorrect format. Saw: '{config}'. Expected 'domain:port:auth' (auth may be omitted)"

    require Some (port) =
        portStr
        | int
    else failWithError "Remote cache config was set with non-integer port. Saw: {portStr}"

    def auth = if authStr ==* "" then None else Some authStr
    def api = RemoteCacheApi domain port auth

    # When in debug mode, allow server incompatible version.
    def overrideOnDebugCache check =
        require Fail err = check
        else check

        require Some _ = getenv "DEBUG_WAKE_SHARED_CACHE"
        else check

        printlnLevel
        logWarning
        "RSC client is incompatable with server but continuing due to DEBUG enabled. Reason: {format err}"
        | Pass

    # If the client isn't compatiable with the server then give up on the cache
    require Pass Unit =
        api
        | rscApiCheckClientVersion "sifive/wake/{version}"
        | overrideOnDebugCache

    # If auth is not set we are done. Just return the api
    require Some _ = auth
    else Pass api

    # Auth was set so it must be validated.
    api
    | rscApiCheckAuthorization
    | rmap (\_ api)

# rscApiPostStringBlob: Posts a named string as a blob to the remote server defined by *api*
#                       then returns the id associated to the blob. Requires authorization.
#
# ```
#  api | rscApiPostStringBlob "foo" "my foo contents" = Pass "asdf-fdsa-asdf-fdsa"
#  (RemoteCacheApi "foo" 1 None) | rscApiPostStringBlob "foo" "my foo contents" = Fail "authorization required"
# ```
export def rscApiPostStringBlob (name: String) (value: String) (api: RemoteCacheApi): Result String Error =
    def contentType =
        if value.strlen < 95 then
            Some "blob/small"
        else
            None

    require Pass temp = writeTempFile name value

    uploadBlobRequest api (addFormData name temp contentType)

# rscApiPostFileBlob: Posts a named file on disk to the remote server defined by *api*
#                     then returns the id associated to the blob. Requires authorization.
#
# ```
#  api | rscApiPostFileBlob "foo" "/some/path/to/foo" = Pass "asdf-fdsa-asdf-fdsa"
#  (RemoteCacheApi "foo" 1 None) | rscApiPostFileBlob "foo" "/some/path/to/foo" = Fail "authorization required"
# ```
export def rscApiPostFileBlob (name: String) (file: String) (api: RemoteCacheApi): Result String Error =
    # We must use unsafe here since we cannot elevate *file* to a Path without either copying it
    # or triggering the 'job output by multiple files' error.
    uploadBlobRequest api (unsafe_addFormData name file None)

# rscApiPostJob: Posts a job defined by *req* to the remote cache server. Requires authorization.
#
# ```
#  api | rscApiPostJob (CachePostRequest ...) = Pass Unit
#  (RemoteCacheApi "foo" 1 None) | rscApiPostJob (CachePostRequest ...) = Fail "authorization required"
# ```
export def rscApiPostJob (req: CachePostRequest) (api: RemoteCacheApi): Result Unit Error =
    require Some auth = api.getRemoteCacheApiAuthorization
    else failWithError "rsc: Posting a job requires authorization but none was provided"

    def jsonStr =
        req
        | getCachePostRequestJson
        | formatJSON

    def _ =
        require True = shouldDebugRemoteCache Unit

        def _ =
            writeTempFile "remote.cache.api.postJob.req" "label: {req.getCachePostRequestLabel}\nreq: {jsonStr}"

        True

    require Pass response =
        makeRoute api "job"
        | buildHttpRequest
        | setMethod HttpMethodPost
        | addContentTypeJsonHeader
        | addAuthorizationHeader auth
        | setBody jsonStr
        | makeRequest

    def _ =
        require True = shouldDebugRemoteCache Unit

        def _ =
            writeTempFile
            "remote.cache.api.postJob.res.{response.getHttpResponseStatusCode | format}"
            "label: {req.getCachePostRequestLabel}\nres: {response | format}"

        True

    require (Some 200) = response.getHttpResponseStatusCode
    else failWithError "rsc: post job failed with code {response.getHttpResponseStatusCode | format}"

    Pass Unit

# rscApiFindMatchingJob: Searches the remote server defined by *api* for a cached job that matches 
#                        the job key provided by *req*. Returns a response that may or may not have
#                        the matching job. Does not require authorization.
#
# ```
#  api | rscApiFindMatchingJob (CacheSearchRequest ...) = Pass (CacheSearchResponse ...)
# ```
export def rscApiFindMatchingJob (req: CacheSearchRequest) (api: RemoteCacheApi): Result CacheSearchResponse Error =
    def jsonStr =
        req
        | getCacheSearchRequestJson
        | formatJSON

    def _ =
        require True = shouldDebugRemoteCache Unit

        def _ =
            writeTempFile
            "remote.cache.api.findJob.req"
            "label: {req.getCacheSearchRequestLabel}\nreq: {jsonStr}"

        True

    require Pass response =
        makeRoute api "job/matching"
        | buildHttpRequest
        | setMethod HttpMethodPost
        | addContentTypeJsonHeader
        | setBody jsonStr
        | makeRequest

    def _ =
        require True = shouldDebugRemoteCache Unit

        def _ =
            writeTempFile
            "remote.cache.api.findJob.res.{response.getHttpResponseStatusCode | format}"
            "label: {req.getCacheSearchRequestLabel}\nres: {response | format}"

        True

    require Pass json =
        response.getHttpResponseBody.parseJSONBody
        | addErrorContext "rsc: http body contains invalid JSON"

    mkCacheSearchResponse json

# rscApiCheckClientVersion: Checks if the client version is compatiable with the server. 
#
# ```
#  api | rscApiCheckClientVersion "sifive/wake/1.2.3 = Pass Unit
# ```
export def rscApiCheckClientVersion (version: String) (api: RemoteCacheApi): Result Unit Error =
    require Pass response =
        makeRoute api "version/check?version={version}"
        | buildHttpRequest
        | setMethod HttpMethodGet
        | makeRequest

    match response.getHttpResponseStatusCode
        Some 200 -> Pass Unit
        Some x -> failWithError "Incompatiable client. Status code: {str x}"
        None -> failWithError "Incompatiable client. Unable to determine status code"

# rscApiCheckAuthorization: Checks if the provided authorization key is valid.
#
# ```
#  api | rscApiCheckAuthorization = Pass Unit
# ```
export def rscApiCheckAuthorization (api: RemoteCacheApi): Result Unit Error =
    require Some auth = api.getRemoteCacheApiAuthorization
    else failWithError "rsc: Checking authorization requires authorization but none was provided"

    require Pass response =
        makeRoute api "auth/check"
        | buildHttpRequest
        | setMethod HttpMethodPost
        | addAuthorizationHeader auth
        | makeRequest

    match response.getHttpResponseStatusCode
        Some 200 -> Pass Unit
        Some x -> failWithError "Invalid auth key. Status code: {str x}"
        None -> failWithError "Invalid auth key. Unable to determine status code"

# rscApiGetStringBlob: Downloads a blob and returns the contents as a string 
#
# ```
#  rscApiGetStringBlob (RemoteCacheBlob "asdf" "https://...") = Pass "foo\nbar\nbat" 
# ```
export def rscApiGetStringBlob ((CacheSearchBlob _ uri): CacheSearchBlob): Result String Error =
    require scheme, path, Nil = extract `([a-zA-Z][a-zA-Z0-9+.-]*)://(.*)` uri
    else failWithError "rsc: uri has unexpected format: '{uri}'"

    # maps path = "%46%6F%6F" to content = "foo"
    def dbScheme _scheme path =
        # If path is empty we have the empty string
        require True = path.strlen > 0
        else Pass ""

        # If not empty then it must as least be %00
        require True = path.strlen >= 3
        else failWithError "rsc: Invalid db path: '{path}'"

        require "", byteStrs = tokenize `%` path
        else failWithError "rsc: Failed to extract bytes from db path: '{path}'"

        require Some bytes =
            byteStrs
            | map (intbase 16)
            | findNone
        else failWithError "rsc: Failed to parse bytes strings into bytes from db path: '{path}'"

        bytes
        # TODO: this only supports ASCII, not unicode. This needs to be enforced somewhere.
        | map integerToByte
        | cat
        | Pass

    def fileScheme scheme path =
        require Pass response =
            buildHttpRequest "{scheme}://{path}"
            | setMethod HttpMethodGet
            | makeRequest

        Pass response.getHttpResponseBody

    def unsupportedScheme scheme path =
        failWithError "rsc: scheme '{scheme}' from uri '{uri}' is not supported"

    def schemeFn = match scheme
        "db" -> dbScheme
        "file" -> fileScheme
        "http" -> fileScheme
        "https" -> fileScheme
        _ -> unsupportedScheme

    schemeFn scheme path

# rscApiGetFileBlob: Downloads a blob to *path* with *mode* permisssions and return *path*
#
# ```
#  rscApiGetFileBlob (RemoteCacheBlob "asdf" "https://...") "foo/bar" 0644 = Pass "foo/bar" 
# ```
export def rscApiGetFileBlob ((CacheSearchBlob _ uri): CacheSearchBlob) (path: String) (mode: Integer): Result String Error =
    # TODO: use "small blob" for this and also parse the schema out
    # require False = id ==* "00000000-0000-0000-0000-000000000000"
    # else Pass  ""

    require Pass downloadPath =
        buildHttpRequest uri
        | setMethod HttpMethodGet
        | makeBinaryRequest

    def fixupScript =
        """
        # 1. No failures are acceptable
        set -e
        # 2. Hardlink the file to not use 2x disk space
        cp -l %{downloadPath.getPathName} '%{path}.rsctmp'
        # 3. Set the permissions as specified
        chmod %{mode | strOctal} '%{path}.rsctmp'
        # 4. If the file was previously created with the exact inode by the rsc but not cleaned up
        #    then it needs to be removed so we can complete the atomic mv
        [ '%{path}.rsctmp' -ef '%{path}' ] && rm '%{path}'
        # 5. Atomically move so interruptions don't effect the build.
        mv -f '%{path}.rsctmp' '%{path}'
        """

    def job =
        makeShellPlan fixupScript (downloadPath, Nil)
        | setPlanLabel "rsc: fixup blob {path} from {downloadPath.getPathName}"
        | setPlanPersistence Once
        # We need to copy the file over another jobs output space so:
        #   - We must run with the localRunner
        #   - We must lie and say we output nothing
        #   - The *path* must be listed as another jobs output to be available to the system 
        | setPlanFnOutputs (\_ Nil)
        | runJobWith localRunner

    require True = job.isJobOk
    else failWithError "Failed to cleanup downloaded file {path} from {downloadPath.getPathName}"

    Pass path

## --- Helper functions ---

# strToBytes "foo" = (13, 14, 15, Nil)
def strToBytes (str: String): List Integer =
    str
    | explode
    # FIXME: unicodeToInteger may return values larger than u8 which will break the serialization
    | map (unicodeToInteger _)

# listFlattenWithNull ((1,2,3,), (4,5,6,), (7,8,9,),) = (1,2,3,0,4,5,6,0,7,8,9,0,)
def listFlattenWithNull (parts: List (List Integer)): List Integer =
    foldr (\x \acc x ++ (0, acc)) Nil parts

# asBytesDelimedByNull ("a", "b", "cd",) = (15, 0, 16, 0, 17, 18, 0)
def asBytesDelimedByNull (parts: List String): List Integer =
    parts
    | map strToBytes
    | listFlattenWithNull

# getPathAsJson (Path "foo" "asdf") = (JObject ...)
def getPathAsJson (Path path hash) =
    JObject (
        "path" :-> JString path,
        "hash" :-> JString hash,
    )

# Helper function for building the route for the resource
def makeRoute ((RemoteCacheApi domain port _)) (resource: String): String =
    "{domain}:{port | str}/{resource}"

# Helper function for uploading a blob.
def uploadBlobRequest (api: RemoteCacheApi) (setBlob: HttpRequest => HttpRequest): Result String Error =
    require Some auth = api.getRemoteCacheApiAuthorization
    else failWithError "rsc: Posting a blob requires authorization but none was provided"

    require Pass response =
        makeRoute api "blob"
        | buildHttpRequest
        | setMethod HttpMethodPost
        | addAuthorizationHeader auth
        | setBlob
        | makeRequest

    require (Some 200) = response.getHttpResponseStatusCode
    else
        failWithError
        "rsc: failed to upload string as blob with code {response.getHttpResponseStatusCode | format}"

    require Pass json = response.getHttpResponseBody.parseJSONBody

    require Pass (JString "Ok") = jField json "type"
    else failWithError "rsc: failed to upload blob"

    require Pass (JArray blobs) = jField json "blobs"
    else failWithError "rsc: JSON response has incorrect schema for blob upload. (Missing blobs key)"

    def idJVals =
        blobs
        | map (jField _ "id")

    require Pass ids = idJVals.findFail
    else failWithError "rsc: JSON response has incorrect schema for blob upload. (Missing blob ids)"

    require ((JString id), Nil) = ids
    else
        failWithError
        "rsc: JSON response has incorrect schema for blob upload. (Expected only 1 id saw {ids.len.str})"

    Pass id

# Converts a CacheSearchRequest to JSON
def getCacheSearchRequestJson (req: CacheSearchRequest): JValue =
    def (CacheSearchRequest _label cmd cwd env hiddenInfo isAtty stdin visibleFiles) = req

    JObject (
        "cmd" :-> JArray (cmd.asBytesDelimedByNull | map JInteger),
        "cwd" :-> JString cwd,
        "env" :-> JArray (env.asBytesDelimedByNull | map JInteger),
        "hidden_info" :-> JString hiddenInfo,
        "is_atty" :-> JBoolean isAtty,
        "stdin" :-> JString stdin,
        "visible_files" :-> JArray (visibleFiles | map getPathAsJson),
    )

# Converts a CachePostJobRequest to JSON
def getCachePostRequestJson (req: CachePostRequest): JValue =
    def (
        CachePostRequest
        _label
        cmd
        cwd
        env
        hiddenInfo
        isAtty
        stdin
        visibleFiles
        outputDirs
        outputSymlinks
        outputFiles
        stdoutBlobId
        stderrBlobId
        status
        runtime
        cputime
        memory
        ibytes
        obytes
    ) = req

    def mkOutputFileJson (CachePostRequestOutputFile path mode blobId) =
        JObject (
            "path" :-> JString path,
            "mode" :-> JInteger mode,
            "blob_id" :-> JString blobId,
        )

    def mkOutputDirJson (CachePostRequestOutputDirectory path mode) =
        JObject (
            "path" :-> JString path,
            "mode" :-> JInteger mode,
        )

    def mkOutputSymlinkJson (CachePostRequestOutputSymlink path link) =
        JObject (
            "path" :-> JString path,
            "link" :-> JString link,
        )

    JObject (
        "cmd" :-> JArray (cmd.asBytesDelimedByNull | map JInteger),
        "cwd" :-> JString cwd,
        "env" :-> JArray (env.asBytesDelimedByNull | map JInteger),
        "hidden_info" :-> JString hiddenInfo,
        "is_atty" :-> JBoolean isAtty,
        "stdin" :-> JString stdin,
        "visible_files" :-> JArray (visibleFiles | map getPathAsJson),
        "output_dirs" :-> JArray (outputDirs | map mkOutputDirJson),
        "output_symlinks" :-> JArray (outputSymlinks | map mkOutputSymlinkJson),
        "output_files" :-> JArray (outputFiles | map mkOutputFileJson),
        "stdout_blob_id" :-> JString stdoutBlobId,
        "stderr_blob_id" :-> JString stderrBlobId,
        "status" :-> JInteger status,
        "runtime" :-> JDouble runtime,
        "cputime" :-> JDouble cputime,
        "memory" :-> JInteger memory,
        "ibytes" :-> JInteger ibytes,
        "obytes" :-> JInteger obytes,
    )

# Makes a CacheSearchResponse from json if possible
def mkCacheSearchResponse (json: JValue): Result CacheSearchResponse Error =
    require Pass (JString isMatch) = jField json "type"
    else failWithError "rsc: JSON response has incorrect schema. Must have string key 'type'"

    require True = isMatch ==* "Match"
    else Pass NoMatch

    def mkBlob (v: JValue): Result CacheSearchBlob Error =
        require Pass (JString id) = jField v "id"
        else failWithError "rsc: JSON response has incorrect schema. '{v | format}' must have string key 'id'"

        require Pass (JString url) = jField v "url"
        else failWithError "rsc: JSON response has incorrect schema. '{v | format}' must have string key 'url'"

        CacheSearchBlob id url
        | Pass

    require Pass stdoutBlobF = jField json "stdout_blob"
    else failWithError "rsc: JSON response has incorrect schema. Must have object key 'stdout_blob'"

    require Pass stderrBlobF = jField json "stderr_blob"
    else failWithError "rsc: JSON response has incorrect schema. Must have object key 'stderr_blob'"

    require Pass stdoutBlob = mkBlob stdoutBlobF
    require Pass stderrBlob = mkBlob stderrBlobF

    require Pass (JInteger status) = jField json "status"
    else failWithError "rsc: JSON response has incorrect schema. Must have integer key 'status'"

    require Pass (JDouble runtime) = jField json "runtime"
    else failWithError "rsc: JSON response has incorrect schema. Must have double key 'runtime'"

    require Pass (JDouble cputime) = jField json "cputime"
    else failWithError "rsc: JSON response has incorrect schema. Must have double key 'cputime'"

    require Pass (JInteger memory) = jField json "memory"
    else failWithError "rsc: JSON response has incorrect schema. Must have integer key 'memory'"

    require Pass (JInteger ibytes) = jField json "ibytes"
    else failWithError "rsc: JSON response has incorrect schema. Must have integer key 'ibytes'"

    require Pass (JInteger obytes) = jField json "obytes"
    else failWithError "rsc: JSON response has incorrect schema. Must have integer key 'obytes'"

    require Pass (JArray outputFiles) = jField json "output_files"
    else failWithError "rsc: JSON response has incorrect schema. Must have array key 'output_files'"

    require Pass (JArray outputSymlinks) = jField json "output_symlinks"
    else failWithError "rsc: JSON response has incorrect schema. Must have array key 'output_symlinks'"

    require Pass (JArray outputDirectories) = jField json "output_dirs"
    else failWithError "rsc: JSON response has incorrect schema. Must have array key 'output_dirs'"

    def mkOutputSymlink (v: JValue): Result CacheSearchOutputSymlink Error =
        require Pass (JString path) = jField v "path"
        else
            failWithError
            "rsc: JSON response has incorrect schema. output_symlinks[x] must have string key 'path'"

        require Pass (JString link) = jField v "link"
        else
            failWithError
            "rsc: JSON response has incorrect schema. output_symlinks[x] must have string key 'link'"

        CacheSearchOutputSymlink path link
        | Pass

    def mkOutputDirectory (v: JValue): Result CacheSearchOutputDirectory Error =
        require Pass (JString path) = jField v "path"
        else
            failWithError
            "rsc: JSON response has incorrect schema. output_directories[x] must have string key 'path'"

        require Pass (JInteger mode) = jField v "mode"
        else
            failWithError
            "rsc: JSON response has incorrect schema. output_directories[x] must have integer key 'mode'"

        CacheSearchOutputDirectory path mode
        | Pass

    def mkOutputFile (v: JValue): Result CacheSearchOutputFile Error =
        require Pass (JString path) = jField v "path"
        else
            failWithError
            "rsc: JSON response has incorrect schema. '{v | format}' in output_files must have string key 'path'"

        require Pass (JInteger mode) = jField v "mode"
        else
            failWithError
            "rsc: JSON response has incorrect schema. {v | format} in output_files must have integer key 'mode'"

        require Pass jblob = jField v "blob"
        else
            failWithError
            "rsc: JSON response has incorrect schema. '{v | format}' in output_files must have object key 'blob'"

        require Pass blob = mkBlob jblob

        CacheSearchOutputFile path mode blob
        | Pass

    require Pass csOutputFiles =
        outputFiles
        | map mkOutputFile
        | findFail

    require Pass csOutputSymlinks =
        outputSymlinks
        | map mkOutputSymlink
        | findFail

    require Pass csOutputDirectories =
        outputDirectories
        | map mkOutputDirectory
        | findFail

    CacheSearchResponseMatch
    csOutputSymlinks
    csOutputDirectories
    csOutputFiles
    stdoutBlob
    stderrBlob
    status
    runtime
    cputime
    memory
    ibytes
    obytes
    | Match
    | Pass
