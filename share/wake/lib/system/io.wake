# Copyright 2019 SiFive, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You should have received a copy of LICENSE.Apache2 along with
# this software. If not, you may obtain a copy at
#
#    https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

package wake

# The file type a path known to wake.
#
# Most Paths will be regular files, sylinks, or directories. Paths to other types are generally
# not well supported by wake.
export data PathType =
    PathTypeRegularFile
    PathTypeDirectory
    PathTypeCharacterDevice
    PathTypeBlockDevice
    PathTypeFifo
    PathTypeSymlink
    PathTypeSocket

# The various flags of a given file permission.
export tuple Permission =
    # The actor may read the file.
    Read: Boolean
    # The actor may write to the file.
    Write: Boolean
    # The actor may execute the file.
    Execute: Boolean

# Converts a Permission tuple to a masked Linux permission bit field.
#
# perm2bits (Permission False True True) -> 3
# perm2bits (Permission True True False) -> 6
export def perm2bits (perm: Permission) =
    def b3 = if perm.getPermissionRead then 4 else 0
    def b2 = if perm.getPermissionWrite then 2 else 0
    def b1 = if perm.getPermissionExecute then 1 else 0

    b1 + b2 + b3

# Converts a masked Linux permission bit field to a Permission tuple
#
# bits2perm 3 -> (Permission False True True)
# bits2perm 6 -> (Permission True True False)
export def bits2perm (bits: Integer) =
    def b3 = 4 == and bits 4
    def b2 = 2 == and bits 2
    def b1 = 1 == and bits 1

    Permission b3 b2 b1

# The full permission set of a given Path
export tuple Mode =
    User: Permission
    Group: Permission
    Other: Permission

# Converts an unmasked permission bit field into a Mode tuple
#
# bits2mode 365 -> Mode (Permission True False True) (Permission True False True) (Permission True False True)
export def bits2mode (bits: Integer) =
    def otherBits = and bits 7
    def groupBits = and (bits >> 3) 7
    def userBits = and (bits >> 6) 7

    Mode (bits2perm userBits) (bits2perm groupBits) (bits2perm otherBits)

#  Converts Mode tuple into an unmasked permission bit field
#
# mode2bits Mode (Permission True False True) (Permission True False True) (Permission True False True) -> 365
export def mode2bits (mode: Mode) =
    def otherBits = perm2bits mode.getModeOther
    def groupBits = perm2bits mode.getModeGroup << 3
    def userBits = perm2bits mode.getModeUser << 6

    otherBits + groupBits + userBits

# The system Stat of a given Path
export tuple Stat =
    # The Path's file type
    Type: PathType
    # The Path's complete permissions
    Mode: Mode
    # The size in bytes of the Path's content
    SizeBytes: Integer

def statTypeNumberToPathType (inodeType: Integer): PathType = match inodeType
    0 -> PathTypeRegularFile
    1 -> PathTypeDirectory
    2 -> PathTypeCharacterDevice
    3 -> PathTypeBlockDevice
    4 -> PathTypeFifo
    5 -> PathTypeSymlink
    6 -> PathTypeSocket
    _ -> unreachable "stat returned invalid file type"

# Returns the system Stat for a given path
export target stat (path: Path): Result Stat Error =
    def imp p = prim "stat"

    require Pass (Pair size (Pair inodeType mode)) =
        imp path.getPathName
        | rmapError makeError

    Stat (statTypeNumberToPathType inodeType) (bits2mode mode) size
    | Pass

# Read the file contents of a Path
export def read (path: Path): Result String Error =
    def imp p = prim "read"

    match (imp path.getPathName)
        Pass body -> Pass body
        Fail f -> Fail (makeError f)

target writeImp inputs mode path content =
    def writeRunner =
        def imp m p c = prim "write"
        def pre input = Pair input Unit

        def post = match _
            Pair (Fail f) _ -> Fail f
            Pair (Pass output) Unit ->
                if mode < 0 || mode > 0x1ff then
                    Fail (makeError "write {path}: Invalid mode ({strOctal mode})")
                else match (imp mode path content)
                    Fail f -> Fail (makeError f)
                    Pass path -> Pass (editRunnerOutputOutputs (path, _) output)

        makeRunner "write" (\_ Pass 0.0) pre post virtualRunner

    # There are a couple likely bad paths that we don't want the user writing to
    # so we give good error messages for these cases
    require False = path ==* ""
    else
        failWithError
        "Attempt to write to the path of the empty string. This was likely a mixup between the path and the content."

    require False = path ==* "."
    else failWithError "Attempt to write to write to the root workspace"

    # We don't want `write` to write to anything outside of the workspace via
    # a relative path
    require False = matches `\.\..*` path
    else failWithError "Attempt to write outside of the workspace"

    # We don't want `write` to write to anything outside of the workspace via
    # an absolute path
    require False = matches `/.*` path
    else failWithError "Attempt to write to an absolute path"

    # Source files should never be deleted so we check for this case
    def scan dir regexp = prim "sources"
    def isSource = exists (_ ==~ path) (scan "." path.quote)

    require False = isSource
    else failWithError "Attempt to write over a source file"

    # If all those checks pass we go ahead and perform the write. The write will
    # overwrite single files but it will not overwrite a whole directory with a file.
    makeExecPlan ("<write>", "0{strOctal mode}", path, Nil) inputs
    | setPlanLabel "write: {path} 0{strOctal mode}"
    | setPlanOnce False
    | setPlanEnvironment Nil
    | runJobWith writeRunner
    | getJobOutput

# Create all directories and the named file. The `content` string is written verbatim with no
# processing. For example, a final terminating newline character is not appended to the end of
# the string.
export def write (path: String) (content: String): Result Path Error =
    def spath = simplify path

    require Pass parent =
        simplify "{spath}/.."
        | mkdir

    writeImp (parent, Nil) 0644 spath content

# Create a file with the given mode in the specified directory
export def writeIn (parent: Path) (mode: Integer) (name: String) (content: String): Result Path Error =
    writeImp (parent, Nil) mode "{parent.getPathName}/{name}".simplify content

# installAs: copy a file to a specified destination
export def installAs (dest: String) (file: Path): Result Path Error =
    def sdest = simplify dest
    def cmd = which "cp", file.getPathName, sdest, Nil

    require Pass destDir =
        simplify "{dest}/.."
        | mkdir

    def inputs = destDir, file, Nil
    def foutputs _ = sdest, Nil

    makeExecPlan cmd inputs
    | setPlanLabel "installAs: {dest} {file.getPathName}"
    | setPlanEnvironment Nil
    | setPlanFnOutputs foutputs
    | runJobWith localRunner
    | getJobOutput

# Copy a file from one directory subtree to another
# installIn "/to" "from"  "from/subdir/file"  => "/to/subdir/file"
# installIn "/to" "."     "from/subdir/file"  => "/to/from/subdir/file"
# installIn "/to" "/from" "/from/subdir/file" => "/to/subdir/file"
# installIn "/to" "/"     "/from/subdir/file" => "/to/from/subdir/file"
# These fail:
# installIn "/to" "from"  "subdir/file"
# installIn "/to" "/from" "/subdir/file"
# installIn "/to" "from"  "/from/subdir/file"
# installIn "/to" "/from" "from/subdir/file"
export def installIn (toRoot: String) (fromRoot: String) (sourcePath: Path): Result Path Error =
    def sourceStr = sourcePath.getPathName
    def rel = relative fromRoot sourceStr
    def isAbs = matches `/.*`
    def uneq a b = (a && !b) || (!a && b)

    if matches `[.][.]/.*` rel || uneq fromRoot.isAbs sourceStr.isAbs then
        failWithError "{sourceStr} is not contained in {fromRoot}"
    else
        installAs (in toRoot rel) sourcePath

def mkdirRunner: Runner =
    def imp m p = prim "mkdir"

    def pre = match _
        Fail f -> Pair (Fail f) (Pair "" "")
        Pass input -> match input.getRunnerInputCommand
            _, _, mode, dir, Nil -> Pair (Pass input) (Pair mode dir)
            _ -> unreachable "mkdirImp violated command-line contract"

    def post = match _
        Pair (Fail f) _ -> Fail f
        Pair (Pass output) (Pair smode dir) ->
            def mode =
                int smode
                | getOrElse 0x200

            if mode < 0 || mode > 0x1ff then
                Fail (makeError "mkdir {dir}: Invalid mode ({smode})")
            else match (imp mode dir)
                Fail f -> Fail (makeError f)
                Pass path -> Pass (editRunnerOutputOutputs (path, _) output)

    makeRunner "mkdir" (\_ Pass 0.0) pre post virtualRunner

def mkdirImp inputs mode path =
    makeExecPlan ("<mkdir>", "-m", "0{strOctal mode}", path, Nil) inputs
    | setPlanLabel "mkdir: {path} 0{strOctal mode}"
    | setPlanKeep False
    | setPlanEnvironment Nil
    | runJobWith mkdirRunner
    | getJobOutput

# Create a directory in the parent
export def mkdirIn (parent: Path) (mode: Integer) (name: String): Result Path Error =
    mkdirImp (parent, Nil) mode "{parent.getPathName}/{name}".simplify

# Make all every element in the directory path with mode 0755
export def mkdir (path: String): Result Path Error =
    def root = match _
        "", x, t -> Pair (mkdirImp Nil 0755 "/{x}") t
        x, t -> Pair (mkdirImp Nil 0755 x) t
        Nil -> unreachable "tokenize never returns an empty list"

    def mkdirRecursive (Pair rootResult pathTail) =
        require Pass root = rootResult

        rfoldl (mkdirIn _ 0755 _) root pathTail

    path
    | simplify
    | tokenize `/`
    | root
    | mkdirRecursive
