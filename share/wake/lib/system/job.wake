# Copyright 2019 SiFive, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You should have received a copy of LICENSE.Apache2 along with
# this software. If not, you may obtain a copy at
#
#    https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

tuple Usage =
  global Status:   Integer
  global Runtime:  Double
  global CPUtime:  Double
  global MemBytes: Integer
  global InBytes:  Integer
  global OutBytes: Integer

# RunnerInput is a subset of the fields supplied in the execution Plan
tuple RunnerInput =
  global Command:     List String
  global Visible:     List Path
  global Environment: List String
  global Directory:   String
  global Stdin:       String
  global Resources:   List String
  global Prefix:      String        # a unique prefix for this job
  global Record:      Option Usage  # previous resource usage, if known

tuple RunnerOutput =
  global Inputs:  List String
  global Outputs: List String
  global Usage:   Usage

# A Runner describes a way to invoke a Plan to get a Job
tuple Runner =
  global Name:  String
  global Score: Plan => Result Double String
  Fn:           Job => Result RunnerInput Error => Result RunnerOutput Error

# Create new Runner given pre- and post-hooks around an existing Runner
global def makeRunner name score pre post (Runner _ _ run) =
  def doit job preInput = match (pre preInput)
    Pair runInput state =
      def runOutput = run job runInput
      def final _ = post (Pair runOutput state)
      # Don't run any 'post' steps until the Job has stopped running
      waitJobMerged final job
  Runner name score doit

global data Persistence =
  ReRun	# Job should be re-executed on every runJob call
  Once	# Job should only be run once in a given wake execution
  Keep	# Job should output be reusable between wake invocations
  Share	# Job should output be shared between workspaces

# A Plan describes a not-yet-executed Job
tuple Plan =
  global Command:      List String  # The command-line arguments (the first is the command to run)
  global Visible:      List Path    # Only these files should be available to the command
  global Environment:  List String  # KEY=VALUE environment variables fed to the command
  global Directory:    String       # The directory in which the command should be run
  global Stdin:        String       # The file to which standard input should be connected
  global Stdout:       (LogLevel => EchoTarget) # How should standard output be displayed during a build
  global Stderr:       (LogLevel => EchoTarget) # How should standard error be displayed during a build
  global Echo:         LogLevel     # Print the command during builds when logLevel <= Echo
  global Persistence:  Persistence  # See Persistence table above
  global LocalOnly:    Boolean      # Must run directly in the local workspace; no output detection performed
  global Resources:    List String  # The resources a runner must provide to the job (licenses/etc)
  global RunnerFilter: Runner => Boolean # Reject from consideration Runners which the Plan deems inappropriate
  global FnInputs:     (List String => List String) # Modify the Runner's reported inputs  (files read)
  global FnOutputs:    (List String => List String) # Modify the Runner's reported outputs (files created)

def isOnce = match _
  ReRun = False
  _     = True
def isKeep = match _
  ReRun = False
  Once  = False
  _     = True
def isShare = match _
  Share = True
  _     = False

# Convenience accessor methods
global def getPlanOnce  p = isOnce  (getPlanPersistence p)
global def getPlanKeep  p = isKeep  (getPlanPersistence p)
global def getPlanShare p = isShare (getPlanPersistence p)

global def setPlanOnce  v p = editPlanOnce  (\_ v) p
global def setPlanKeep  v p = editPlanKeep  (\_ v) p
global def setPlanShare v p = editPlanShare (\_ v) p

# Helper methods that maintain the invariant that: Share => Keep => Once
global def editPlanOnce f =
  def helper = match _
    ReRun if   f False = Once
    Once  if ! f True  = ReRun
    Keep  if ! f True  = ReRun
    Share if ! f True  = ReRun
    x                  = x
  editPlanPersistence helper _

global def editPlanKeep f =
  def helper = match _
    ReRun if   f False = Keep
    Once  if   f False = Keep
    Keep  if ! f True  = Once
    Share if ! f True  = Once
    x                  = x
  editPlanPersistence helper _

global def editPlanShare f =
  def helper = match _
    ReRun if   f False = Share
    Once  if   f False = Share
    Keep  if   f False = Share
    Share if ! f True  = Keep
    x                  = x
  editPlanPersistence helper _

# The criteria which determine if Job execution can be skipped:
#   Once  is True and a matching job was run by this wake invocation
#   Keep  is True and there is matching output in the workspace
#   Share is True and there is matching output in a shared cache
# A Job is considered matching if:
#   The Command, Environment, Directory, and Stdin are exact matches
#   FnInputs, FnOutputs have the same hashcode
# Output is considered matching if:
#   The prior Outputs exist as the output of a matching Job
#   The prior Input files have the same hashes as files in the workspace
#   The prior Input dirs observe the same set of Visible files

# Set reasonable defaults for all Plan arguments
def id x = x
global def makePlan cmd visible =
  Plan cmd visible environment "." "" logVerbose logWarn Normal Share False Nil (\_ True) id id

def defaultUsage = Usage 0 0.0 0.0 0 0 0

# This runner does not detect inputs/outputs on it's own
# You must use Fn{Inputs,Outputs} to fill in this information
global def localRunner =
  def launch job dir stdin env cmd status runtime cputime membytes ibytes obytes = prim "job_launch"
  def badlaunch job error = prim "job_fail_launch"
  def doit job = match _
    Fail e =
      def _ = badlaunch job e
      Fail e
    Pass (RunnerInput cmd vis env dir stdin _ _ predict) = match (findSomeFn getPathError vis)
      Some e =
        def _ = badlaunch job e
        Fail e
      None = match (getOrElse defaultUsage predict)
        Usage status runtime cputime mem in out =
          def _ = launch job dir stdin env.implode cmd.implode status runtime cputime mem in out
          match (getJobReality job)
            Pass reality = Pass (RunnerOutput (map getPathName vis) Nil reality)
            Fail f = Fail f
  def score (Plan _ _ _ _ _ _ _ _ _ lo _ _ _ _) =
    if lo then Pass 1.0 else Fail "cannot detect outputs"
  Runner "local" score doit

global def virtualRunner =
  def virtual job stdout stderr status runtime cputime membytes ibytes obytes = prim "job_virtual"
  def badlaunch job error = prim "job_fail_launch"
  def doit job = match _
    Fail e =
      def _ = badlaunch job e
      Fail e
    Pass (RunnerInput _ vis _ _ _ _ _ predict) = match (findSomeFn getPathError vis)
      Some e =
        def _ = badlaunch job e
        Fail e
      None = match (getOrElse defaultUsage predict)
        Usage status runtime cputime mem in out =
          def _ = virtual job "" "" status runtime cputime mem in out # sets predict+reality
          match (getJobReality job)
            Pass reality = Pass (RunnerOutput (map getPathName vis) Nil reality)
            Fail f = Fail f
  Runner "virtual" (\_ Pass 0.0) doit

def pid = prim "pid"

def implode l = cat (foldr (_, "\0", _) Nil l)
def runAlways cmd env dir stdin res finputs foutputs vis keep run log =
  def create dir stdin env cmd visible keep log = prim "job_create"
  def finish job inputs outputs status runtime cputime membytes ibytes obytes = prim "job_finish"
  def badfinish job error = prim "job_fail_finish"
  def cache dir stdin env cmd visible = prim "job_cache"
  def build Unit =
    def job = create dir stdin env.implode cmd.implode (map getPathName vis).implode (if keep then 1 else 0) log
    def prefix = "{str pid}.{str (getJobId job)}"
    def usage = getJobRecord job
    def output = run job (Pass (RunnerInput cmd vis env dir stdin res prefix usage))
    def final _ = match output
      Fail e =
        badfinish job e
      Pass (RunnerOutput inputs outputs (Usage status runtime cputime mem in out)) =
        def input  = finputs  inputs  | map simplify | implode
        def output = foutputs outputs | map addhash  | implode
        finish job input output status runtime cputime mem in out
    # Make sure we don't hash files before the job has stopped running
    def _ = waitJobMerged final job
    job
  def confirm last job =
    def notOk (Pair name hash) =
      if hashcode name ==* hash
      then False
      else panic "Hash mismatch for {name} ({hash} != {hashcode name}); remove it"
    def _ = waitJobMerged (\_ find notOk last) job
    job
  match keep
    False = build Unit
    True  = match (cache dir stdin env.implode cmd.implode (map getPathName vis).implode)
      Pair (job, _) last = confirm last job
      Pair Nil      last = confirm last (build Unit)

# Only run if the first four arguments differ
def runOnce cmd env dir stdin res finputs foutputs vis keep run log =
  memoize 8 (runAlways cmd env dir stdin res finputs foutputs vis keep run log)

# Default runners provided by wake
publish runner = localRunner, defaultRunner, Nil

def runJobImp cmd env dir stdin res finputs foutputs vis pers run log =
  if isOnce pers
  then runOnce   cmd env dir stdin res finputs foutputs vis (isKeep pers) run log
  else runAlways cmd env dir stdin res finputs foutputs vis (isKeep pers) run log

def logLevelRaw = prim "level"
def logLevel = match logLevelRaw
  0 = Quiet
  1 = Normal
  2 = Verbose
  _ = Debug

def jobLog stdout stderr echo =
  def num = match _
    Null   = 0
    Stdout = 1
    Stderr = 2
  def thresh = match echo
    Debug   = 3
    Verbose = 2
    Normal  = 1
    Quiet   = 0
  def bit = if thresh <= logLevelRaw then 1 else 0
  (bit << 4) + (num (stderr logLevel) << 2) + num (stdout logLevel)

global def runJobWith (Runner _ _ run) (Plan cmd vis env dir stdin stdout stderr echo pers _ res _ finputs foutputs) =
  runJobImp cmd env dir stdin res finputs foutputs vis pers run (jobLog stdout stderr echo)

data RunnerOption =
  Accept (score: Double) (runnerFn: Job => Result RunnerInput Error => Result RunnerOutput Error)
  Reject (why: String)

# Run the job!
global def runJob p = match p
  Plan cmd vis env dir stdin stdout stderr echo pers lo res rf finputs foutputs =
    # Transform the 'List Runner' into 'List RunnerOption'
    def qualify runner = match runner
      Runner name _ _ if ! rf runner = Reject "{name}: rejected by Plan"
      Runner name scorefn fn = match (scorefn p)
        Pass x if x <=. 0.0 = Reject "{name}: non-positive score"
        Pass x = Accept x fn
        Fail x = Reject "{name} {x}"
    def opts = subscribe runner | map qualify
    def best acc = match _ acc
      (Reject _) _ = acc
      (Accept score fn) (Pair bests bestr) =
        if score >. bests then Pair score (Some fn) else acc
    def log = jobLog stdout stderr echo
    match (opts | foldl best (Pair 0.0 None) | getPairSecond)
      Some r = runJobImp cmd env dir stdin res finputs foutputs vis pers r log
      None =
        def create dir stdin env cmd visible keep log = prim "job_create"
        def badfinish job e = prim "job_fail_finish"
        def badlaunch job e = prim "job_fail_launch"
        def job = create dir stdin env.implode cmd.implode (map getPathName vis).implode 0 log
        def error =
          def pretty = match _
            Accept _ _ = ""
            Reject why = why
          makeError "No runner for '{job.getJobDescription}' available, because: {map pretty opts | catWith ", "}"
        def l = badlaunch job error
        def f = waitOne (\_ badfinish job error) l
        job

def toUsage (Pair (Pair status runtime) (Pair (Pair cputime membytes) (Pair ibytes obytes))) =
  Usage status runtime cputime membytes ibytes obytes

def getJobReality =
  def raw job = prim "job_reality"
  raw _ | rmap toUsage

def waitJobMerged f j =
  def raw job = prim "job_reality"
  raw j | waitOne f

# Actual usage of a finished job
global def getJobReport =
  def raw job = prim "job_report"
  raw _ | rmap toUsage

# From database, available the moment a Job exists
global def getJobRecord =
  def raw job = prim "job_record"
  raw _ | at 0 | omap toUsage

global def makeBadPath error = BadPath error
global def makeBadJob error =
  def _ = printlnLevel logWarn "Deprecated use of makeBadJob. Use makeBadPath."
  makeBadPath error

# Control a running/finished Job
def stdio job fd  = prim "job_output" # 1=stdout, 2=stderr; blocks till closed
def tree  job typ = prim "job_tree"   # 0=visible, 1=input, 2=output; blocks till finished
def treeOk (Pair f h) = match h
  "BadHash" = BadPath (makeError "Could not hash {f}")
  _ = Path f
def guardPath job = match _
  Fail e = BadPath e, Nil
  Pass l if job.isJobOk = map treeOk l
  _ = makeBadPath (makeError "Non-zero exit status ({format job.getJobStatus}) for '{job.getJobDescription}'"), Nil
def mapPath = match _
  Fail e = BadPath e, Nil
  Pass l = map treeOk l
global def killJob job signal = prim "job_kill" # send signal to job
global def getJobStdout  job = stdio job 1
global def getJobStderr  job = stdio job 2
global def getJobInputs  job = tree job 1 | guardPath job
global def getJobOutputs job = tree job 2 | guardPath job
global def getJobFailedInputs  job = tree job 1 | mapPath
global def getJobFailedOutputs job = tree job 2 | mapPath
global def getJobId job = prim "job_id"
global def getJobDescription job = prim "job_desc"
global def getJobOutput job = match (tree job 2)
  Fail e = BadPath e
  Pass l if job.isJobOk = match l
    (Pair f _), Nil = Path f
    Nil    = makeBadPath (makeError "No outputs available from '{job.getJobDescription}'")
    _      = makeBadPath (makeError "More than one output found from '{job.getJobDescription}'")
  _ = makeBadPath (makeError "Non-zero exit status ({format job.getJobStatus}) for '{job.getJobDescription}'")

global def isJobOk job = match (getJobReport job)
  Fail _ = False
  Pass u = u.getUsageStatus == 0

global data Status =
  Exited   Integer
  Signaled Integer
  Aborted  Error

global def getJobStatus job = match (getJobReport job)
  Fail f = Aborted f
  Pass u =
    def status = u.getUsageStatus
    if status >= 0
    then Exited status
    else Signaled (-status)

# Implement FUSE-based Runner
def wakePath = prim "execpath" # location of the wake executable
global def fuseRunner =
  def fuse = "{wakePath}/../lib/wake/fuse-wake"
  def score (Plan _ _ _ _ _ _ _ _ _ lo _ _ _ _) =
    if lo then Fail "would hide workspace" else Pass 1.0
  makeJSONRunner fuse score (Some _)

global def preloadRunner =
  def preload = "{wakePath}/../lib/wake/preload-wake"
  def score (Plan _ _ _ _ _ _ _ _ _ lo _ _ _ _) =
    if lo then Fail "would hide workspace" else Pass 1.0
  makeJSONRunner preload score (Some _)

def rOK = 0
def wOK = 1
def xOK = 2
def access file mode = prim "access"

global def defaultRunner = match sysname
  "Darwin" = fuseRunner
  _ = match (getenv "USE_FUSE_WAKE")
    Some "0" = preloadRunner
    Some _ = fuseRunner
    None =
      def fuse = access "/dev/fuse" wOK
      if fuse then fuseRunner else preloadRunner

# Make a Runner that runs a named script to run jobs
# score: Plan => Double; runJob chooses the runner with the largest score for a Plan
# estimate: Usage => Option Usage; predict local usage based on prior recorded usage
global def makeJSONRunner rawScript score estimate =
  def script = which (simplify rawScript)
  def ok = access script xOK
  def pre = match _
    Fail f = Pair (Fail f) ""
    _ if ! ok = Pair (Fail (makeError "Runner {script} is not executable")) ""
    Pass (RunnerInput command visible environment directory stdin res prefix record) = match (findSomeFn getPathError visible)
      Some e = Pair (Fail e) ""
      None =
        def pmkdir m p = prim "mkdir"
        def pwrite m p d = prim "write"
        def json = JObject (
          "command"     → command     | map JString | JArray,
          "environment" → environment | map JString | JArray,
          "visible"     → visible | map (_.getPathName.JString) | JArray,
          "directory"   → JString directory,
          "stdin"       → JString stdin,
          "resources"   → res | map JString | JArray,
          "version"     → JString version,
          match record
            None = Nil
            Some (Usage status runtime cputime membytes inbytes outbytes) =
              "usage" → JObject (
                "status"   → JInteger status,
                "runtime"  → JDouble  runtime,
                "cputime"  → JDouble  cputime,
                "membytes" → JInteger membytes,
                "inbytes"  → JInteger inbytes,
                "outbytes" → JInteger outbytes,
                Nil
              ), Nil
        )
        match (pmkdir 0775 ".build")
          Fail f = Pair (Fail (makeError f)) ""
          Pass build = match (pwrite 0664 "{build}/{prefix}.in.json" (prettyJSON json))
            Fail f = Pair (Fail (makeError f)) ""
            Pass inFile =
              def outFile = "{build}/{prefix}.out.json"
              def cmd = script, inFile, outFile, Nil
              def proxy = RunnerInput cmd Nil environment "." "" Nil prefix (omapPartial estimate record)
              Pair (Pass proxy) inFile
  def post = match _
    Pair (Fail f) _ = Fail f
    Pair (Pass (RunnerOutput _ _ (Usage x _ _ _ _ _))) inFile if x != 0 =
      Fail (makeError "Non-zero exit status ({str x}) for JSON runner {script} on {inFile}")
    Pair (Pass output) inFile =
      def unlink f = prim "unlink"
      def outFile = replace `\.in\.json$` ".out.json" inFile
      def json = parseJSONFile (Path outFile)
      def _ = unlink inFile
      match json
        Fail f = Fail (makeError f)
        Pass content =
          def _ = unlink outFile
          def field name = match _ _
             _ (Fail f) = Fail f
             None (Pass fn) = Fail "{script} produced {outFile}, which is missing usage/{name}"
             (Some x) (Pass fn) = Pass (fn x)
          def usage = content // `usage`
          def usageResult =
            Pass (Usage _ _ _ _ _ _)
            | field "status"   (usage // `status`   | getJInteger)
            | field "runtime"  (usage // `runtime`  | getJDouble)
            | field "cputime"  (usage // `cputime`  | getJDouble)
            | field "membytes" (usage // `membytes` | getJInteger)
            | field "inbytes"  (usage // `inbytes`  | getJInteger)
            | field "outbytes" (usage // `outbytes` | getJInteger)
          def getK exp = content // exp | getJArray | getOrElse Nil | mapPartial getJString
          match usageResult
            Fail f = Fail (makeError f)
            Pass usage = Pass (RunnerOutput (getK `inputs`) (getK `outputs`) usage)
  makeRunner "json-{script}" score pre post localRunner

# Paths differ from Strings in that they have been hashed; their content is frozen
data Path =
  Path    (name: String)
  BadPath (error: Error)

global def getPathName path = match path
  Path name = name
  BadPath _ = "BADPATH"

global def getPathResult path = match path
  Path name = Pass name
  BadPath e = Fail e

global def getPathParent path = match path
  Path name = Path (simplify "{name}/..")
  BadPath e = BadPath e

global def getPathError path = match path
  Path _    = None
  BadPath e = Some e

def addhash f =
  def p = simplify f
  def add f h = prim "add_hash"
  add p (hashcode p)

def hashcode f = memoize 0 (
  def get f = prim "get_hash"
  def reuse = get f
  if reuse !=* "" then reuse else
    def hashPlan cmd  =
      Plan cmd Nil Nil "." "" logNever logError Verbose ReRun True Nil (\_ True) id id
    def job = hashPlan ("<hash>", f, Nil) | runJobWith localRunner
    def hash =
      job.getJobStdout
      | getWhenFail ""
      | extract `(.{64}).*`
    match job.isJobOk hash
      True (x, Nil) = x
      _ _ = "BadHash"
)

def stateRunner =
  def add f h = prim "add_hash"
  def hash = "0000000000000000000000000000000000000000000000000000000000000000"
  def pre = match _
    Fail f = Pair (Fail f) ""
    Pass input = match input.getRunnerInputCommand
      _, file, Nil = Pair (Pass input) file
      _ = panic "stateRunner: invalid command-line"
  def post = match _
    Pair (Fail f) _ = Fail f
    Pair (Pass output) file =
      Pass (editRunnerOutputOutputs (add file hash, _) output)
  makeRunner "state" (\_ Pass 0.0) pre post virtualRunner

# Mark a file whose contents must not be tracked
global def makeStatePath file =
  makePlan ("<state>", file, Nil) Nil
  | setPlanKeep        False
  | setPlanEcho        Debug
  | setPlanEnvironment Nil
  | setPlanFnOutputs   (file, _)
  | runJobWith stateRunner
  | getJobOutput

# Whenever possible, use 'job' if:
#   cmd can run under FUSE
#   cmd guarantees to produce the same outputs given the same inputs
# Examples:
#   gcc
# job only allows cmd access to 'visible', to prevent undeclared dependencies.
# If you miss declared visible inputs, your build will fail so you can fix it.
# If you declare too many visible inputs, cmd execution/replay will wait for unnecessary files.
global def job cmd visible =
  makePlan cmd visible
  | runJob

# Use alwaysJob when:
#   cmd can run under FUSE
#   cmd output can differ between invocations
# Examples:
#   date
# alwaysJob only allows cmd access to 'visible', to prevent undeclared dependencies.
# If you miss declared visible inputs, your build will fail so you can fix it.
# If you declare too many visible inputs, cmd execution/replay will wait for unnecessary files.
global def alwaysJob cmd visible =
  def _ = printlnLevel logWarn "Deprecated use of alwaysJob. Use makePlan and runJob."
  makePlan cmd visible
  | setPlanKeep False
  | runJob

# Use manualJob when:
#   cmd cannot run under FUSE, but you know which inputs and outputs cmd uses
#   cmd guarantees to produce the same outputs given the same inputs
# Examples:
#   vcs
# cmd will have access to the entire workspace.
# manualJob behaves like normal target rule in a Makefile.
# If you miss declared visible inputs, your build is not reproducible and may run in the wrong order.
# If you declare too many visible inputs, cmd may be rerun and wait unnecessarily.
# If you miss declared outputs, dependant commands might fail or not run reproducibly.
# If you declare too many outputs, the build will fail.
global def manualJob cmd visible foutputs =
  def _ = printlnLevel logWarn "Deprecated use of manualJob. Use makePlan and runJob."
  makePlan cmd visible
  | setPlanLocalOnly True
  | setPlanFnOutputs (\_ foutputs Unit)
  | runJob

# Use volatileJob when:
#   cmd cannot run under FUSE, but you know which inputs and outputs cmd uses
#   cmd output can differ between invocations
# Examples:
#   ???
# volatileJob behaves like a PHONY target in a Makefile.
# If you miss declared visible inputs, your build is not reproducible and may run in the wrong order.
# If you declare too many visible inputs, cmd may wait unnecessarily.
# If you miss declared outputs, dependant commands might fail or not run reproducibly.
# If you declare too many outputs, the build will fail.
global def volatileJob cmd visible foutputs =
  def _ = printlnLevel logWarn "Deprecated use of volatileJob. Use makePlan and runJob."
  makePlan cmd visible
  | setPlanLocalOnly True
  | setPlanFnOutputs (\_ foutputs Unit)
  | setPlanKeep False
  | runJob
