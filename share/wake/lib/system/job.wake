# Copyright 2019 SiFive, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You should have received a copy of LICENSE.Apache2 along with
# this software. If not, you may obtain a copy at
#
#    https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

tuple Usage =
  global Status:   Integer
  global Runtime:  Double
  global CPUtime:  Double
  global MemBytes: Integer
  global InBytes:  Integer
  global OutBytes: Integer

# RunnerInput is a subset of the fields supplied in the execution Plan
tuple RunnerInput =
  global Command:       List String
  global Visible:       List Path
  global Environment:   List String
  global Directory:     String
  global StandardInput: String
  global Resources:     List String
  global Prefix:        String        # a unique prefix for this job
  global Record:        Option Usage  # previous resource usage, if known
  Pool:                 Integer

tuple RunnerOutput =
  global Inputs:  List String
  global Outputs: List String
  global Indexes: List String
  global Usage:   Usage

# A Runner describes a way to invoke a Plan to get a Job
tuple Runner =
  global Name:  String
  global Score: Plan => Result Double String
  Fn:           Job => Result RunnerInput Error => Result RunnerOutput Error

# Create new Runner given pre- and post-hooks around an existing Runner
global def makeRunner name score pre post (Runner _ _ run) =
  def doit job preInput = match (pre preInput)
    Pair runInput state =
      def runOutput = run job runInput
      def final _ = post (Pair runOutput state)
      # Don't run any 'post' steps until the Job has stopped running
      waitJobMerged final job
  Runner name score doit

global data Persistence =
  ReRun	# Job should be re-executed on every runJob call
  Once	# Job should only be run once in a given wake execution
  Keep	# Job should output be reusable between wake invocations
  Share	# Job should output be shared between workspaces

# A Plan describes a not-yet-executed Job
tuple Plan =
  global Command:       List String  # The command-line arguments (the first is the command to run)
  global Visible:       List Path    # Only these files should be available to the command
  global Environment:   List String  # KEY=VALUE environment variables fed to the command
  global Directory:     String       # The directory in which the command should be run
  global StandardInput: String       # The file to which standard input should be connected
  global Persistence:   Persistence  # See Persistence table above
  global LocalOnly:     Boolean      # Must run directly in the local workspace; no output detection performed
  global Resources:     List String  # The resources a runner must provide to the job (licenses/etc)
  global RunnerFilter:  Runner => Boolean # Reject from consideration Runners which the Plan deems inappropriate
  global FnInputs:      (List String => List String) # Modify the Runner's reported inputs  (files read)
  global FnOutputs:     (List String => List String) # Modify the Runner's reported outputs (files created)
  global FnIndexes:     (List String => List String) # Modify the Runner's reported indexes (directories listed)
  Pool:                 Integer      # Resource pool used to pay for the Job

def isOnce = match _
  ReRun = False
  _     = True
def isKeep = match _
  ReRun = False
  Once  = False
  _     = True
def isShare = match _
  Share = True
  _     = False

# Convenience accessor methods
global def getPlanOnce  p = isOnce  (getPlanPersistence p)
global def getPlanKeep  p = isKeep  (getPlanPersistence p)
global def getPlanShare p = isShare (getPlanPersistence p)

global def setPlanOnce  v p = editPlanOnce  (\_ v) p
global def setPlanKeep  v p = editPlanKeep  (\_ v) p
global def setPlanShare v p = editPlanShare (\_ v) p

# Helper methods that maintain the invariant that: Share => Keep => Once
global def editPlanOnce f =
  def helper = match _
    ReRun if   f False = Once
    Once  if ! f True  = ReRun
    Keep  if ! f True  = ReRun
    Share if ! f True  = ReRun
    x                  = x
  editPlanPersistence helper _

global def editPlanKeep f =
  def helper = match _
    ReRun if   f False = Keep
    Once  if   f False = Keep
    Keep  if ! f True  = Once
    Share if ! f True  = Once
    x                  = x
  editPlanPersistence helper _

global def editPlanShare f =
  def helper = match _
    ReRun if   f False = Share
    Once  if   f False = Share
    Keep  if   f False = Share
    Share if ! f True  = Keep
    x                  = x
  editPlanPersistence helper _

# The criteria which determine if Job execution can be skipped:
#   Once  is True and a matching job was run by this wake invocation
#   Keep  is True and there is matching output in the workspace
#   Share is True and there is matching output in a shared cache
# A Job is considered matching if:
#   The Command, Environment, Directory, and StandardInput are exact matches
#   FnInputs, FnOutputs, FnIndexes have the same hashcode
# Output is considered matching if:
#   The prior Outputs exist as the output of a matching Job
#   The prior Inputs have the same hashes as files in the workspace
#   The prior Indexes observe the same set of Visible files

# Set reasonable defaults for all Plan arguments
def id x = x
global def makePlan cmd visible =
  Plan cmd visible environment "." "" Share False Nil (\_ True) id id id 1

def makeRawPlan cmd  =
  Plan cmd Nil Nil "." "" ReRun True Nil (\_ True) id id id 1

def defaultUsage = Usage 0 0.0 0.0 0 0 0

# This runner does not detect inputs/outputs/indexes on it's own
# You must use Fn{Inputs,Outputs,Indexes} to fill in this information
global def localRunner =
  def launch job pool dir stdin env cmd status runtime cputime membytes ibytes obytes = prim "job_launch"
  def badlaunch job error = prim "job_fail_launch"
  def doit job = match _
    Fail e =
      def _ = badlaunch job e
      Fail e
    Pass (RunnerInput cmd vis env dir stdin _ _ predict pool) = match (findSome getPathError vis)
      Some e =
        def _ = badlaunch job e
        Fail e
      None = match (getOrElse defaultUsage predict)
        Usage status runtime cputime mem in out =
          def _ = launch job pool dir stdin env.implode cmd.implode status runtime cputime mem in out
          match (getJobReality job)
            Pass reality = Pass (RunnerOutput (map getPathName vis) Nil Nil reality)
            Fail f = Fail f
  def score (Plan _ _ _ _ _ _ lo _ _ _ _ _ _) =
    if lo then Pass 1.0 else Fail "cannot detect outputs"
  Runner "local" score doit

global def virtualRunner =
  def virtual job stdout stderr status runtime cputime membytes ibytes obytes = prim "job_virtual"
  def badlaunch job error = prim "job_fail_launch"
  def doit job = match _
    Fail e =
      def _ = badlaunch job e
      Fail e
    Pass (RunnerInput cmd vis env dir stdin _ _ predict pool) = match (findSome getPathError vis)
      Some e =
        def _ = badlaunch job e
        Fail e
      None = match (getOrElse defaultUsage predict)
        Usage status runtime cputime mem in out =
          def _ = virtual job "" "" status runtime cputime mem in out # sets predict+reality
          match (getJobReality job)
            Pass reality = Pass (RunnerOutput (map getPathName vis) Nil Nil reality)
            Fail f = Fail f
  Runner "virtual" (\_ Pass 0.0) doit

def pid = prim "pid"

def implode l = cat (foldr (_, "\0", _) Nil l)
def runAlways cmd env dir stdin res finputs foutputs findexes vis keep run pool =
  def create dir stdin env cmd visible keep = prim "job_create"
  def finish job inputs outputs status runtime cputime membytes ibytes obytes = prim "job_finish"
  def badfinish job error = prim "job_fail_finish"
  def cache dir stdin env cmd visible = prim "job_cache"
  def build Unit =
    def job = create dir stdin env.implode cmd.implode (map getPathName vis).implode (if keep then 1 else 0)
    def prefix = "{str pid}.{str (getJobId job)}"
    def usage = getJobRecord job
    def output = run job (Pass (RunnerInput cmd vis env dir stdin res prefix usage pool))
    def final _ = match output
      Fail e =
        badfinish job e
      Pass (RunnerOutput inputs outputs indexes (Usage status runtime cputime mem in out)) =
        def input  = finputs  inputs  | map simplify | implode
        def output = foutputs outputs | map addhash  | implode
        finish job input output status runtime cputime mem in out
    # Make sure we don't hash files before the job has stopped running
    def _ = waitJobMerged final job
    job
  def confirm last job =
    def notOk (Pair name hash) =
      if hashcode name ==* hash
      then False
      else panic "Hash mismatch for {name} ({hash} != {hashcode name}); remove it"
    def _ = waitJobMerged (\_ find notOk last) job
    job
  match keep
    False = build Unit
    True  = match (cache dir stdin env.implode cmd.implode (map getPathName vis).implode)
      Pair (job, _) last = confirm last job
      Pair Nil      last = confirm last (build Unit)

# Only run if the first four arguments differ
def runOnce cmd env dir stdin res finputs foutputs findexes vis keep run pool =
  memoize 9 (runAlways cmd env dir stdin res finputs foutputs findexes vis keep run pool)

# Default runners provided by wake
publish runner = localRunner, defaultRunner, Nil

def runJobImp cmd env dir stdin res finputs foutputs findexes vis pers run pool =
  if isOnce pers
  then runOnce   cmd env dir stdin res finputs foutputs findexes vis (isKeep pers) run pool
  else runAlways cmd env dir stdin res finputs foutputs findexes vis (isKeep pers) run pool

global def runJobWith (Runner _ _ run) (Plan cmd vis env dir stdin pers _ res _ finputs foutputs findexes pool) =
  runJobImp cmd env dir stdin res finputs foutputs findexes vis pers run pool

data RunnerOption =
  Accept (score: Double) (runnerFn: Job => Result RunnerInput Error => Result RunnerOutput Error)
  Reject (why: String)

# Run the job!
global def runJob p = match p
  Plan cmd vis env dir stdin pers lo res rf finputs foutputs findexes pool =
    # Transform the 'List Runner' into 'List RunnerOption'
    def qualify runner = match runner
      Runner name _ _ if ! rf runner = Reject "{name}: rejected by Plan"
      Runner name scorefn fn = match (scorefn p)
        Pass x if x <=. 0.0 = Reject "{name}: non-positive score"
        Pass x = Accept x fn
        Fail x = Reject "{name} {x}"
    def opts = subscribe runner | map qualify
    def best acc = match _ acc
      (Reject _) _ = acc
      (Accept score fn) (Pair bests bestr) =
        if score >. bests then Pair score (Some fn) else acc
    match (opts | foldl best (Pair 0.0 None) | getPairSecond)
      Some r = runJobImp cmd env dir stdin res finputs foutputs findexes vis pers r pool
      None =
        def create dir stdin env cmd visible keep = prim "job_create"
        def badfinish job e = prim "job_fail_finish"
        def badlaunch job e = prim "job_fail_launch"
        def job = create dir stdin env.implode cmd.implode (map getPathName vis).implode 0
        def error =
          def pretty = match _
            Accept _ _ = ""
            Reject why = why
          makeError "No runner for '{job.getJobDescription}' available, because: {map pretty opts | catWith ", "}"
        def l = badlaunch job error
        def f = waitOne (\_ badfinish job error) l
        job

def toUsage (Pair (Pair status runtime) (Pair (Pair cputime membytes) (Pair ibytes obytes))) =
  Usage status runtime cputime membytes ibytes obytes

def getJobReality =
  def raw job = prim "job_reality"
  raw _ | rmap toUsage

def waitJobMerged f j =
  def raw job = prim "job_reality"
  raw j | waitOne f

# Actual usage of a finished job
global def getJobReport =
  def raw job = prim "job_report"
  raw _ | rmap toUsage

# From database, available the moment a Job exists
global def getJobRecord =
  def raw job = prim "job_record"
  raw _ | at 0 | omap toUsage

global def makeBadJob error = BadJob error

# Control a running/finished Job
def stdio job fd  = prim "job_output" # 1=stdout, 2=stderr; blocks till closed
def tree  job typ = prim "job_tree"   # 0=visible, 1=input, 2=output; blocks till finished
def guardPath job = match _
  Fail e = BadJob e, Nil
  Pass l if job.isJobOk = map (\(Pair f _) File f) l
  _ = makeBadJob (makeError "Non-zero exit status ({format job.getJobStatus}) for '{job.getJobDescription}'"), Nil
def mapPath = match _
  Fail e = BadJob e, Nil
  Pass l = map (\(Pair f _) File f) l
global def killJob job signal = prim "job_kill" # send signal to job
global def getJobStdout  job = stdio job 1
global def getJobStderr  job = stdio job 2
global def getJobInputs  job = tree job 1 | guardPath job
global def getJobOutputs job = tree job 2 | guardPath job
global def getJobFailedInputs  job = tree job 1 | mapPath
global def getJobFailedOutputs job = tree job 2 | mapPath
global def getJobId job = prim "job_id"
global def getJobDescription job = prim "job_desc"
global def getJobOutput job = match (tree job 2)
  Fail e = BadJob e
  Pass l if job.isJobOk = match l
    (Pair f _), Nil = File f
    Nil    = makeBadJob (makeError "No outputs available from '{job.getJobDescription}'")
    _      = makeBadJob (makeError "More than one output found from '{job.getJobDescription}'")
  _ = makeBadJob (makeError "Non-zero exit status ({format job.getJobStatus}) for '{job.getJobDescription}'")

global def isJobOk job = match (getJobReport job)
  Fail _ = False
  Pass u = u.getUsageStatus == 0

global data Status =
  Exited   Integer
  Signaled Integer
  Aborted  Error

global def getJobStatus job = match (getJobReport job)
  Fail f = Aborted f
  Pass u =
    def status = u.getUsageStatus
    if status >= 0
    then Exited status
    else Signaled (-status)

# Implement FUSE-based Runner
def wakePath = prim "execpath" # location of the wake executable
def fusePath = relative workspace (simplify "{wakePath}/../lib/wake/fuse-wake")
global def fuseRunner =
  def sigalrm = 14
  def pre = match _
    Fail f = Pair (Fail f) None
    Pass input = match ((\m\p prim "mkdir") 0775 ".build")
      Fail f = Pair (Fail (makeError f)) None
      Pass build = match (
        (input.getRunnerInputDirectory, input.getRunnerInputVisible | map getPathName)
        | implode
        | (\m\p\c prim "write") 0664 "{build}/{input.getRunnerInputPrefix}.visible"
      )
        Fail f = Pair (Fail (makeError f)) None
        Pass visibleFile =
          def cmd = fusePath, visibleFile, Nil
          def fuse = makeRawPlan cmd | setPlanPool 0 | runJobWith localRunner
          match (fuse.getJobStderr | rmap (extract `OK: (.*)`))
            Pass (x, Nil) = Pair (Pass (editRunnerInputDirectory ("{x}/{_}") input)) (Some fuse)
            Pass _ = Pair (Fail (makeError "fuse-wake stderr invalid: {fuse.getJobStderr | getWhenFail ""}")) (Some fuse)
            Fail f = Pair (Fail f) (Some fuse)
  def post = match _
    Pair x None = x
    Pair (Fail f) (Some fuse) =
      def _ = killJob fuse sigalrm
      Fail f
    Pair (Pass output) (Some fuse) =
      def _ = killJob fuse sigalrm
      def usage (Usage ps pr pc pm pi po) = match fuse.getJobReport
        Pass (Usage fs _ fc fm fi fo) =
          Usage (if fs == 0 then ps else fs) pr (fc +. pc) (fm + pm) (fi + pi) (fo + po)
        Fail _ =
          Usage ps pr pc pm pi po
      def fields =
        fuse.getJobStdout
        | getWhenFail ""
        | extract `(.*\0)?\0(.*)`
      match fields
        inputs, outputs, Nil =
          output
          | setRunnerOutputInputs  (inputs  | tokenize `\0` | filter (_!=*""))
          | setRunnerOutputOutputs (outputs | tokenize `\0` | filter (_!=*""))
          | editRunnerOutputUsage usage
          | Pass
        _ = Fail (makeError "fuse-wake stdout invalid: {fuse.getJobStdout | getWhenFail ""}")
  def score (Plan _ _ _ _ _ _ lo _ _ _ _ _ _) =
    if lo then Fail "would hide workspace" else Pass 1.0
  makeRunner "fuse" score pre post localRunner

global def preloadRunner =
  def preload = "{wakePath}/../lib/wake/preload-wake"
  def score (Plan _ _ _ _ _ _ lo _ _ _ _ _ _) =
    if lo then Fail "would hide workspace" else Pass 1.0
  makeJSONRunner preload score (\_ None)

def rOK = 0
def wOK = 1
def xOK = 2
def access file mode = prim "access"

global def defaultRunner = match (getenv "USE_FUSE_WAKE")
  Some "0" = preloadRunner
  Some _ = fuseRunner
  None =
    def fuse =
      access "/dev/fuse" wOK ||
      access "/dev/osxfuse0" wOK
    if fuse then fuseRunner else preloadRunner

# Make a Runner that runs a named script to run jobs
# score: Plan => Double; runJob chooses the runner with the largest score for a Plan
# estimate: Usage => Option Usage; predict local usage based on prior recorded usage
global def makeJSONRunner script score estimate =
  def pre = match _
    Fail f = Pair (Fail f) ""
    Pass (RunnerInput command visible environment directory stdin res prefix record _) = match (findSome getPathError visible)
      Some e = Pair (Fail e) ""
      None =
        def json = JObject (
          "command"     → command     | map JString | JArray,
          "environment" → environment | map JString | JArray,
          "visible"     → visible | map (_.getPathName.JString) | JArray,
          "directory"   → JString directory,
          "stdin"       → JString stdin,
          "resources"   → res | map JString | JArray,
          "version"     → JString version,
          match record
            None = Nil
            Some (Usage status runtime cputime membytes inbytes outbytes) =
              "usage" → JObject (
                "status"   → JInteger status,
                "runtime"  → JDouble  runtime,
                "cputime"  → JDouble  cputime,
                "membytes" → JInteger membytes,
                "inbytes"  → JInteger inbytes,
                "outbytes" → JInteger outbytes,
                Nil
              ), Nil
        )
        match ((\m\p prim "mkdir") 0775 ".build")
          Fail f = Pair (Fail (makeError f)) ""
          Pass build = match ((\m\p\c prim "write") 0664 "{build}/{prefix}.in.json" (prettyJSON json))
            Fail f = Pair (Fail (makeError f)) ""
            Pass inFile =
              def outFile = "{build}/{prefix}.out.json"
              def cmd = script, inFile, outFile, Nil
              def proxy = RunnerInput cmd Nil environment "." "" Nil prefix (omapPartial estimate record) 1
              Pair (Pass proxy) outFile
  def post = match _
    Pair (Fail f) _ = Fail f
    Pair (Pass output) outFile =
      def content = parseJSONFile (File outFile) | getWhenFail JNull
      def usage = content // `usage`
      def usageOut =
        Usage
        (usage // `status`   | getJInteger | getOrElse 255)
        (usage // `runtime`  | getJDouble  | getOrElse 0.0)
        (usage // `cputime`  | getJDouble  | getOrElse 0.0)
        (usage // `membytes` | getJInteger | getOrElse 0)
        (usage // `inbytes`  | getJInteger | getOrElse 0)
        (usage // `outbytes` | getJInteger | getOrElse 0)
      def getK exp = content // exp | getJArray | getOrElse Nil | mapPartial getJString
      Pass (RunnerOutput (getK `inputs`) (getK `outputs`) (getK `indexes`) usageOut)
  makeRunner "json-{script}" score pre post localRunner

global def executeJSON json =
  def makeVirtual visible =
    def add f h = prim "add_hash"
    File (add visible "0")
  def cmd   = json // `command`     | getJArray  | getOrElse Nil | mapPartial getJString
  def vis   = json // `visible`     | getJArray  | getOrElse Nil | mapPartial getJString | map makeVirtual
  def env   = json // `environment` | getJArray  | getOrElse Nil | mapPartial getJString
  def dir   = json // `directory`   | getJString | getOrElse "."
  def stdin = json // `stdin`       | getJString | getOrElse ""
  # Resources should have been resolved by the runner prior to invocation by us
  def res   = Nil # json // `resources`   | getJString | getOrElse Nil | mapPartial getJString
  def job = Plan cmd vis env dir stdin ReRun True res (\_ True) id id id 1 | runJobWith fuseRunner
  match job.getJobReport
    Fail (Error cause stack) = JObject (
      "cause" → JString cause,
      "stack" → stack | map JString | JArray,
      Nil
    )
    Pass (Usage status runtime cputime membytes inbytes outbytes) = JObject (
      "inputs"  → tree job 1 | getWhenFail Nil | map (_.getPairFirst.JString) | JArray,
      "outputs" → tree job 2 | getWhenFail Nil | map (_.getPairFirst.JString) | JArray,
      "usage" → JObject (
        "status"   → JInteger status,
        "runtime"  → JDouble runtime,
        "cputime"  → JDouble cputime,
        "membytes" → JInteger membytes,
        "inbytes"  → JInteger inbytes,
        "outbytes" → JInteger outbytes,
        Nil
      ), Nil
    )

# Paths differ from Strings in that they have been hashed; their content is frozen
data Path =
  File   (name: String)
  BadJob (error: Error)

global def getPathName path = match path
  File name = name
  BadJob _ = "BADJOB"

global def getPathResult path = match path
  File name = Pass name
  BadJob e  = Fail e

global def getPathParent path = match path
  File name = File (simplify "{name}/..")
  BadJob e  = BadJob e

global def getPathError path = match path
  File _ = None
  BadJob e = Some e

def addhash f =
  def p = simplify f
  def add f h = prim "add_hash"
  add p (hashcode p)

def hashcode f = memoize 0 (
  def get f = prim "get_hash"
  def reuse = get f
  if reuse !=* "" then reuse else
    def job = makeRawPlan ("<hash>", f, Nil) | runJobWith localRunner
    def hash =
      job.getJobStdout
      | getWhenFail ""
      | extract `(.{64}).*`
    match job.isJobOk hash
      True (x, Nil) = x
      _ _ = panic "Failed to hash file {f}"
)

def stateRunner =
  def add f h = prim "add_hash"
  def hash = "0000000000000000000000000000000000000000000000000000000000000000"
  def pre = match _
    Fail f = Pair (Fail f) ""
    Pass input = match input.getRunnerInputCommand
      _, file, Nil = Pair (Pass input) file
      _ = panic "stateRunner: invalid command-line"
  def post = match _
    Pair (Fail f) _ = Fail f
    Pair (Pass output) file =
      Pass (editRunnerOutputOutputs (add file hash, _) output)
  makeRunner "state" (\_ Pass 0.0) pre post virtualRunner

# Mark a file whose contents must not be tracked
global def makeStatePath file =
  makePlan ("<state>", file, Nil) Nil
  | setPlanKeep        False
  | setPlanEnvironment Nil
  | setPlanFnOutputs   (file, _)
  | runJobWith stateRunner
  | getJobOutput

# Whenever possible, use 'job' if:
#   cmd can run under FUSE
#   cmd guarantees to produce the same outputs given the same inputs
# Examples:
#   gcc
# job only allows cmd access to 'visible', to prevent undeclared dependencies.
# If you miss declared visible inputs, your build will fail so you can fix it.
# If you declare too many visible inputs, cmd execution/replay will wait for unnecessary files.
global def job cmd visible =
  makePlan cmd visible
  | runJob

# Use alwaysJob when:
#   cmd can run under FUSE
#   cmd output can differ between invocations
# Examples:
#   date
# alwaysJob only allows cmd access to 'visible', to prevent undeclared dependencies.
# If you miss declared visible inputs, your build will fail so you can fix it.
# If you declare too many visible inputs, cmd execution/replay will wait for unnecessary files.
global def alwaysJob cmd visible =
  makePlan cmd visible
  | setPlanKeep False
  | runJob

# Use manualJob when:
#   cmd cannot run under FUSE, but you know which inputs and outputs cmd uses
#   cmd guarantees to produce the same outputs given the same inputs
# Examples:
#   vcs
# cmd will have access to the entire workspace.
# manualJob behaves like normal target rule in a Makefile.
# If you miss declared visible inputs, your build is not reproducible and may run in the wrong order.
# If you declare too many visible inputs, cmd may be rerun and wait unnecessarily.
# If you miss declared outputs, dependant commands might fail or not run reproducibly.
# If you declare too many outputs, the build will fail.
global def manualJob cmd visible foutputs =
  makePlan cmd visible
  | setPlanLocalOnly True
  | setPlanFnOutputs (\_ foutputs Unit)
  | runJob

# Use volatileJob when:
#   cmd cannot run under FUSE, but you know which inputs and outputs cmd uses
#   cmd output can differ between invocations
# Examples:
#   ???
# volatileJob behaves like a PHONY target in a Makefile.
# If you miss declared visible inputs, your build is not reproducible and may run in the wrong order.
# If you declare too many visible inputs, cmd may wait unnecessarily.
# If you miss declared outputs, dependant commands might fail or not run reproducibly.
# If you declare too many outputs, the build will fail.
global def volatileJob cmd visible foutputs =
  makePlan cmd visible
  | setPlanLocalOnly True
  | setPlanFnOutputs (\_ foutputs Unit)
  | setPlanKeep False
  | runJob
