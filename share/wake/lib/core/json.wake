# The JSON data type
global data JValue =
  JString  String
  JInteger Integer
  JDouble  Double
  JBoolean Boolean
  JNull
  JObject  (List (Pair String JValue))
  JArray   (List JValue)

global def getJString = match _
  JString x               = Some x
  JArray (JString x, Nil) = Some x
  _                       = None
global def getJInteger = match _
  JInteger x               = Some x
  JArray (JInteger x, Nil) = Some x
  _                        = None
global def getJDouble = match _
  JDouble x               = Some x
  JArray (JDouble x, Nil) = Some x
  _                       = None
global def getJBoolean = match _
  JBoolean x               = Some x
  JArray (JBoolean x, Nil) = Some x
  _                        = None
global def getJObject = match _
  JObject x               = Some x
  JArray (JObject x, Nil) = Some x
  _                       = None
global def getJArray = match _
  JArray x = Some x
  _        = None

global def parseJSONBody body = prim "json_body"
global def parseJSONFile file = prim "json_file"

global def escape =
  def fmt t = match _
    0xa = '\n', t
    0x9 = '\t', t
    0xd = '\r', t
    x if x < 16 = '\u000', strbase 16 x, t
    x           = '\u00',  strbase 16 x, t
  def helper = match _
    s, c, t = s, str2bin c | fmt (helper t)
    x = x
  _
  | replace '[\\"]' '\\\0'
  | replace "\0" '\\u0000'
  | replace '[\x01-\x1f]' "\0\\0\0"
  | tokenize "\0"
  | helper

tuple JSONFormat =
  global String (String => String)
  global Integer (Integer => String)
  global Double (Double => String)
  global Indent Integer

def doFormat fmt lhs =
  def indent = fmt.getJSONFormatIndent
  def space = if indent > 0 then " " else ""
  def indention = tab (\_ ' ') indent | cat
  def rec rhs depth lhs =
    def deeper = omap ("{indention}{_}") depth
    def tabbed = omap ("\n{_}") depth | getOrElse ""
    def tabbeder = omap ("\n{_}") deeper | getOrElse ""
    match lhs
      JString  s    = '"', fmt.getJSONFormatString s, '"', rhs
      JInteger i    = fmt.getJSONFormatInteger i,          rhs
      JDouble  d    = fmt.getJSONFormatDouble d,           rhs
      JBoolean True = "true",   rhs
      JBoolean False= "false",  rhs
      JNull         = "null",   rhs
      JArray   list =
        def helper value acc = ",{tabbeder}", rec acc deeper value
        if list.empty then '[]', rhs
        else "[{tabbeder}", foldr helper ("{tabbed}]", rhs) list | tail
      JObject  list =
        def helper (Pair key value) acc =
          ",{tabbeder}", '"', escape key ++ ("\":{space}", rec acc deeper value)
        if list.empty then '{}', rhs
        else "\{{tabbeder}", foldr helper ("{tabbed}\}", rhs) list | tail
  rec Nil (if indent > 0 then Some "" else None) lhs

global def defaultJSONFormat =
  def formatDouble d =
    match (dclass d)
      Infinite if d <. 0e0 = "-1e9999"
      Infinite = "1e9999"
      NaN      = "NaN"
      _        = dstr d
  JSONFormat (escape _ | cat) str formatDouble 0

global def prettyJSONFormat = defaultJSONFormat | setJSONFormatIndent 2

global def customFormatJSON fmt x = doFormat fmt x | cat
global def formatJSON = customFormatJSON defaultJSONFormat
global def prettyJSON = customFormatJSON prettyJSONFormat

global def x /| f = match x
  JArray l = JArray (filter f l)
  _ = if f x then JArray (x, Nil) else JArray Nil

#global def x /. i = match x
#  JArray l = at i l
#  _ = if i == 0 then x else raise "index out of bounds"

global def x // y =
  def helper tail = match _
    JString  _ = tail
    JInteger _ = tail
    JDouble  _ = tail
    JBoolean _ = tail
    JNull      = tail
    JObject  l =
      def flatten v tail = match v.getPairSecond
        JArray l = l ++ tail
        w = w, tail
      foldr flatten tail (filter (matches y _.getPairFirst) l)
    JArray   l =
      def flatten v tail = helper tail v
      foldr flatten tail l
  JArray (helper Nil x)

global def x ==/ y = match x y
  (JString  a) (JString  b) = a ==~ b
  (JInteger a) (JInteger b) = a ==  b
  (JDouble  a) (JDouble  b) = a ==. b
  (JBoolean a) (JBoolean b) = if a then b else !b
  JNull        JNull        = True
  (JObject  a) (JObject  b) =
    def helper (Pair (Pair k c) (Pair l d)) = k ==~ l && c ==/ d
    if a.len != b.len then False else zip a b | forall helper
  (JArray   a) (JArray   b) =
    def helper (Pair c d) = c ==/ d
    if a.len != b.len then False else zip a b | forall helper
  (JArray a) _ = exists (_ ==/ y) a
  _ (JArray b) = exists (_ ==/ x) b
  _ _ = False
