package v0_22_wake
from v0_24_wake export type Array Boolean Colour Double DoubleClass DoubleFormat Error Integer Intensity JSONFormat JSONRunnerPlan JValue Job List LogLevel Option Order Pair Path Persistence Plan RegExp Result Runner RunnerInput RunnerOutput Status String Tree Triple Unit Usage Vector
from v0_24_wake export type binary ; =>
from v0_24_wake export def Aborted Black Blue Bright Cyan Dim DoubleDefault DoubleFixed DoubleHex DoubleInfinite DoubleNaN DoubleNormal DoubleScientific DoubleSubNormal EQ Error Exited Fail False GT Green JArray JBoolean JDouble JInteger JNull JObject JString Keep LT Magenta Nil None Once Pair Pass ReRun Red RunnerInput RunnerOutput Share Signaled Some Triple True Unit Usage White Yellow _0 _1 _2 _3 _4 _5 _6 _7 _8 _9 abs access addEnvironmentPath addEnvironmentPathOpt addErrorContext and append at byteToInteger cat catWith cmp customFormatJSON cwd dabs dacos dasin datan dclass dcmp dcos defaultJSONFormat defaultRunner derf derfc dexp dexpm1 dfma dformat dfrexp dhex dint distinctBy distinctRunBy dldexp dlgamma dlog dlog1p dmax dmin dmodf double dprod droot drop dropUntil dsin dsqrt dstr dsum dtan dtgamma editEnvironment editErrorCause editErrorStack editJSONFormatDouble editJSONFormatIndent editJSONFormatInteger editJSONFormatString editJSONRunnerPlanEstimate editJSONRunnerPlanExtraArgs editJSONRunnerPlanExtraEnv editJSONRunnerPlanRawScript editJSONRunnerPlanScore editPairFirst editPairSecond editPlanCommand editPlanDirectory editPlanEcho editPlanEnvironment editPlanFnInputs editPlanFnOutputs editPlanKeep editPlanLabel editPlanLocalOnly editPlanOnce editPlanPersistence editPlanResources editPlanRunnerFilter editPlanShare editPlanStderr editPlanStdin editPlanStdout editPlanUsage editPlanVisible editRunnerInputCommand editRunnerInputDirectory editRunnerInputEnvironment editRunnerInputLabel editRunnerInputPrefix editRunnerInputRecord editRunnerInputResources editRunnerInputStdin editRunnerInputVisible editRunnerName editRunnerOutputInputs editRunnerOutputOutputs editRunnerOutputUsage editRunnerScore editTripleFirst editTripleSecond editTripleThird editUsageCPUtime editUsageInBytes editUsageMemBytes editUsageOutBytes editUsageRuntime editUsageStatus empty environment exists explode extract failWithError files filter find findFail findFailFn findNone findNoneFn findPass findPassFn findSome findSomeFn flatten flip foldl foldr forall format formatJSON fuseRunner gcd getEnvironment getErrorCause getErrorStack getFail getJArray getJBoolean getJDouble getJInteger getJObject getJSONFormatDouble getJSONFormatIndent getJSONFormatInteger getJSONFormatString getJSONRunnerPlanEstimate getJSONRunnerPlanExtraArgs getJSONRunnerPlanExtraEnv getJSONRunnerPlanRawScript getJSONRunnerPlanScore getJString getJobDescription getJobId getJobRecord getJobReport getJobStatus getJobStderr getJobStdout getLogLevelName getOrElse getOrElseFn getOrFail getOrFailFn getOrPass getOrPassFn getPairFirst getPairSecond getPass getPathChild getPathError getPathHash getPathName getPathParent getPathResult getPlanCommand getPlanDirectory getPlanEcho getPlanEnvironment getPlanFnInputs getPlanFnOutputs getPlanHash getPlanKeep getPlanLabel getPlanLocalOnly getPlanOnce getPlanPersistence getPlanResources getPlanRunnerFilter getPlanShare getPlanStderr getPlanStdin getPlanStdout getPlanUsage getPlanVisible getRunnerInputCommand getRunnerInputDirectory getRunnerInputEnvironment getRunnerInputLabel getRunnerInputPrefix getRunnerInputRecord getRunnerInputResources getRunnerInputStdin getRunnerInputVisible getRunnerName getRunnerOutputInputs getRunnerOutputOutputs getRunnerOutputUsage getRunnerScore getTripleFirst getTripleSecond getTripleThird getUsageCPUtime getUsageInBytes getUsageMemBytes getUsageOutBytes getUsageRuntime getUsageStatus getUsageThreads getWhenFail getWhenPass getenv globToRegExp groupBy head icmp in inf int intbase integerToByte integerToUnicode isEQ isFail isGE isGT isJobOk isLE isLT isNE isNone isPass isPathDir isSome jempty jfilter jfind jlist job jsonEscape killJob lcm len listToTree listToTreeMulti listToVector localRunner logDebug logEcho logError logInfo logNever logReport logWarning machine makeError makeExecPlan makeJSONRunner makeJSONRunnerPlan makeLogLevel makeLogLevel2 makePlan makeRunner makeShellPlan map mapFlat mapPartial matches max min nan ofilter omap omapPartial or orElse parseJSONBody parseJSONFile path pi powm preloadRunner prepend prependPlanPath prettyJSON prettyJSONFormat print printLevel println printlnLevel prod quote rOK read regExpCat regExpToString relative replace reverse rmap rmapFail rmapPass root runIncrementalJob runJob runJobWith scanl scanr scmp scmpCanonical scmpIdentifier scmpLowercase seq setEnvironment setErrorCause setErrorStack setJSONFormatDouble setJSONFormatIndent setJSONFormatInteger setJSONFormatString setJSONRunnerPlanEstimate setJSONRunnerPlanExtraArgs setJSONRunnerPlanExtraEnv setJSONRunnerPlanRawScript setJSONRunnerPlanScore setJobTag setPairFirst setPairSecond setPlanCommand setPlanDirectory setPlanEcho setPlanEnvVar setPlanEnvironment setPlanFnInputs setPlanFnOutputs setPlanKeep setPlanLabel setPlanLocalOnly setPlanOnce setPlanPersistence setPlanResources setPlanRunnerFilter setPlanShare setPlanStderr setPlanStdin setPlanStdout setPlanUsage setPlanVisible setRunnerInputCommand setRunnerInputDirectory setRunnerInputEnvironment setRunnerInputLabel setRunnerInputPrefix setRunnerInputRecord setRunnerInputResources setRunnerInputStdin setRunnerInputVisible setRunnerName setRunnerOutputInputs setRunnerOutputOutputs setRunnerOutputUsage setRunnerScore setTripleFirst setTripleSecond setTripleThird setUsageCPUtime setUsageInBytes setUsageMemBytes setUsageOutBytes setUsageRuntime setUsageStatus shellJob simplify sortBy sortPaths sortStrings splitAt splitBy splitUntil sqrt stack str strHex strOctal strbase stringToRegExp strlen sum sysname tab tail take takeUntil tap tappi tat tcontains tdelete tdistinctBy tdistinctRunBy tdrop tdropUntil tempty tequal texists tfilter tfind tfold tfoldl tfoldmap tfoldr tforall tinsert tinsertMulti tinsertReplace tintersect tlen tlowerGE tlowerGT tmax tmin tnew tokenize transpose treeToList treeToVector tsplit tsplitAt tsplitBy tsplitUntil tsubset tsubtract ttake ttakeUntil tunion tunionMulti tupperLE tupperLT unicodeCanonical unicodeIdentifier unicodeLowercase unicodeToInteger unreachable unsetEnvironment unzip vat vcmp vdistinctBy vdistinctRunBy vdrop vdropUntil vectorToList vectorToTree vectorToTreeMulti vempty version vexists vfilter vfind vflatten vfoldl vfoldr vforall virtualRunner vlen vmap vmapPartial vmapPartial2 vmapReduce vmapScan vreverse vscan vscanl vscanr vseq vsortBy vsplitAt vsplitBy vsplitUntil vtab vtake vtakeUntil vtranspose vunfoldl vunzip vzip wOK wait wakePath which whichIn workspace xOK xor zip
from v0_24_wake export def unary ! + +. - -. ~ ∏ ∏. ∑ ∑. √ ∛ ∜
from v0_24_wake export def binary != !=* !=. !=^ !=~ $ % && * *. + ++ +. , - -. . / /. /../ // /| ; < <* <. << <= <=* <=. <=> <=>* <=>. <=>^ <=>~ <=^ <=~ <^ <~ == ==* ==. ==/ ==^ ==~ > >* >. >= >=* >=. >=^ >=~ >> >^ >~ ^ ^. | || → ∈ ∉ ∋ ∌ ∘ ∩ ∪ ⊆ ⊇ ⊈ ⊉ ⊊ ⊋ ⊎
from v0_24_wake export topic environment path runner source

from v0_24_wake export def getJobResultOutput=getJobOutput getJobResultOutputs=getJobOutputs


# Functions returning a single `Path` can easily extract it from the `Result`

from internals_wake import def Path BadPath # Path constructor stays private!

export def makeBadPath (error: Error): Path =
  BadPath error

def wrapBadPath (pathResult: Result Path Error): Path =
    match pathResult
        Pass path  = path
        Fail error = makeBadPath error


export def claimFileAsPath (existingFile: String) (desiredWorkspacePath: String): Path =
    from v0_24_wake import claimFileAsPath
    claimFileAsPath existingFile desiredWorkspacePath
    | wrapBadPath

export def claimFileAsPathIn (outputDirectory: Path) (existingFile: String) (desiredWorkspacePath: String): Path =
    from v0_24_wake import claimFileAsPathIn
    claimFileAsPathIn outputDirectory existingFile desiredWorkspacePath
    | wrapBadPath

export def getJobOutput (job: Job): Path =
    from v0_24_wake import getJobOutput
    getJobOutput job
    | wrapBadPath

export def installAs (dest: String) (file: Path): Path =
    from v0_24_wake import installAs
    installAs dest file
    | wrapBadPath

export def installIn (toRoot: String) (fromRoot: String) (sourcePath: Path): Path =
    from v0_24_wake import installIn
    installIn toRoot fromRoot sourcePath
    | wrapBadPath

export def mkdir (path: String): Path =
    from v0_24_wake import mkdir
    mkdir path
    | wrapBadPath

export def mkdirIn (parent: Path) (mode: Integer) (name: String): Path =
    from v0_24_wake import mkdirIn
    mkdirIn parent mode name
    | wrapBadPath

export def write (path: String) (content: String): Path =
    from v0_24_wake import write
    write path content
    | wrapBadPath

export def writeIn (parent: Path) (mode: Integer) (name: String) (content: String): Path =
    from v0_24_wake import writeIn
    writeIn parent mode name content
    | wrapBadPath

export def source (file: String): Path =
    from v0_24_wake import source
    source file
    | wrapBadPath


# Every other function returning `Result` post-0.24 needs some degree of reimplementation

def treeCompat job typ =
    def tree j t =
        prim "job_tree"
    def treeOk (Pair f h) = match h
        "BadHash" = makeBadPath (makeError "Could not hash {f}")
        _         = Path f
    def mapPath = match _
        Fail e = makeBadPath e, Nil
        Pass l = map treeOk l
    tree job typ
    | mapPath

export def getJobInputs (job: Job): List Path =
    if isJobOk job then
        getJobFailedInputs job
    else
        makeBadPath "Non-zero exit status ({format job.getJobStatus}) for '{job.getJobDescription}'".makeError, Nil

export def getJobOutputs (job: Job): List Path =
    if isJobOk job then
        getJobFailedOutputs job
    else
        makeBadPath "Non-zero exit status ({format job.getJobStatus}) for '{job.getJobDescription}'".makeError, Nil

export def getJobFailedInputs (job: Job): List Path =
    treeCompat job 1

export def getJobFailedOutputs (job: Job): List Path =
    treeCompat job 2


export def sources (dir: String) (filterRegexp: RegExp): List Path =
    def scan dir regexp =
        prim "sources"
    scan dir filterRegexp
    | map source
