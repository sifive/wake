# comment
def five = 5


# ordinary comment
def name Unit =
    def other = @here
    def other =
        "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
    another


def name Unit =
    def other = @here
    def other = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
    another


global export def glob1 = 34


# ordinary comment
def name Unit =
    def other = @here
    def other = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
    another


# wake-format off
def name Unit =
  def other = here
  # wake-format off
  def other = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
  another


def name Unit =
    # wake-format off
    def other = here
    def other = @here
    another


def name Unit =
    def other = @here
    # wake-format off
    def other = here
    def other = @here
    another


def name Unit =
    def other = @here
    # wake-format off
    def other = here
    def other = @here
    another


def name Unit =
    # ordinary comment
    def other = @here
    def other = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
    another


def t1 = match _
    0 = 0
    n = 2 + t (n - 1)


# wake-format off
def t1 =match _
  0=0
  n = 2+t(n-1)


def t1 = match _
    # wake-format off
    0=0
    n = 2 + t (n - 1)


def t1 = match _
    0 = 0
    # wake-format off
    n = 2+t(n-1)


def t1 = match _
    # wake-format off
    0=0
    # wake-format off
    n = 2+t(n-1)


def t1 = match _
    # many
    # comments
    # wake-format off
    0=0
    # many
    # more
    # comments
    n = 2 + t (n - 1)


def t2 = ((x + 7) * 3)


def t4 = (
    # comment
    x + 5
)


def t4 = (
    # comment
    (
        # comment
        x + 5
    )
)


def t5 = (
    # comment
    # comment
    # comment
    x + 5
)


def t7 = (
    x # comment
    + 5
)


def t8 = (
    x
    + # comment
    5
)


def t9 = (
    x + 5 # comment
)


def t10 = (
    x, # comment
    5
)


def name Unit = # wake-format off
    def other = here
    def other = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
    another


def t3 = ( # comment
    x + 5
)


def t6 = ( # comment
    # comment
    # comment
    x + 5
)


def t8 = (
    # comment
    x # comment
    + # comment
    5 # comment
    - # comment
    2 # comment
)


def t9 = x + 5 - 2


def ff = a | b | c | d


def ff = a $ b $ c $ d


def ff =
    aaaaaaaaaaaaa
    | bbbbbbbbbbbbbbbb
    | cccccccccccccccccc
    | ddddddddddddddddddd
    | eeeeeeeeeeeeeee
    | ffffffffff
    | ggggggggggg
    | hhhhhhhhhhh


def ff =
    aaaaaaaaaaaaa
    $ bbbbbbbbbbbbbbbb
    $ cccccccccccccccccc
    $ ddddddddddddddddddd
    $ eeeeeeeeeeeeeee
    $ ffffffffff
    $ ggggggggggg
    $ hhhhhhhhhhh


def ff =
    aaaaaaaaaaaaa,
    bbbbbbbbbbbbbbbb,
    cccccccccccccccccc,
    ddddddddddddddddddd,
    eeeeeeeeeeeeeee,
    ffffffffff,
    ggggggggggg,
    hhhhhhhhhhh


def ff =
    aaaaaaaaaaaaa
    .bbbbbbbbbbbbbbbb
    .cccccccccccccccccc
    .ddddddddddddddddddd
    .eeeeeeeeeeeeeee
    .ffffffffff
    .ggggggggggg
    .hhhhhhhhhhh


def wakeToTestDir Unit = match (subscribe wakeTestBinary)
    buildTestWake, Nil =
        require Pass (Pair path visible) = buildTestWake Unit
        Pass (Pair (simplify "{path}/..") visible)
    Nil = Pass (Pair "{wakePath}" Nil)
    _ = Fail (makeError "Two wake binaries declared for testing!")


def wakeToTestDir Unit = match (subscribe wakeTestBinary)
    buildTestWake, Nil =
        require (
            Pass
            # comment
            (
                Pair path visible
            )
        ) = buildTestWake Unit
        Pass (Pair (simplify "{path}/..") visible)
    Nil = Pass (Pair "{wakePath}" Nil)
    _ = Fail (makeError "Two wake binaries declared for testing!")


package test_wake

from wake import _
from wake import source , Nil
from test_wake import topic wakeTestBinary
from gcc_wake import compileC linkO
from wake import myMap=map foldl myFoldr=foldr
from wake import def unary + -
from wake import type Pair Result
from wake import source,Nil
export topic wakeTestBinary: Unit => Result (Pair String (List Path)) Error
export topic compileC: (
    Pair
    String
    ((extraFlags: List String) => (headers: List Path) => (cfile: Path) => Result (List Path) Error)
)
topic linkO: (
    Pair
    String
    ((extraFlags: List String) => (objects: List Path) => (targ: String) => Result (List Path) Error)
)
export topic path: String
export topic wakeUnitTestBinary: (variant: Pair String String) => Result (List Path) Error
global export topic glob1: String
global topic glob1: String
def app1 =
    Pair # comment
    "a"
    "b"


def app = Pair "a" "b"


# TODO: The trailing NL here causes a failure for 'fits all' which is why this is NL'd
def app =
    Pair "a" "b" # comment



def app =
    Pair "a" "b" # comment



def app =
    Pair
    "a" # comment
    "b"


def app =
    Pair # comment
    "a" # comment
    "b" # comment



def app =
    aaaaaaaaaa
    bbbbbbbbbbbbbbbb
    cccccccccccccccccc
    ddddddddddddddddddd
    eeeeeeeeeeeeeee
    ffffffffff
    gggggggggggggggggggg
    hhhhhhhhhhhhhh


def t1 = match _
    0 = 0
    n # comment
    = 2 + t (n - 1)


def t1 = match _
    # comment
    0 = 0
    n = 2 + t (n - 1)


def t1 = match _
    0 = 0
    # comment
    n = 2 + t (n - 1)


publish wakeTestBinary = defaultWake, Nil

publish animal = "Cat", Nil

publish animal = replace `u` "o" "Mouse", Nil

publish compileC = makeCompileC "native-c11-debug" (which "cc") (c11Flags ++ debugCFlags)

publish path = match (getenv "WAKE_PATH")
    Some x = tokenize `:` x
    None = Nil

publish path = match sysname
    "Darwin" = "/opt/local/bin", "/usr/local/bin", Nil
    "FreeBSD" = "/usr/local/bin", Nil
    _ = Nil

publish compileC = emccFn (makeCompileC "wasm-c11-release" _ ("-std=gnu11", emscriptenCFlags))

publish compileC =
    emccFn
    (makeCompileC "wasm-c11-release" _ ("-std=gnu11", emscriptenCFlags) (another) ("thing" "here"))

publish compileC = # comment
 emccFn (makeCompileC "wasm-c11-release" _ ("-std=gnu11", emscriptenCFlags))

publish compileC =
    # comment
    emccFn (makeCompileC "wasm-c11-release" _ ("-std=gnu11", emscriptenCFlags))

global export target fib n = match n
    0 = 1
    1 = 1
    _ = fib (n - 1) + fib (n - 2)

def buildRE2WASM Unit =
    def version = "2021-08-01"
    require Some emmake = emmake
    else
        # comment
        failWithError "emmake is not available"
    def emsdk = replace `/[^/]*$` "" emmake
    require Pass patch = source "{@here}/re2.patch"
    require Pass buildDir = vendorBuildDir Unit
    def job =
        """
            cd .build
            wget https://github.com/google/re2/archive/refs/tags/%{version}.tar.gz
            tar xvzf %{version}.tar.gz
            cd re2-%{version}
            patch -p0 < ../../%{relative @here patch.getPathName}
            emmake make -j4 RE2_CXXFLAGS="-std=c++14 -I. -Wall -DNO_THREADS" CXXFLAGS="-O2" obj/libre2.a
        """
        | makePlan "compiling re2" (buildDir, patch, Nil)
        | editPlanEnvironment (addEnvironmentPath emsdk)
        | setPlanDirectory @here
        | runJob
    require Pass outputs = job.getJobOutputs
    def headers = filter (matches `.*\.h` _.getPathName) outputs
    def objects = filter (matches `.*\.o` _.getPathName) outputs
    def cflags = "-I{@here}/.build/re2-{version}", Nil
    def lflags = Nil
    Pass (SysLib "1.0" headers objects cflags lflags)


def t5 = a.b.c


